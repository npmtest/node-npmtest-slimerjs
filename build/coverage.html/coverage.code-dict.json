{"/home/travis/build/npmtest/node-npmtest-slimerjs/test.js":"/* istanbul instrument in package npmtest_slimerjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-slimerjs/lib.npmtest_slimerjs.js":"/* istanbul instrument in package npmtest_slimerjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_slimerjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_slimerjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-slimerjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-slimerjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_slimerjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_slimerjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_slimerjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_slimerjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_slimerjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_slimerjs.__dirname + '/lib.npmtest_slimerjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/phantom-protocol.js":"/**\n * Exposes necessary information so slimerjs will work with phantom drivers.\n */\nvar path = require('path');\nexports.path = path.join(__dirname, '../', 'src', 'slimerjs');\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/g.js":"let foo = 'bar';\n\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/h.js":"var webpage = require('webpage').create();\nwebpage\n  .open('http://slimerjs.org')\n  .then(function() {\n    // store a screenshot of the page\n    webpage.viewportSize = { width:650, height:320 };\n    webpage.render('page.png',\n                   { onlyViewport:true });\n    slimer.exit();\n});\n\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/callPhantom.js":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nlet Cu = Components.utils;\nlet Ci = Components.interfaces;\nlet Cc = Components.classes;\n\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nCu.import(\"resource://gre/modules/Services.jsm\");\nCu.import('resource://slimerjs/slUtils.jsm');\n\nvar listErrorName = ['Error','EvalError','InternalError','RangeError','ReferenceError',\n                     'SyntaxError','TypeError','URIError'];\n\n\nfunction callPhantomAPI() {}\n\ncallPhantomAPI.prototype = {\n\n    classID: Components.ID(\"{4e2fc2ea-f8b9-456b-a421-71039eb8dcd0}\"),\n\n    QueryInterface: XPCOMUtils.generateQI(\n                                          [Ci.nsIDOMGlobalPropertyInitializer,\n                                           Ci.nsISupports]\n                                          ),\n\n    init: function (aWindow) {\n        let self = this;\n        this.window = XPCNativeWrapper.unwrap(aWindow);\n        this.webpage = slUtils.getWebpageFromContentWindow(aWindow);\n        return function() {\n            var arg = (arguments.length?arguments[0]:null);\n            if (!self.webpage) {\n                dump(\"Error: no webpage found when calling callPhantom\\n\")\n                return;\n            }\n            if (self.webpage.onCallback) {\n                try {\n                    let result = self.webpage.onCallback(arg);\n                    if (typeof result == \"object\") {\n                        let expose = {}\n                        for (let p in result) {\n                            expose[p] = 'rw';\n                        }\n                        result.__exposedProps__ = expose;\n                    }\n                    return result;\n                }\n                catch(e) {\n                    // an erro occured in the callback defined in the user script.\n                    if (typeof e == 'object') {\n                        // we cannot throw directly the catch error: since Gecko 33\n                        // properties and methods are hidden when passing to the\n                        // non-privileged compartiment. so we throw a new error\n                        // from the unprivileged compartiment.\n                        if ('name' in e && 'message' in e) {\n                            if (listErrorName.indexOf(e.name) != -1) {\n                                throw new self.window[e.name](e.message);\n                            }\n                        }\n                        throw new self.window.Error(\"\"+e);\n                    }\n                    throw e;\n                }\n            }\n        }\n    }\n};\n\nvar NSGetFactory = XPCOMUtils.generateNSGetFactory([callPhantomAPI]);\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/commandline.js":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n\nComponents.utils.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nComponents.utils.import(\"resource://gre/modules/Services.jsm\");\nComponents.utils.import(\"resource://slimerjs/slConfiguration.jsm\");\nComponents.utils.import(\"resource://slimerjs/slUtils.jsm\");\n\nvar envService = Components.classes[\"@mozilla.org/process/environment;1\"].\n          getService(Components.interfaces.nsIEnvironment);\n\nvar httphandler =  Components.classes[\"@mozilla.org/network/protocol;1?name=http\"]\n                    .getService(Components.interfaces.nsIHttpProtocolHandler);\n\n\n/*\nScript handlers are object that can be used to launch a script (intenal or external).\nThese handlers can handle some command line parameter, and then are able to say\nwhich script SlimerJS should execute.\n\nInterface for script handlers:\n\n- setOptionsSpecInto(currentOptionSpec) : indicate all options that it supports on the\n  command line. It should fill the current object. see optionsSpec in slConfiguration.jsm\n\n- isHandledMainScript(). returns true if it is able to indicate the main script to\n  execute. This method is called after setOptionsSpecInto().\n\n- declareScript(nsICommandLine): set to slConfiguration the main script URI.\n  called only if isHandledMainScript() returned true.\n\n*/\n\n// script handler for external js file\nvar externalScriptHandler = {\n    name: 'externalScriptHandler',\n    setOptionsSpecInto : function(currentOptionSpec) {\n        // no specific options\n    },\n\n    isHandledMainScript : function() {\n        // first argument should be the script name\n        return (slConfiguration.args.length && slConfiguration.args[0].substr(0,1) != '-');\n        //dump(\"unknown option \"+slConfiguration.args[0]+\" \\n\");\n        //cmdLine.preventDefault = true\n    },\n    declareScript : function(cmdLine) {\n        let file = null;\n        if (/Mac/i.test(httphandler.oscpu)) {\n            // under MacOS, resolveFile fails with a relative path\n            try {\n                file = cmdLine.resolveFile(slConfiguration.args[0]);\n            }\n            catch(e) {\n                file = slUtils.getAbsMozFile(slConfiguration.args[0], cmdLine.workingDirectory)\n            }\n        }\n        else {\n            file = cmdLine.resolveFile(slConfiguration.args[0]);\n        }\n        if (!file.exists())\n            throw new Error(\"script not found\");\n\n        slConfiguration.mainScriptURI = Services.io.newFileURI(file);\n        slConfiguration.scriptFile = file;\n    }\n}\n\n// example of a script handler that loads an script from a specifique URI/namespace\nvar helloScriptHandler = {\n    name : 'helloScriptHandler',\n    setOptionsSpecInto : function(currentOptionSpec) {\n        currentOptionSpec.helloworld = ['hello-world', 'bool', false, true];\n    },\n    isHandledMainScript : function() {\n        return slConfiguration.helloworld;\n    },\n    declareScript : function(cmdLine) {\n        slConfiguration.mainScriptURI = Services.io.newURI('resource://slimerjs/hello/world.js', null, null);\n        slConfiguration.scriptModulePath = 'hello/';\n        slConfiguration.args.unshift(slConfiguration.mainScriptURI.spec);\n    }\n}\n\n\n\n// Script handler for GhostDriver\nvar webDriverScriptHandler = {\n    name : 'webDriverScriptHandler',\n    _getDir : function() {\n        var appDir = Services.dirsvc.get(\"CurProcD\", Components.interfaces.nsIFile);\n        appDir.append('vendors');\n        appDir.append('ghostdriver');\n        return appDir;\n    },\n    setOptionsSpecInto : function(currentOptionSpec) {\n\n        slConfiguration.baseURIStrictCommonJS.push(this._getDir().path);\n\n        function parse_webdriver(val, cmdlineOpt) {\n            let pos = val.lastIndexOf(':');\n            if ( pos > 0) {\n                slConfiguration.webdriverIp = val.substring(0, pos);\n                slConfiguration.webdriverPort = val.substring(pos+1);\n            }\n            else {\n                slConfiguration.webdriverPort = val;\n            }\n            return val;\n        }\n        //currentOptionSpec.webdriverEngine = ['webdriver-engine', '', null, true];\n        currentOptionSpec.webdriver = [['webdriver', 'wd','w'], parse_webdriver, '', true];\n        currentOptionSpec.webdriverIp = ['', '', '127.0.0.1', true];\n        currentOptionSpec.webdriverPort = ['', '', '8910', true];\n        currentOptionSpec.webdriverLogFile = ['webdriver-logfile', 'file', '', true];\n        currentOptionSpec.webdriverLogLevel = ['webdriver-loglevel',\n                function (val, cmdlineOpt) {\n                    if (!(val == 'ERROR' || val == 'WARN' || val=='INFO' || val == 'DEBUG')) {\n                        throw new Error(\"Invalid value for '\"+cmdlineOpt+\"' option. It should be ERROR, WARN, INFO or DEBUG\");\n                    }\n                    return val;\n                }, 'INFO', true];\n        currentOptionSpec.webdriverSeleniumGridHub = ['webdriver-selenium-grid-hub', 'url', '', true];\n    },\n    isHandledMainScript : function() {\n        return (slConfiguration.webdriver != '');\n    },\n    declareScript : function(cmdLine) {\n        slConfiguration.scriptFile = this._getDir();\n        slConfiguration.scriptFile.append('main.js');\n        slConfiguration.mainScriptURI = Services.io.newFileURI(slConfiguration.scriptFile);\n        slConfiguration.args.unshift(slConfiguration.mainScriptURI.spec);\n\n        slConfiguration.args.push(\"--ip=\"+slConfiguration.webdriverIp);\n        slConfiguration.args.push(\"--port=\"+slConfiguration.webdriverPort);\n\n        if (slConfiguration.webdriverSeleniumGridHub) {\n            slConfiguration.args.push(\"--hub=\"+slConfiguration.webdriverSeleniumGridHub);\n        }\n\n        if (slConfiguration.webdriverLogFile) {\n            slConfiguration.args.push(\"--logFile=\"+slConfiguration.webdriverLogFile);\n            slConfiguration.args.push(\"--logColor=false\");\n        }\n\n        slConfiguration.args.push(\"--logLevel=\"+slConfiguration.webdriverLogLevel);\n        slConfiguration.enableCoffeeScript = false;\n    }\n}\n\n\n/**\n * The main command line handler of SlimerJS\n */\nfunction slCommandLine() {\n}\n\nslCommandLine.prototype = {\n\n    classID: Components.ID(\"{00995ba2-223f-4efb-b656-ce98aff7019b}\"),\n    classDescription: \"Command line handler for SlimerJS\",\n    QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsICommandLineHandler]),\n\n    /**\n     * known script handlers\n     */\n    _scriptHandlers : [\n        webDriverScriptHandler,\n        //helloScriptHandler,\n        externalScriptHandler // should be always the last one\n    ],\n\n    // ------- nsICommandLineHandler interface\n\n    handle : function (cmdLine) {\n\n        // clear all caches, so scripts will be truly loaded\n        try {\n            if ('cache2' in Services) {\n                Services.cache2.clear();\n            }\n            else {\n                // GECKO <31\n                Services.cache.evictEntries(Services.cache.STORE_ANYWHERE);\n            }\n        } catch(ex) {\n            dump(\"error cache service:\"+ ex+\"\\n\");\n        }\n\n        // retrieve environment variables\n        if (envService.exists('__SLIMER_ENV')) {\n            let envs = envService.get('__SLIMER_ENV');\n            slConfiguration.setEnvNames(envs.split(/,/));\n        }\n\n        // set working directory\n        slConfiguration.workingDirectory = cmdLine.workingDirectory;\n\n        // bug in mozilla: the -attach-console used during the call of xulrunner\n        // on windows is not \"eat\"\n        cmdLine.handleFlag('attach-console', false)\n\n        // read all options and parameters (except script name and script arguments)\n        try {\n            slConfiguration.handleFlags(cmdLine, this._scriptHandlers);\n        }\n        catch(e) {\n            dump(e+\"\\n\");\n            cmdLine.preventDefault = true\n            return;\n        }\n\n        // let's read all script arguments, so they will be available in system.args\n        this._extractScriptArgs(cmdLine);\n\n        // did a script handler is able to give us the main script to execute?\n        let handler = this._scriptHandlers.filter(function(sh) {\n                return sh.isHandledMainScript();\n            });\n\n        if (handler.length == 0) {\n            // no script handler...\n            let msg;\n            if (slConfiguration.args.length && slConfiguration.args[0].substr(0,1) == '-') {\n                msg = \"unknown option \"+slConfiguration.args[0];\n            }\n            else {\n                msg = \"script is missing\";\n            }\n            Components.utils.reportError(msg);\n            dump(msg+\"\\n\");\n            cmdLine.preventDefault = true\n        }\n        else {\n            // yes, we found a script handler!\n            handler = handler[0];\n            try {\n                handler.declareScript(cmdLine);\n                if (!slConfiguration.mainScriptURI)\n                    throw new Error(\"Internal error: script cannot be defined\");\n            }\n            catch(e) {\n                let msg = (\"getMessage\" in e?e.getMessage() : \"\" +e);\n                Components.utils.reportError(msg);\n                dump(msg + \"\\n\");\n                cmdLine.preventDefault = true\n                return;\n            }\n        }\n\n        // display debug information if needed\n        Components.utils.import(\"resource://slimerjs/slDebug.jsm\");\n        if (DEBUG_CLI) {\n            slDebugLog('Gecko version: '+Services.appinfo.platformVersion);\n            slDebugLog('script args: '+slConfiguration.args.join(' '));\n        }\n        if (DEBUG_CONFIG) {\n            slConfiguration.printDebugConfig();\n        }\n\n        // now XulRunner will open the slimerjs.xul window which\n        // will call slLauncher.\n    },\n\n    get helpInfo () {\n        return \"\\n\";\n    },\n\n    _extractScriptArgs: function(cmdLine) {\n        let nbArgs = cmdLine.length;\n        if (nbArgs == 0) {\n            return;\n        }\n        // The command line parser normalize options:\n        // --flag becomes -flag and --flag==value becomes -flag value\n        // we should store original flags into system.args\n        let realArgs = ''\n        if (envService.exists('__SLIMER_ARGS'))\n            realArgs = envService.get('__SLIMER_ARGS');\n\n        for(let i=0; i < nbArgs; i++) {\n            let arg = cmdLine.getArgument(i);\n            if (arg.charAt(0) == '-' && realArgs) {\n                let r = new RegExp(\"-\"+arg+\"(\\=[^ \\t\\r\\n]+)?\")\n                let result = r.exec(realArgs);\n                if (result) {\n                    if (result[1]) {\n                        i++;\n                        slConfiguration.args.push('-'+arg+'='+cmdLine.getArgument(i));\n                    }\n                    else {\n                        slConfiguration.args.push('-'+arg);\n                    }\n                }\n                else {\n                    slConfiguration.args.push(arg);\n                }\n            }\n            else {\n                slConfiguration.args.push(arg);\n            }\n        }\n        cmdLine.removeArguments(0, nbArgs-1);\n    }\n}\n\n\n\n\n\nvar NSGetFactory = XPCOMUtils.generateNSGetFactory([slCommandLine]);\n\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/ConsoleAPI.js":"/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */\n/* vim: set ft=javascript ts=2 et sw=2 tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/*\n \nThis file comes originally from the source code of Firefox\nhttp://mxr.mozilla.org/mozilla-central/source/dom/base/ConsoleAPI.js\n\nIn the original implementation, methods for the console object\ndo things asynchronously. This is not what we want in SlimerJS.\n\nOur implementation is totally synchronous\n*/\n\nlet Cu = Components.utils;\nlet Ci = Components.interfaces;\nlet Cc = Components.classes;\n\n// The maximum allowed number of concurrent timers per page.\nconst MAX_PAGE_TIMERS = 10000;\n\n// The regular expression used to parse %s/%d and other placeholders for\n// variables in strings that need to be interpolated.\nconst ARGUMENT_PATTERN = /%\\d*\\.?\\d*([osdif])\\b/g;\n\n// The maximum stacktrace depth when populating the stacktrace array used for\n// console.trace().\nconst DEFAULT_MAX_STACKTRACE_DEPTH = 200;\n\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nCu.import(\"resource://gre/modules/Services.jsm\");\nCu.import(\"resource://gre/modules/ConsoleAPIStorage.jsm\");\nCu.import(\"resource://gre/modules/PrivateBrowsingUtils.jsm\");\n\n/**\n * The window.console API implementation. One instance is lazily created for\n * every inner window, when the window.console object is accessed.\n */\nfunction ConsoleAPI() {}\nConsoleAPI.prototype = {\n\n  classID: Components.ID(\"{fe06cc0a-53d5-4004-a5af-c23b4d2e327d}\"),\n\n  QueryInterface: XPCOMUtils.generateQI([Ci.nsIDOMGlobalPropertyInitializer,\n                                         Ci.nsISupportsWeakReference,\n                                         Ci.nsIObserver]),\n\n  _timerInitialized: false,\n  _queuedCalls: null,\n  _window: null,\n  _innerID: null,\n  _outerID: null,\n  _windowDestroyed: false,\n  _timer: null,\n\n  // nsIDOMGlobalPropertyInitializer\n  init: function CA_init(aWindow) {\n    Services.obs.addObserver(this, \"inner-window-destroyed\", true);\n\n    try {\n      let windowUtils = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)\n                          .getInterface(Ci.nsIDOMWindowUtils);\n\n      this._outerID = windowUtils.outerWindowID;\n      this._innerID = windowUtils.currentInnerWindowID;\n    }\n    catch (ex) {\n      Cu.reportError(ex);\n    }\n\n    let self = this;\n    let chromeObject = {\n      // window.console API\n      log: function CA_log() {\n        self.execCall(\"log\", arguments);\n      },\n      info: function CA_info() {\n        self.execCall(\"info\", arguments);\n      },\n      warn: function CA_warn() {\n        self.execCall(\"warn\", arguments);\n      },\n      error: function CA_error() {\n        self.execCall(\"error\", arguments);\n      },\n      debug: function CA_debug() {\n        self.execCall(\"debug\", arguments);\n      },\n      trace: function CA_trace() {\n        self.execCall(\"trace\", arguments);\n      },\n      // Displays an interactive listing of all the properties of an object.\n      dir: function CA_dir() {\n        self.execCall(\"dir\", arguments);\n      },\n      group: function CA_group() {\n        self.execCall(\"group\", arguments);\n      },\n      groupCollapsed: function CA_groupCollapsed() {\n        self.execCall(\"groupCollapsed\", arguments);\n      },\n      groupEnd: function CA_groupEnd() {\n        self.execCall(\"groupEnd\", arguments);\n      },\n      time: function CA_time() {\n        self.execCall(\"time\", arguments);\n      },\n      timeEnd: function CA_timeEnd() {\n        self.execCall(\"timeEnd\", arguments);\n      },\n      profile: function CA_profile() {\n        // Send a notification picked up by the profiler if installed.\n        // This must happen right away otherwise we will miss samples\n        let consoleEvent = {\n          action: \"profile\",\n          arguments: arguments\n        };\n        consoleEvent.wrappedJSObject = consoleEvent;\n        Services.obs.notifyObservers(consoleEvent, \"console-api-profiler\",\n                                     null);  \n      },\n      profileEnd: function CA_profileEnd() {\n        // Send a notification picked up by the profiler if installed.\n        // This must happen right away otherwise we will miss samples\n        let consoleEvent = {\n          action: \"profileEnd\",\n          arguments: arguments\n        };\n        consoleEvent.wrappedJSObject = consoleEvent;\n        Services.obs.notifyObservers(consoleEvent, \"console-api-profiler\",\n                                     null);  \n      },\n      __exposedProps__: {\n        log: \"r\",\n        info: \"r\",\n        warn: \"r\",\n        error: \"r\",\n        debug: \"r\",\n        trace: \"r\",\n        dir: \"r\",\n        group: \"r\",\n        groupCollapsed: \"r\",\n        groupEnd: \"r\",\n        time: \"r\",\n        timeEnd: \"r\",\n        profile: \"r\",\n        profileEnd: \"r\"\n      }\n    };\n\n    // We need to return an actual content object here, instead of a wrapped\n    // chrome object. This allows things like console.log.bind() to work.\n    let contentObj = Cu.createObjectIn(aWindow);\n    function genPropDesc(fun) {\n      return { enumerable: true, configurable: true, writable: true,\n               value: chromeObject[fun].bind(chromeObject) };\n    }\n    const properties = {\n      log: genPropDesc('log'),\n      info: genPropDesc('info'),\n      warn: genPropDesc('warn'),\n      error: genPropDesc('error'),\n      debug: genPropDesc('debug'),\n      trace: genPropDesc('trace'),\n      dir: genPropDesc('dir'),\n      group: genPropDesc('group'),\n      groupCollapsed: genPropDesc('groupCollapsed'),\n      groupEnd: genPropDesc('groupEnd'),\n      time: genPropDesc('time'),\n      timeEnd: genPropDesc('timeEnd'),\n      profile: genPropDesc('profile'),\n      profileEnd: genPropDesc('profileEnd'),\n      __noSuchMethod__: { enumerable: true, configurable: true, writable: true,\n                          value: function() {} },\n      __mozillaConsole__: { value: true }\n    };\n\n    Object.defineProperties(contentObj, properties);\n    Cu.makeObjectPropsNormal(contentObj);\n\n    this._queuedCalls = [];\n    this._timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n    this._window = Cu.getWeakReference(aWindow);\n    this.timerRegistry = {};\n\n    return contentObj;\n  },\n\n  observe: function CA_observe(aSubject, aTopic, aData)\n  {\n    if (aTopic == \"inner-window-destroyed\") {\n      let innerWindowID = aSubject.QueryInterface(Ci.nsISupportsPRUint64).data;\n      if (innerWindowID == this._innerID) {\n        Services.obs.removeObserver(this, \"inner-window-destroyed\");\n        this._windowDestroyed = true;\n        this.timerRegistry = {};\n      }\n    }\n  },\n\n  /**\n   * execute a call to a console method.\n   *\n   * @param string aMethod\n   *        The console method the code has invoked.\n   * @param object aArguments\n   *        The arguments passed to the console method.\n   */\n  execCall: function CA_execCall(aMethod, aArguments)\n  {\n    let metaForCall = {\n      isPrivate: PrivateBrowsingUtils.isWindowPrivate(this._window.get()),\n      timeStamp: Date.now(),\n      stack: this.getStackTrace(aMethod != \"trace\" ? 1 : null),\n    };\n\n    this._processCall([aMethod, aArguments, metaForCall]);\n\n    if (this._windowDestroyed) {\n        ConsoleAPIStorage.clearEvents(this._innerID);\n        this.timerRegistry = {};\n    }\n  },\n\n  /**\n   * Process a call to a console method.\n   *\n   * @private\n   * @param array aCall\n   *        Array that holds information about the call.\n   */\n  _processCall: function CA__processQueuedItem(aCall)\n  {\n    let [method, args, meta] = aCall;\n\n    let frame = meta.stack[0];\n    let consoleEvent = {\n      ID: this._outerID,\n      innerID: this._innerID,\n      level: method,\n      filename: frame.filename,\n      lineNumber: frame.lineNumber,\n      functionName: frame.functionName,\n      timeStamp: meta.timeStamp,\n      arguments: args,\n    };\n\n    switch (method) {\n      case \"log\":\n      case \"info\":\n      case \"warn\":\n      case \"error\":\n      case \"debug\":\n        consoleEvent.arguments = this.processArguments(args);\n        break;\n      case \"trace\":\n        consoleEvent.stacktrace = meta.stack;\n        break;\n      case \"group\":\n      case \"groupCollapsed\":\n      case \"groupEnd\":\n        try {\n          consoleEvent.groupName = Array.prototype.join.call(args, \" \");\n        }\n        catch (ex) {\n          Cu.reportError(ex);\n          Cu.reportError(ex.stack);\n          return;\n        }\n        break;\n      case \"dir\":\n        break;\n      case \"time\":\n        consoleEvent.timer = this.startTimer(args[0], meta.timeStamp);\n        break;\n      case \"timeEnd\":\n        consoleEvent.timer = this.stopTimer(args[0], meta.timeStamp);\n        break;\n      default:\n        // unknown console API method!\n        return;\n    }\n\n    this.notifyObservers(method, consoleEvent, meta.isPrivate);\n  },\n\n  /**\n   * Notify all observers of any console API call.\n   *\n   * @param string aLevel\n   *        The message level.\n   * @param object aConsoleEvent\n   *        The console event object to send to observers for the given console\n   *        API call.\n   * @param boolean aPrivate\n   *        Tells whether the window is in private browsing mode.\n   */\n  notifyObservers: function CA_notifyObservers(aLevel, aConsoleEvent, aPrivate)\n  {\n    aConsoleEvent.wrappedJSObject = aConsoleEvent;\n\n    // Store non-private messages for which the inner window was not destroyed.\n    if (!aPrivate) {\n      ConsoleAPIStorage.recordEvent(this._innerID, aConsoleEvent);\n    }\n\n    Services.obs.notifyObservers(aConsoleEvent, \"console-api-log-event\",\n                                 this._outerID);\n  },\n\n  /**\n   * Process the console API call arguments in order to perform printf-like\n   * string substitution.\n   *\n   * TODO: object substitution should take into account width and precision\n   * qualifiers (bug 685813).\n   *\n   * @param mixed aArguments\n   *        The arguments given to the console API call.\n   **/\n  processArguments: function CA_processArguments(aArguments) {\n    if (aArguments.length < 2 || typeof aArguments[0] != \"string\") {\n      return aArguments;\n    }\n\n    let args = Array.prototype.slice.call(aArguments);\n    let format = args.shift();\n    let splitter = \"%\" + format.length + Date.now() + \"%\";\n    let objects = [];\n\n    // Format specification regular expression.\n    let processed = format.replace(ARGUMENT_PATTERN, function CA_PA_substitute(match, submatch) {\n      switch (submatch) {\n        case \"o\":\n          objects.push(args.shift());\n          return splitter;\n        case \"s\":\n          return String(args.shift());\n        case \"d\":\n        case \"i\":\n          return parseInt(args.shift());\n        case \"f\":\n          return parseFloat(args.shift());\n        default:\n          return submatch;\n      };\n    });\n\n    let result = [];\n    let processedArray = processed.split(splitter);\n    processedArray.forEach(function(aValue, aIndex) {\n      if (aValue !== \"\") {\n        result.push(aValue);\n      }\n      if (objects[aIndex]) {\n        result.push(objects[aIndex]);\n      }\n    });\n\n    return result.concat(args);\n  },\n\n  /**\n   * Build the stacktrace array for the console.trace() call.\n   *\n   * @param number [aMaxDepth=DEFAULT_MAX_STACKTRACE_DEPTH]\n   *        Optional maximum stacktrace depth.\n   * @return array\n   *         Each element is a stack frame that holds the following properties:\n   *         filename, lineNumber, functionName and language.\n   */\n  getStackTrace: function CA_getStackTrace(aMaxDepth) {\n    if (!aMaxDepth) {\n      aMaxDepth = DEFAULT_MAX_STACKTRACE_DEPTH;\n    }\n\n    let stack = [];\n    let frame = Components.stack.caller.caller;\n    while (frame = frame.caller) {\n      if (frame.language == Ci.nsIProgrammingLanguage.JAVASCRIPT ||\n          frame.language == Ci.nsIProgrammingLanguage.JAVASCRIPT2) {\n        stack.push({\n          filename: frame.filename,\n          lineNumber: frame.lineNumber,\n          functionName: frame.name,\n          language: frame.language,\n        });\n        if (stack.length == aMaxDepth) {\n          break;\n        }\n      }\n    }\n\n    return stack;\n  },\n\n  /*\n   * A registry of started timers. Timer maps are key-value pairs of timer\n   * names to timer start times, for all timers defined in the page. Timer\n   * names are prepended with the inner window ID in order to avoid conflicts\n   * with Object.prototype functions.\n   */\n  timerRegistry: null,\n\n  /**\n   * Create a new timer by recording the current time under the specified name.\n   *\n   * @param string aName\n   *        The name of the timer.\n   * @param number [aTimestamp=Date.now()]\n   *        Optional timestamp that tells when the timer was originally started.\n   * @return object\n   *        The name property holds the timer name and the started property\n   *        holds the time the timer was started. In case of error, it returns\n   *        an object with the single property \"error\" that contains the key\n   *        for retrieving the localized error message.\n   **/\n  startTimer: function CA_startTimer(aName, aTimestamp) {\n    if (!aName) {\n        return;\n    }\n    if (Object.keys(this.timerRegistry).length > MAX_PAGE_TIMERS - 1) {\n        return { error: \"maxTimersExceeded\" };\n    }\n    let key = this._innerID + \"-\" + aName.toString();\n    if (!(key in this.timerRegistry)) {\n        this.timerRegistry[key] = aTimestamp || Date.now();\n    }\n    return { name: aName, started: this.timerRegistry[key] };\n  },\n\n  /**\n   * Stop the timer with the specified name and retrieve the elapsed time.\n   *\n   * @param string aName\n   *        The name of the timer.\n   * @param number [aTimestamp=Date.now()]\n   *        Optional timestamp that tells when the timer was originally stopped.\n   * @return object\n   *        The name property holds the timer name and the duration property\n   *        holds the number of milliseconds since the timer was started.\n   **/\n  stopTimer: function CA_stopTimer(aName, aTimestamp) {\n    if (!aName) {\n        return;\n    }\n    let key = this._innerID + \"-\" + aName.toString();\n    if (!(key in this.timerRegistry)) {\n        return;\n    }\n    let duration = (aTimestamp || Date.now()) - this.timerRegistry[key];\n    delete this.timerRegistry[key];\n    return { name: aName, duration: duration };\n  }\n};\n\nthis.NSGetFactory = XPCOMUtils.generateNSGetFactory([ConsoleAPI]);\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/filePicker.js":" \nconst Cc = Components.classes;\nconst Ci = Components.interfaces;\nconst Cr = Components.results;\nconst Cu = Components.utils;\n\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nCu.import(\"resource://gre/modules/Services.jsm\");\nCu.import(\"resource://slimerjs/slUtils.jsm\");\n\n/**\n * implements a file picker that replaces the default filepicker\n * of mozilla. This file picker does not show a dialog\n * and gives file setted by webpage.onFilePicker or webpage.uploadFile\n */\nfunction filePicker() {\n    this.fileName = null;\n    this._nsfile = null;\n    this._nsfiles = [];\n    this.browser = null;\n    this.supportsMultiple = false;\n    this.domWindowUtils = null;\n}\n\nfilePicker.prototype = {\n    classID          : Components.ID(\"{4d447d76-5205-4685-9237-9a35c7349adf}\"),\n    classDescription: \"file picker for SlimerJS\",\n    QueryInterface   : XPCOMUtils.generateQI([Ci.nsIFilePicker]),\n\n    _filterFiles : function(list) {\n        let finalList = []\n        list.forEach(function(file){\n            try {\n                let selectedFile = Cc['@mozilla.org/file/local;1']\n                                .createInstance(Ci.nsILocalFile);\n                selectedFile.initWithPath(file);\n                if (selectedFile.exists()) {\n                    finalList.push(selectedFile);\n                }\n            }\n            catch(e) {\n            }\n        });\n        return finalList;\n    },\n\n    // ------------------------------------- nsIFilePicker interface\n\n    /**\n     * Initialize the file picker widget.  The file picker is not valid until this\n     * method is called.\n     *\n     * @param   nsIDOMWindow   parent   nsIDOMWindow parent.  This dialog will be dependent\n     *                                   on this parent. parent must be non-null.\n     * @param   string   title    The title for the file widget\n     * @param   int   mode     load, save, or get folder (nsIFilePicker.mod*)\n     *\n     */\n    init : function (parent, title, mode) {\n        // retrieve the webpage object corresponding to the parent\n        this.browser = slUtils.getBrowserFromContentWindow(parent);\n        this.domWindowUtils = parent.QueryInterface(Ci.nsIInterfaceRequestor)\n                                    .getInterface(Ci.nsIDOMWindowUtils);\n        this._mode = mode;\n        // take account of mode if multi files\n        if (mode & Ci.nsIFilePicker.modeOpenMultiple) {\n            this.supportsMultiple = true;\n        }\n        else {\n            this.supportsMultiple = false;\n        }\n    },\n\n    _mode : 0,\n\n    /**\n     * The picker's mode, as set by the 'mode' argument passed to init()\n     * (one of the modeOpen et. al. constants specified above).\n     */\n    get mode() {\n        return this._mode;\n    },\n\n    /**\n     * Append to the  filter list with things from the predefined list\n     *\n     * @param   long   filterMask  mask of filters i.e. (filterAll | filterHTML)\n     *\n     */\n    appendFilters : function (filterMask) {\n        // nothing: let's ignore\n    },\n\n    /**\n     * Add a filter\n     *\n     * @param   string   title    name of the filter\n     * @param   string   filter   extensions to filter -- semicolon and space separated\n     *\n     */\n    appendFilter : function (title, filter) {\n        // nothing: let's ignore\n    },\n\n    /**\n     * The filename that should be suggested to the user as a default. This should\n     * include the extension.\n     *\n     * @throws NS_ERROR_FAILURE on attempts to get\n     */\n    defaultString : '',\n\n    /**\n     * The extension that should be associated with files of the type we\n     * want to work with.  On some platforms, this extension will be\n     * automatically appended to filenames the user enters, if needed.  \n     */\n    defaultExtension : '.*',\n\n    /**\n     * The filter which is currently selected in the File Picker dialog\n     *\n     * @return long Returns the index (0 based) of the selected filter in the filter list. \n     */\n    filterIndex : 0,\n\n    /**\n     * Set the directory that the file open/save dialog initially displays\n     *\n     * @param   nsIFile   displayDirectory  the name of the directory\n     *\n     */\n    displayDirectory : null,\n\n    /**\n     * Get the nsIFile for the file or directory.\n     *\n     * @return nsIFile Returns the file currently selected\n     * @readonly\n     */\n    get file () {\n        return this._nsfile;\n    },\n\n    /**\n     * Get the nsIURI for the file or directory.\n     *\n     * @return nsIURI Returns the file currently selected\n     * @readonly\n     */\n    get fileURL () {\n        if (this._nsfile)\n            return Services.io.newFileURI(this._nsfile);\n        return null;\n    },\n\n    /**\n     * Get the enumerator for the selected files\n     * only works in the modeOpenMultiple mode\n     *\n     * @return nsISimpleEnumerator Returns the files currently selected\n     * @readonly\n     */\n    get files () {\n        return slUtils.createSimpleEnumerator(this._nsfiles);\n    },\n\n    /**\n     * Get the nsIDOMFile for the file.\n     *\n     * @return nsIDOMFile Returns the file currently selected as DOMFile\n     * @readonly\n     */\n    get domfile () {\n        if (this._nsfile)\n            return this.domWindowUtils.wrapDOMFile(this._nsfile);\n        return null;\n    },\n\n    /**\n     * Get the enumerator for the selected files\n     * only works in the modeOpenMultiple mode\n     *\n     * @return nsISimpleEnumerator Returns the files currently selected as DOMFiles\n     * @readonly\n     */\n    get domfiles () {\n        let me = this;\n        let list = this._nsfiles.map(function(file){\n            return me.domWindowUtils.wrapDOMFile(file);\n        });\n        return slUtils.createSimpleEnumerator(list);\n    },\n\n    get domFileOrDirectory () {\n        if (this._nsfile)\n            return this.domWindowUtils.wrapDOMFile(this._nsfile);\n        return null;\n    },\n\n    get domFileOrDirectoryEnumerator () {\n        let me = this;\n        let list = this._nsfiles.map(function(file){\n            return me.domWindowUtils.wrapDOMFile(file);\n        });\n        return slUtils.createSimpleEnumerator(list);\n    },\n\n    /**\n     * Controls whether the chosen file(s) should be added to the system's recent\n     * documents list. This attribute will be ignored if the system has no \"Recent\n     * Docs\" concept, or if the application is in private browsing mode (in which\n     * case the file will not be added). Defaults to true.\n     */\n    addToRecentDocs: false,\n\n    /**\n     * Show File Dialog. The dialog is displayed modally.\n     *\n     * @return short returnOK if the user selects OK, returnCancel if the user selects cancel\n     *\n     */\n    show : function () {\n        if (!this.browser || !this.browser.webpage) {\n            return Ci.nsIFilePicker.returnCancel;\n        }\n\n        let oldFile = '';\n        if (this.defaultString != '' && this.displayDirectory) {\n            let f = this.displayDirectory.clone();\n            f.append(this.defaultString);\n            oldFile = f.path;\n        }\n\n        // call the onFilePicker callback on the corresponding webpage\n        let selectedFileName = '';\n        let selectedFiles = [];\n        if (this.browser.webpage.onFilePicker) {\n            // the callback receives the old selected file\n            // and should returns the new file.\n            selectedFileName = this.browser.webpage.onFilePicker(oldFile);\n            if (selectedFileName) {\n                if (!Array.isArray(selectedFileName))\n                    selectedFiles = this._filterFiles([selectedFileName]);\n                else\n                    selectedFiles = this._filterFiles(selectedFileName);\n            }\n        }\n\n        // if no file is given, take the file set by webpage.uploadFile()\n        if (!selectedFiles.length\n            && 'uploadFiles' in this.browser\n            && this.browser.uploadFiles.length != 0) {\n            selectedFiles = this.browser.uploadFiles;\n        }\n        this._nsfiles = selectedFiles;\n        if (selectedFiles.length) {\n            this._nsfile = selectedFiles[0];\n            if (!this.supportsMultiple) {\n                this._nsfiles = [selectedFiles[0]];\n            }\n            this.browser.uploadFilesReaded = true;\n            return Ci.nsIFilePicker.returnOK;\n        }\n        else {\n            this._nsfile = null;\n            this.browser.uploadFilesReaded = true;\n            return Ci.nsIFilePicker.returnCancel;\n        }\n    },\n\n    /**\n     * Opens the file dialog asynchrounously.\n     * The passed in object's done method will be called upon completion.\n     * @param nsIFilePickerShownCallback aFilePickerShownCallback\n     */\n    open : function (aFilePickerShownCallback) {\n        let res = this.show();\n        aFilePickerShownCallback.done(res);\n    }\n}\n\nthis.NSGetFactory = XPCOMUtils.generateNSGetFactory([filePicker]);\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/helperAppDialog.js":"\"use strict\";\n\n/*\n * overrides nsHelperAppDlg.js\n *\n * the goal is to avoid dialog when a file is downloaded\n */\n\nconst Ci = Components.interfaces;\nconst Cc = Components.classes;\nconst Cu = Components.utils;\n\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nCu.import('resource://slimerjs/slUtils.jsm');\n\n/*\nXPCOMUtils.defineLazyModuleGetter(this, \"Downloads\",\n  \"resource://gre/modules/Downloads.jsm\");\n*/\nXPCOMUtils.defineLazyModuleGetter(this, \"Services\",\n  \"resource://gre/modules/Services.jsm\");\n\nXPCOMUtils.defineLazyModuleGetter(this, \"FileUtils\",\n  \"resource://gre/modules/FileUtils.jsm\");\n\n//XPCOMUtils.defineLazyModuleGetter(this, \"Task\",\n// \"resource://gre/modules/Task.jsm\");\n\n//let downloadModule = {};\n//Cu.import(\"resource://gre/modules/DownloadLastDir.jsm\", downloadModule);\n\n\nfunction unknownContentTypeDialog() {\n}\n\nunknownContentTypeDialog.prototype = {\n    show: function(aLauncher, aWindowContext, aReason)  {\n        try {\n            aLauncher.saveToDisk(null, false);\n        } catch(e) {\n            Cu.reportError(\"nsUnknownContentTypeDialog.show \"+e)\n        }\n    },\n\n    promptForSaveToFileAsync: function(aLauncher, aWindowContext, aDefaultFileName,\n                                       aSuggestedFileExtension, aForcePrompt) {\n        let webpage = slUtils.getWebpageFromContentWindow(aWindowContext);\n\n        let suggestedFile = aDefaultFileName? aDefaultFileName: aLauncher.suggestedFileName;\n        if (suggestedFile == '') {\n            if (aLauncher.source.path != '/') {\n                suggestedFile = aLauncher.source.path.replace(\"/\", \"_\") + \".\" + aSuggestedFileExtension;\n            }\n            else {\n                suggestedFile = aLauncher.source.host + \".\" + aSuggestedFileExtension;\n            }\n        }\n\n        let responseData = {\n            filename: suggestedFile,\n            size : aLauncher.contentLength,\n            contentType: aLauncher.MIMEInfo.type\n        };\n\n        let filename = webpage.fileDownload(aLauncher.source.spec, responseData);\n        if (!filename) {\n            aLauncher.saveDestinationAvailable(null);\n            return;\n        }\n        let file = slUtils.getAbsMozFile(filename, slUtils.workingDirectory);\n\n        if (file.exists() && file.isDirectory()) {\n            if (!file.isWritable()) {\n                webpage.fileDownloadError(\"Requested path is not writable\");\n                aLauncher.saveDestinationAvailable(null);\n                return;\n            }\n            file.append(aDefaultFileName);\n        }\n        else if (file.parent.exists() && !file.parent.isWritable()) {\n            webpage.fileDownloadError(\"Requested path is not writable\");\n            aLauncher.saveDestinationAvailable(null);\n            return;\n        }\n        aLauncher.saveDestinationAvailable(file);\n    },\n    classDescription: 'Unknown Content Type Dialog placeholder',\n    classID: Components.ID(\"{04c5992d-c6a5-4138-9b75-b03ead2be0f1}\"),\n    contractID: '@mozilla.org/helperapplauncherdialog;1',\n    QueryInterface : XPCOMUtils.generateQI([Ci.nsIHelperAppLauncherDialog, Ci.nsITimerCallback])\n};\n\nthis.NSGetFactory = XPCOMUtils.generateNSGetFactory([unknownContentTypeDialog]);\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/httpd.js":"/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// SlimerJS: this file is a modified version of\n// http://mxr.mozilla.org/mozilla-central/source/netwerk/test/httpserver/httpd.js\n\n/*\n * An implementation of an HTTP server both as a loadable script and as an XPCOM\n * component.  See the accompanying README file for user documentation on\n * httpd.js.\n */\n\nthis.EXPORTED_SYMBOLS = [\n  \"HTTP_400\",\n  \"HTTP_401\",\n  \"HTTP_402\",\n  \"HTTP_403\",\n  \"HTTP_404\",\n  \"HTTP_405\",\n  \"HTTP_406\",\n  \"HTTP_407\",\n  \"HTTP_408\",\n  \"HTTP_409\",\n  \"HTTP_410\",\n  \"HTTP_411\",\n  \"HTTP_412\",\n  \"HTTP_413\",\n  \"HTTP_414\",\n  \"HTTP_415\",\n  \"HTTP_417\",\n  \"HTTP_500\",\n  \"HTTP_501\",\n  \"HTTP_502\",\n  \"HTTP_503\",\n  \"HTTP_504\",\n  \"HTTP_505\",\n  \"HttpError\",\n  \"HttpServer\",\n];\n\nComponents.utils.import(\"resource://gre/modules/XPCOMUtils.jsm\");\n\nconst Cc = Components.classes;\nconst Ci = Components.interfaces;\nconst Cr = Components.results;\nconst Cu = Components.utils;\nconst CC = Components.Constructor;\n\nconst PR_UINT32_MAX = Math.pow(2, 32) - 1;\n\n/** True if debugging output is enabled, false otherwise. */\nvar DEBUG = false; // non-const *only* so tweakable in server tests\n\n/** True if debugging output should be timestamped. */\nvar DEBUG_TIMESTAMP = false; // non-const so tweakable in server tests\n\nvar gGlobalObject = this;\n\n/**\n * Asserts that the given condition holds.  If it doesn't, the given message is\n * dumped, a stack trace is printed, and an exception is thrown to attempt to\n * stop execution (which unfortunately must rely upon the exception not being\n * accidentally swallowed by the code that uses it).\n */\nfunction NS_ASSERT(cond, msg)\n{\n  if (DEBUG && !cond)\n  {\n    dumpn(\"###!!!\");\n    dumpn(\"###!!! ASSERTION\" + (msg ? \": \" + msg : \"!\"));\n    dumpn(\"###!!! Stack follows:\");\n\n    var stack = new Error().stack.split(/\\n/);\n    dumpn(stack.map(function(val) { return \"###!!!   \" + val; }).join(\"\\n\"));\n\n    throw Cr.NS_ERROR_ABORT;\n  }\n}\n\n/** Constructs an HTTP error object. */\nthis.HttpError = function HttpError(code, description)\n{\n  this.code = code;\n  this.description = description;\n}\nHttpError.prototype =\n{\n  toString: function()\n  {\n    return this.code + \" \" + this.description;\n  }\n};\n\n/**\n * Errors thrown to trigger specific HTTP server responses.\n */\nthis.HTTP_400 = new HttpError(400, \"Bad Request\");\nthis.HTTP_401 = new HttpError(401, \"Unauthorized\");\nthis.HTTP_402 = new HttpError(402, \"Payment Required\");\nthis.HTTP_403 = new HttpError(403, \"Forbidden\");\nthis.HTTP_404 = new HttpError(404, \"Not Found\");\nthis.HTTP_405 = new HttpError(405, \"Method Not Allowed\");\nthis.HTTP_406 = new HttpError(406, \"Not Acceptable\");\nthis.HTTP_407 = new HttpError(407, \"Proxy Authentication Required\");\nthis.HTTP_408 = new HttpError(408, \"Request Timeout\");\nthis.HTTP_409 = new HttpError(409, \"Conflict\");\nthis.HTTP_410 = new HttpError(410, \"Gone\");\nthis.HTTP_411 = new HttpError(411, \"Length Required\");\nthis.HTTP_412 = new HttpError(412, \"Precondition Failed\");\nthis.HTTP_413 = new HttpError(413, \"Request Entity Too Large\");\nthis.HTTP_414 = new HttpError(414, \"Request-URI Too Long\");\nthis.HTTP_415 = new HttpError(415, \"Unsupported Media Type\");\nthis.HTTP_417 = new HttpError(417, \"Expectation Failed\");\n\nthis.HTTP_500 = new HttpError(500, \"Internal Server Error\");\nthis.HTTP_501 = new HttpError(501, \"Not Implemented\");\nthis.HTTP_502 = new HttpError(502, \"Bad Gateway\");\nthis.HTTP_503 = new HttpError(503, \"Service Unavailable\");\nthis.HTTP_504 = new HttpError(504, \"Gateway Timeout\");\nthis.HTTP_505 = new HttpError(505, \"HTTP Version Not Supported\");\n\n/** Creates a hash with fields corresponding to the values in arr. */\nfunction array2obj(arr)\n{\n  var obj = {};\n  for (var i = 0; i < arr.length; i++)\n    obj[arr[i]] = arr[i];\n  return obj;\n}\n\n/** Returns an array of the integers x through y, inclusive. */\nfunction range(x, y)\n{\n  var arr = [];\n  for (var i = x; i <= y; i++)\n    arr.push(i);\n  return arr;\n}\n\n/** An object (hash) whose fields are the numbers of all HTTP error codes. */\nconst HTTP_ERROR_CODES = array2obj(range(400, 417).concat(range(500, 505)));\n\n\n/**\n * The character used to distinguish hidden files from non-hidden files, a la\n * the leading dot in Apache.  Since that mechanism also hides files from\n * easy display in LXR, ls output, etc. however, we choose instead to use a\n * suffix character.  If a requested file ends with it, we append another\n * when getting the file on the server.  If it doesn't, we just look up that\n * file.  Therefore, any file whose name ends with exactly one of the character\n * is \"hidden\" and available for use by the server.\n */\nconst HIDDEN_CHAR = \"^\";\n\n/**\n * The file name suffix indicating the file containing overridden headers for\n * a requested file.\n */\nconst HEADERS_SUFFIX = HIDDEN_CHAR + \"headers\" + HIDDEN_CHAR;\n\n/** Type used to denote SJS scripts for CGI-like functionality. */\nconst SJS_TYPE = \"sjs\";\n\n/** Base for relative timestamps produced by dumpn(). */\nvar firstStamp = 0;\n\n/** dump(str) with a trailing \"\\n\" -- only outputs if DEBUG. */\nfunction dumpn(str)\n{\n  if (DEBUG)\n  {\n    var prefix = \"HTTPD-INFO | \";\n    if (DEBUG_TIMESTAMP)\n    {\n      if (firstStamp === 0)\n        firstStamp = Date.now();\n\n      var elapsed = Date.now() - firstStamp; // milliseconds\n      var min = Math.floor(elapsed / 60000);\n      var sec = (elapsed % 60000) / 1000;\n\n      if (sec < 10)\n        prefix += min + \":0\" + sec.toFixed(3) + \" | \";\n      else\n        prefix += min + \":\" + sec.toFixed(3) + \" | \";\n    }\n\n    dump(prefix + str + \"\\n\");\n  }\n}\n\n/** Dumps the current JS stack if DEBUG. */\nfunction dumpStack()\n{\n  // peel off the frames for dumpStack() and Error()\n  var stack = new Error().stack.split(/\\n/).slice(2);\n  stack.forEach(dumpn);\n}\n\n\n/** The XPCOM thread manager. */\nvar gThreadManager = null;\n\n/** The XPCOM prefs service. */\nvar gRootPrefBranch = null;\nfunction getRootPrefBranch()\n{\n  if (!gRootPrefBranch)\n  {\n    gRootPrefBranch = Cc[\"@mozilla.org/preferences-service;1\"]\n                        .getService(Ci.nsIPrefBranch);\n  }\n  return gRootPrefBranch;\n}\n\n/**\n * JavaScript constructors for commonly-used classes; precreating these is a\n * speedup over doing the same from base principles.  See the docs at\n * http://developer.mozilla.org/en/docs/Components.Constructor for details.\n */\nconst ServerSocket = CC(\"@mozilla.org/network/server-socket;1\",\n                        \"nsIServerSocket\",\n                        \"init\");\nconst ScriptableInputStream = CC(\"@mozilla.org/scriptableinputstream;1\",\n                                 \"nsIScriptableInputStream\",\n                                 \"init\");\nconst Pipe = CC(\"@mozilla.org/pipe;1\",\n                \"nsIPipe\",\n                \"init\");\nconst FileInputStream = CC(\"@mozilla.org/network/file-input-stream;1\",\n                           \"nsIFileInputStream\",\n                           \"init\");\nconst ConverterInputStream = CC(\"@mozilla.org/intl/converter-input-stream;1\",\n                                \"nsIConverterInputStream\",\n                                \"init\");\nconst WritablePropertyBag = CC(\"@mozilla.org/hash-property-bag;1\",\n                               \"nsIWritablePropertyBag2\");\nconst SupportsString = CC(\"@mozilla.org/supports-string;1\",\n                          \"nsISupportsString\");\n\n/* These two are non-const only so a test can overwrite them. */\nvar BinaryInputStream = CC(\"@mozilla.org/binaryinputstream;1\",\n                           \"nsIBinaryInputStream\",\n                           \"setInputStream\");\nvar BinaryOutputStream = CC(\"@mozilla.org/binaryoutputstream;1\",\n                            \"nsIBinaryOutputStream\",\n                            \"setOutputStream\");\n\n/**\n * Returns the RFC 822/1123 representation of a date.\n *\n * @param date : Number\n *   the date, in milliseconds from midnight (00:00:00), January 1, 1970 GMT\n * @returns string\n *   the representation of the given date\n */\nfunction toDateString(date)\n{\n  //\n  // rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\n  // date1        = 2DIGIT SP month SP 4DIGIT\n  //                ; day month year (e.g., 02 Jun 1982)\n  // time         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n  //                ; 00:00:00 - 23:59:59\n  // wkday        = \"Mon\" | \"Tue\" | \"Wed\"\n  //              | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\n  // month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n  //              | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n  //              | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n  //\n\n  const wkdayStrings = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n  const monthStrings = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                        \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n  /**\n   * Processes a date and returns the encoded UTC time as a string according to\n   * the format specified in RFC 2616.\n   *\n   * @param date : Date\n   *   the date to process\n   * @returns string\n   *   a string of the form \"HH:MM:SS\", ranging from \"00:00:00\" to \"23:59:59\"\n   */\n  function toTime(date)\n  {\n    var hrs = date.getUTCHours();\n    var rv  = (hrs < 10) ? \"0\" + hrs : hrs;\n    \n    var mins = date.getUTCMinutes();\n    rv += \":\";\n    rv += (mins < 10) ? \"0\" + mins : mins;\n\n    var secs = date.getUTCSeconds();\n    rv += \":\";\n    rv += (secs < 10) ? \"0\" + secs : secs;\n\n    return rv;\n  }\n\n  /**\n   * Processes a date and returns the encoded UTC date as a string according to\n   * the date1 format specified in RFC 2616.\n   *\n   * @param date : Date\n   *   the date to process\n   * @returns string\n   *   a string of the form \"HH:MM:SS\", ranging from \"00:00:00\" to \"23:59:59\"\n   */\n  function toDate1(date)\n  {\n    var day = date.getUTCDate();\n    var month = date.getUTCMonth();\n    var year = date.getUTCFullYear();\n\n    var rv = (day < 10) ? \"0\" + day : day;\n    rv += \" \" + monthStrings[month];\n    rv += \" \" + year;\n\n    return rv;\n  }\n\n  date = new Date(date);\n\n  const fmtString = \"%wkday%, %date1% %time% GMT\";\n  var rv = fmtString.replace(\"%wkday%\", wkdayStrings[date.getUTCDay()]);\n  rv = rv.replace(\"%time%\", toTime(date));\n  return rv.replace(\"%date1%\", toDate1(date));\n}\n\n/**\n * Prints out a human-readable representation of the object o and its fields,\n * omitting those whose names begin with \"_\" if showMembers != true (to ignore\n * \"private\" properties exposed via getters/setters).\n */\nfunction printObj(o, showMembers)\n{\n  var s = \"******************************\\n\";\n  s +=    \"o = {\\n\";\n  for (var i in o)\n  {\n    if (typeof(i) != \"string\" ||\n        (showMembers || (i.length > 0 && i[0] != \"_\")))\n      s+= \"      \" + i + \": \" + o[i] + \",\\n\";\n  }\n  s +=    \"    };\\n\";\n  s +=    \"******************************\";\n  dumpn(s);\n}\n\n/**\n * Instantiates a new HTTP server.\n */\nfunction nsHttpServer()\n{\n  if (!gThreadManager)\n    gThreadManager = Cc[\"@mozilla.org/thread-manager;1\"].getService();\n\n  /** The port on which this server listens. */\n  this._port = undefined;\n\n  /** The socket associated with this. */\n  this._socket = null;\n\n  /** The handler used to process requests to this server. */\n  this._handler = new ServerHandler(this);\n\n  /** Naming information for this server. */\n  this._identity = new ServerIdentity();\n\n  /**\n   * Indicates when the server is to be shut down at the end of the request.\n   */\n  this._doQuit = false;\n\n  /**\n   * True if the socket in this is closed (and closure notifications have been\n   * sent and processed if the socket was ever opened), false otherwise.\n   */\n  this._socketClosed = true;\n\n  /**\n   * Used for tracking existing connections and ensuring that all connections\n   * are properly cleaned up before server shutdown; increases by 1 for every\n   * new incoming connection.\n   */\n  this._connectionGen = 0;\n\n  /**\n   * Hash of all open connections, indexed by connection number at time of\n   * creation.\n   */\n  this._connections = {};\n\n  this.wrappedJSObject = this;\n}\nnsHttpServer.prototype =\n{\n  classID: Components.ID(\"{54ef6f81-30af-4b1d-ac55-8ba811293e41}\"),\n\n  // NSISERVERSOCKETLISTENER\n\n  /**\n   * Processes an incoming request coming in on the given socket and contained\n   * in the given transport.\n   *\n   * @param socket : nsIServerSocket\n   *   the socket through which the request was served\n   * @param trans : nsISocketTransport\n   *   the transport for the request/response\n   * @see nsIServerSocketListener.onSocketAccepted\n   */\n  onSocketAccepted: function(socket, trans)\n  {\n    dumpn(\"*** onSocketAccepted(socket=\" + socket + \", trans=\" + trans + \")\");\n\n    dumpn(\">>> new connection on \" + trans.host + \":\" + trans.port);\n\n    const SEGMENT_SIZE = 8192;\n    const SEGMENT_COUNT = 1024;\n    try\n    {\n      var input = trans.openInputStream(0, SEGMENT_SIZE, SEGMENT_COUNT)\n                       .QueryInterface(Ci.nsIAsyncInputStream);\n      var output = trans.openOutputStream(0, 0, 0);\n    }\n    catch (e)\n    {\n      dumpn(\"*** error opening transport streams: \" + e);\n      trans.close(Cr.NS_BINDING_ABORTED);\n      return;\n    }\n\n    var connectionNumber = ++this._connectionGen;\n\n    try\n    {\n      var conn = new Connection(input, output, this, socket.port, trans.port,\n                                connectionNumber);\n      var reader = new RequestReader(conn);\n\n      // XXX add request timeout functionality here!\n\n      // Note: must use main thread here, or we might get a GC that will cause\n      //       threadsafety assertions.  We really need to fix XPConnect so that\n      //       you can actually do things in multi-threaded JS.  :-(\n      input.asyncWait(reader, 0, 0, gThreadManager.mainThread);\n    }\n    catch (e)\n    {\n      // Assume this connection can't be salvaged and bail on it completely;\n      // don't attempt to close it so that we can assert that any connection\n      // being closed is in this._connections.\n      dumpn(\"*** error in initial request-processing stages: \" + e);\n      trans.close(Cr.NS_BINDING_ABORTED);\n      return;\n    }\n\n    this._connections[connectionNumber] = conn;\n    dumpn(\"*** starting connection \" + connectionNumber);\n  },\n\n  /**\n   * Called when the socket associated with this is closed.\n   *\n   * @param socket : nsIServerSocket\n   *   the socket being closed\n   * @param status : nsresult\n   *   the reason the socket stopped listening (NS_BINDING_ABORTED if the server\n   *   was stopped using nsIHttpServer.stop)\n   * @see nsIServerSocketListener.onStopListening\n   */\n  onStopListening: function(socket, status)\n  {\n    dumpn(\">>> shutting down server on port \" + socket.port);\n    for (var n in this._connections) {\n      if (!this._connections[n]._requestStarted) {\n        this._connections[n].close();\n      }\n    }\n    this._socketClosed = true;\n    if (this._hasOpenConnections()) {\n      dumpn(\"*** open connections!!!\");\n    }\n    if (!this._hasOpenConnections())\n    {\n      dumpn(\"*** no open connections, notifying async from onStopListening\");\n\n      // Notify asynchronously so that any pending teardown in stop() has a\n      // chance to run first.\n      var self = this;\n      var stopEvent =\n        {\n          run: function()\n          {\n            dumpn(\"*** _notifyStopped async callback\");\n            self._notifyStopped();\n          }\n        };\n      gThreadManager.currentThread\n                    .dispatch(stopEvent, Ci.nsIThread.DISPATCH_NORMAL);\n    }\n  },\n\n  // NSIHTTPSERVER\n\n  //\n  // see nsIHttpServer.start\n  //\n  start: function(port)\n  {\n    this._start(port, \"localhost\")\n  },\n\n  _start: function(port, host)\n  {\n    if (this._socket)\n      throw Cr.NS_ERROR_ALREADY_INITIALIZED;\n\n    this._port = port;\n    this._doQuit = this._socketClosed = false;\n\n    this._host = host;\n\n    // The listen queue needs to be long enough to handle\n    // network.http.max-persistent-connections-per-server or\n    // network.http.max-persistent-connections-per-proxy concurrent\n    // connections, plus a safety margin in case some other process is\n    // talking to the server as well.\n    var prefs = getRootPrefBranch();\n    var maxConnections = 5 + Math.max(\n      prefs.getIntPref(\"network.http.max-persistent-connections-per-server\"),\n      prefs.getIntPref(\"network.http.max-persistent-connections-per-proxy\"));\n\n    try\n    {\n      var loopback = true;\n      if (this._host != \"127.0.0.1\" && this._host != \"localhost\") {\n        var loopback = false;\n      }\n\n      // When automatically selecting a port, sometimes the chosen port is\n      // \"blocked\" from clients. We don't want to use these ports because\n      // tests will intermittently fail. So, we simply keep trying to to\n      // get a server socket until a valid port is obtained. We limit\n      // ourselves to finite attempts just so we don't loop forever.\n      var ios = Cc[\"@mozilla.org/network/io-service;1\"]\n                  .getService(Ci.nsIIOService);\n      var socket;\n      for (var i = 100; i; i--)\n      {\n        var temp = new ServerSocket(this._port,\n                                    loopback, // true = localhost, false = everybody\n                                    maxConnections);\n\n        var allowed = ios.allowPort(temp.port, \"http\");\n        if (!allowed)\n        {\n          dumpn(\">>>Warning: obtained ServerSocket listens on a blocked \" +\n                \"port: \" + temp.port);\n        }\n\n        if (!allowed && this._port == -1)\n        {\n          dumpn(\">>>Throwing away ServerSocket with bad port.\");\n          temp.close();\n          continue;\n        }\n\n        socket = temp;\n        break;\n      }\n\n      if (!socket) {\n        throw new Error(\"No socket server available. Are there no available ports?\");\n      }\n\n      dumpn(\">>> listening on port \" + socket.port + \", \" + maxConnections +\n            \" pending connections\");\n      socket.asyncListen(this);\n      this._port = socket.port;\n      this._identity._initialize(socket.port, host, true);\n      this._socket = socket;\n    }\n    catch (e)\n    {\n      dump(\"\\n!!! could not start server on port \" + port + \": \" + e + \"\\n\\n\");\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n    }\n  },\n\n  //\n  // see nsIHttpServer.stop\n  //\n  stop: function(callback)\n  {\n    if (!callback)\n      throw Cr.NS_ERROR_NULL_POINTER;\n    if (!this._socket)\n      throw Cr.NS_ERROR_UNEXPECTED;\n\n    this._stopCallback = typeof callback === \"function\"\n                       ? callback\n                       : function() { callback.onStopped(); };\n\n    dumpn(\">>> stopping listening on port \" + this._socket.port);\n    this._socket.close();\n    this._socket = null;\n\n    // We can't have this identity any more, and the port on which we're running\n    // this server now could be meaningless the next time around.\n    this._identity._teardown();\n\n    this._doQuit = false;\n\n    // socket-close notification and pending request completion happen async\n  },\n\n  //\n  // see nsIHttpServer.registerFile\n  //\n  registerFile: function(path, file)\n  {\n    if (file && (!file.exists() || file.isDirectory()))\n      throw Cr.NS_ERROR_INVALID_ARG;\n\n    this._handler.registerFile(path, file);\n  },\n\n  //\n  // see nsIHttpServer.registerDirectory\n  //\n  registerDirectory: function(path, directory)\n  {\n    // XXX true path validation!\n    if (path.charAt(0) != \"/\" ||\n        path.charAt(path.length - 1) != \"/\" ||\n        (directory &&\n         (!directory.exists() || !directory.isDirectory())))\n      throw Cr.NS_ERROR_INVALID_ARG;\n\n    // XXX determine behavior of nonexistent /foo/bar when a /foo/bar/ mapping\n    //     exists!\n\n    this._handler.registerDirectory(path, directory);\n  },\n\n  //\n  // see nsIHttpServer.registerPathHandler\n  //\n  registerPathHandler: function(path, handler)\n  {\n    this._handler.registerPathHandler(path, handler);\n  },\n\n  //\n  // see nsIHttpServer.registerPrefixHandler\n  //\n  registerPrefixHandler: function(prefix, handler)\n  {\n    this._handler.registerPrefixHandler(prefix, handler);\n  },\n\n  //\n  // see nsIHttpServer.registerErrorHandler\n  //\n  registerErrorHandler: function(code, handler)\n  {\n    this._handler.registerErrorHandler(code, handler);\n  },\n\n  //\n  // see nsIHttpServer.setIndexHandler\n  //\n  setIndexHandler: function(handler)\n  {\n    this._handler.setIndexHandler(handler);\n  },\n\n  //\n  // see nsIHttpServer.registerContentType\n  //\n  registerContentType: function(ext, type)\n  {\n    this._handler.registerContentType(ext, type);\n  },\n\n  //\n  // see nsIHttpServer.serverIdentity\n  //\n  get identity()\n  {\n    return this._identity;\n  },\n\n  //\n  // see nsIHttpServer.getState\n  //\n  getState: function(path, k)\n  {\n    return this._handler._getState(path, k);\n  },\n\n  //\n  // see nsIHttpServer.setState\n  //\n  setState: function(path, k, v)\n  {\n    return this._handler._setState(path, k, v);\n  },\n\n  //\n  // see nsIHttpServer.getSharedState\n  //\n  getSharedState: function(k)\n  {\n    return this._handler._getSharedState(k);\n  },\n\n  //\n  // see nsIHttpServer.setSharedState\n  //\n  setSharedState: function(k, v)\n  {\n    return this._handler._setSharedState(k, v);\n  },\n\n  //\n  // see nsIHttpServer.getObjectState\n  //\n  getObjectState: function(k)\n  {\n    return this._handler._getObjectState(k);\n  },\n\n  //\n  // see nsIHttpServer.setObjectState\n  //\n  setObjectState: function(k, v)\n  {\n    return this._handler._setObjectState(k, v);\n  },\n\n\n  // NSISUPPORTS\n\n  //\n  // see nsISupports.QueryInterface\n  //\n  QueryInterface: function(iid)\n  {\n    if (iid.equals(Ci.nsIHttpServer) ||\n        iid.equals(Ci.nsIServerSocketListener) ||\n        iid.equals(Ci.nsISupports))\n      return this;\n\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  },\n\n\n  // NON-XPCOM PUBLIC API\n\n  /**\n   * Returns true iff this server is not running (and is not in the process of\n   * serving any requests still to be processed when the server was last\n   * stopped after being run).\n   */\n  isStopped: function()\n  {\n    return this._socketClosed && !this._hasOpenConnections();\n  },\n\n  // PRIVATE IMPLEMENTATION\n\n  /** True if this server has any open connections to it, false otherwise. */\n  _hasOpenConnections: function()\n  {\n    //\n    // If we have any open connections, they're tracked as numeric properties on\n    // |this._connections|.  The non-standard __count__ property could be used\n    // to check whether there are any properties, but standard-wise, even\n    // looking forward to ES5, there's no less ugly yet still O(1) way to do\n    // this.\n    //\n    for (var n in this._connections)\n      return true;\n    return false;\n  },\n\n  /** Calls the server-stopped callback provided when stop() was called. */\n  _notifyStopped: function()\n  {\n    NS_ASSERT(this._stopCallback !== null, \"double-notifying?\");\n    NS_ASSERT(!this._hasOpenConnections(), \"should be done serving by now\");\n\n    if (this._stopCallback === undefined)\n        return;\n    //\n    // NB: We have to grab this now, null out the member, *then* call the\n    //     callback here, or otherwise the callback could (indirectly) futz with\n    //     this._stopCallback by starting and immediately stopping this, at\n    //     which point we'd be nulling out a field we no longer have a right to\n    //     modify.\n    //\n    var callback = this._stopCallback;\n    this._stopCallback = null;\n    try\n    {\n      callback();\n    }\n    catch (e)\n    {\n      // not throwing because this is specified as being usually (but not\n      // always) asynchronous\n      dump(\"!!! error running onStopped callback: \" + e + \"\\n\");\n    }\n  },\n\n  /**\n   * Notifies this server that the given connection has been closed.\n   *\n   * @param connection : Connection\n   *   the connection that was closed\n   */\n  _connectionClosed: function(connection)\n  {\n    NS_ASSERT(connection.number in this._connections,\n              \"closing a connection \" + this + \" that we never added to the \" +\n              \"set of open connections?\");\n    NS_ASSERT(this._connections[connection.number] === connection,\n              \"connection number mismatch?  \" +\n              this._connections[connection.number]);\n    delete this._connections[connection.number];\n\n    // Fire a pending server-stopped notification if it's our responsibility.\n    if (!this._hasOpenConnections() && this._socketClosed)\n      this._notifyStopped();\n    // Bug 508125: Add a GC here else we'll use gigabytes of memory running\n    // mochitests. We can't rely on xpcshell doing an automated GC, as that\n    // would interfere with testing GC stuff...\n    Components.utils.forceGC();\n  },\n\n  /**\n   * Requests that the server be shut down when possible.\n   */\n  _requestQuit: function()\n  {\n    dumpn(\">>> requesting a quit\");\n    dumpStack();\n    this._doQuit = true;\n  }\n};\n\nthis.HttpServer = nsHttpServer;\n\n//\n// RFC 2396 section 3.2.2:\n//\n// host        = hostname | IPv4address\n// hostname    = *( domainlabel \".\" ) toplabel [ \".\" ]\n// domainlabel = alphanum | alphanum *( alphanum | \"-\" ) alphanum\n// toplabel    = alpha | alpha *( alphanum | \"-\" ) alphanum\n// IPv4address = 1*digit \".\" 1*digit \".\" 1*digit \".\" 1*digit\n//\n\nconst HOST_REGEX =\n  new RegExp(\"^(?:\" +\n               // *( domainlabel \".\" )\n               \"(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)*\" +\n               // toplabel\n               \"[a-z](?:[a-z0-9-]*[a-z0-9])?\" +\n             \"|\" +\n               // IPv4 address \n               \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\" +\n             \")$\",\n             \"i\");\n\n\n/**\n * Represents the identity of a server.  An identity consists of a set of\n * (scheme, host, port) tuples denoted as locations (allowing a single server to\n * serve multiple sites or to be used behind both HTTP and HTTPS proxies for any\n * host/port).  Any incoming request must be to one of these locations, or it\n * will be rejected with an HTTP 400 error.  One location, denoted as the\n * primary location, is the location assigned in contexts where a location\n * cannot otherwise be endogenously derived, such as for HTTP/1.0 requests.\n *\n * A single identity may contain at most one location per unique host/port pair;\n * other than that, no restrictions are placed upon what locations may\n * constitute an identity.\n */\nfunction ServerIdentity()\n{\n  /** The scheme of the primary location. */\n  this._primaryScheme = \"http\";\n\n  /** The hostname of the primary location. */\n  this._primaryHost = \"127.0.0.1\"\n\n  /** The port number of the primary location. */\n  this._primaryPort = -1;\n\n  /**\n   * The current port number for the corresponding server, stored so that a new\n   * primary location can always be set if the current one is removed.\n   */\n  this._defaultPort = -1;\n\n  /**\n   * Maps hosts to maps of ports to schemes, e.g. the following would represent\n   * https://example.com:789/ and http://example.org/:\n   *\n   *   {\n   *     \"xexample.com\": { 789: \"https\" },\n   *     \"xexample.org\": { 80: \"http\" }\n   *   }\n   *\n   * Note the \"x\" prefix on hostnames, which prevents collisions with special\n   * JS names like \"prototype\".\n   */\n  this._locations = { \"xlocalhost\": {} };\n}\nServerIdentity.prototype =\n{\n  // NSIHTTPSERVERIDENTITY\n\n  //\n  // see nsIHttpServerIdentity.primaryScheme\n  //\n  get primaryScheme()\n  {\n    if (this._primaryPort === -1)\n      throw Cr.NS_ERROR_NOT_INITIALIZED;\n    return this._primaryScheme;\n  },\n\n  //\n  // see nsIHttpServerIdentity.primaryHost\n  //\n  get primaryHost()\n  {\n    if (this._primaryPort === -1)\n      throw Cr.NS_ERROR_NOT_INITIALIZED;\n    return this._primaryHost;\n  },\n\n  //\n  // see nsIHttpServerIdentity.primaryPort\n  //\n  get primaryPort()\n  {\n    if (this._primaryPort === -1)\n      throw Cr.NS_ERROR_NOT_INITIALIZED;\n    return this._primaryPort;\n  },\n\n  //\n  // see nsIHttpServerIdentity.add\n  //\n  add: function(scheme, host, port)\n  {\n    this._validate(scheme, host, port);\n\n    var entry = this._locations[\"x\" + host];\n    if (!entry)\n      this._locations[\"x\" + host] = entry = {};\n\n    entry[port] = scheme;\n  },\n\n  //\n  // see nsIHttpServerIdentity.remove\n  //\n  remove: function(scheme, host, port)\n  {\n    this._validate(scheme, host, port);\n\n    var entry = this._locations[\"x\" + host];\n    if (!entry)\n      return false;\n\n    var present = port in entry;\n    delete entry[port];\n\n    if (this._primaryScheme == scheme &&\n        this._primaryHost == host &&\n        this._primaryPort == port &&\n        this._defaultPort !== -1)\n    {\n      // Always keep at least one identity in existence at any time, unless\n      // we're in the process of shutting down (the last condition above).\n      this._primaryPort = -1;\n      this._initialize(this._defaultPort, host, false);\n    }\n\n    return present;\n  },\n\n  //\n  // see nsIHttpServerIdentity.has\n  //\n  has: function(scheme, host, port)\n  {\n    this._validate(scheme, host, port);\n\n    return \"x\" + host in this._locations &&\n           scheme === this._locations[\"x\" + host][port];\n  },\n\n  //\n  // see nsIHttpServerIdentity.has\n  //\n  getScheme: function(host, port)\n  {\n    this._validate(\"http\", host, port);\n\n    var entry = this._locations[\"x\" + host];\n    if (!entry)\n      return \"\";\n\n    return entry[port] || \"\";\n  },\n\n  //\n  // see nsIHttpServerIdentity.setPrimary\n  //\n  setPrimary: function(scheme, host, port)\n  {\n    this._validate(scheme, host, port);\n\n    this.add(scheme, host, port);\n\n    this._primaryScheme = scheme;\n    this._primaryHost = host;\n    this._primaryPort = port;\n  },\n\n\n  // NSISUPPORTS\n\n  //\n  // see nsISupports.QueryInterface\n  //\n  QueryInterface: function(iid)\n  {\n    if (iid.equals(Ci.nsIHttpServerIdentity) || iid.equals(Ci.nsISupports))\n      return this;\n\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  },\n\n\n  // PRIVATE IMPLEMENTATION\n\n  /**\n   * Initializes the primary name for the corresponding server, based on the\n   * provided port number.\n   */\n  _initialize: function(port, host, addSecondaryDefault)\n  {\n    this._host = host;\n    if (this._primaryPort !== -1)\n      this.add(\"http\", host, port);\n    else\n      this.setPrimary(\"http\", \"localhost\", port);\n    this._defaultPort = port;\n\n    // Only add this if we're being called at server startup\n    if (addSecondaryDefault && host != \"127.0.0.1\")\n      this.add(\"http\", \"127.0.0.1\", port);\n  },\n\n  /**\n   * Called at server shutdown time, unsets the primary location only if it was\n   * the default-assigned location and removes the default location from the\n   * set of locations used.\n   */\n  _teardown: function()\n  {\n    if (this._host != \"127.0.0.1\") {\n      // Not the default primary location, nothing special to do here\n      this.remove(\"http\", \"127.0.0.1\", this._defaultPort);\n    }\n    \n    // This is a *very* tricky bit of reasoning here; make absolutely sure the\n    // tests for this code pass before you commit changes to it.\n    if (this._primaryScheme == \"http\" &&\n        this._primaryHost == this._host &&\n        this._primaryPort == this._defaultPort)\n    {\n      // Make sure we don't trigger the readding logic in .remove(), then remove\n      // the default location.\n      var port = this._defaultPort;\n      this._defaultPort = -1;\n      this.remove(\"http\", this._host, port);\n\n      // Ensure a server start triggers the setPrimary() path in ._initialize()\n      this._primaryPort = -1;\n    }\n    else\n    {\n      // No reason not to remove directly as it's not our primary location\n      this.remove(\"http\", this._host, this._defaultPort);\n    }\n  },\n\n  /**\n   * Ensures scheme, host, and port are all valid with respect to RFC 2396.\n   *\n   * @throws NS_ERROR_ILLEGAL_VALUE\n   *   if any argument doesn't match the corresponding production\n   */\n  _validate: function(scheme, host, port)\n  {\n    if (scheme !== \"http\" && scheme !== \"https\")\n    {\n      dumpn(\"*** server only supports http/https schemes: '\" + scheme + \"'\");\n      dumpStack();\n      throw Cr.NS_ERROR_ILLEGAL_VALUE;\n    }\n    if (!HOST_REGEX.test(host))\n    {\n      dumpn(\"*** unexpected host: '\" + host + \"'\");\n      throw Cr.NS_ERROR_ILLEGAL_VALUE;\n    }\n    if (port < 0 || port > 65535)\n    {\n      dumpn(\"*** unexpected port: '\" + port + \"'\");\n      throw Cr.NS_ERROR_ILLEGAL_VALUE;\n    }\n  }\n};\n\n\n/**\n * Represents a connection to the server (and possibly in the future the thread\n * on which the connection is processed).\n *\n * @param input : nsIInputStream\n *   stream from which incoming data on the connection is read\n * @param output : nsIOutputStream\n *   stream to write data out the connection\n * @param server : nsHttpServer\n *   the server handling the connection\n * @param port : int\n *   the port on which the server is running\n * @param outgoingPort : int\n *   the outgoing port used by this connection\n * @param number : uint\n *   a serial number used to uniquely identify this connection\n */\nfunction Connection(input, output, server, port, outgoingPort, number)\n{\n  dumpn(\"*** opening new connection \" + number + \" on port \" + outgoingPort);\n\n  /** Stream of incoming data. */\n  this.input = input;\n\n  /** Stream for outgoing data. */\n  this.output = output;\n\n  /** The server associated with this request. */\n  this.server = server;\n\n  /** The port on which the server is running. */\n  this.port = port;\n\n  /** The outgoing poort used by this connection. */\n  this._outgoingPort = outgoingPort;\n\n  /** The serial number of this connection. */\n  this.number = number;\n\n  /**\n   * The request for which a response is being generated, null if the\n   * incoming request has not been fully received or if it had errors.\n   */\n  this.request = null;\n\n  /** This allows a connection to disambiguate between a peer initiating a\n   *  close and the socket being forced closed on shutdown.\n   */\n  this._closed = false;\n\n  /** State variable for debugging. */\n  this._processed = false;\n\n  /** whether or not 1st line of request has been received */\n  this._requestStarted = false; \n}\nConnection.prototype =\n{\n  /** Closes this connection's input/output streams. */\n  close: function()\n  {\n    if (this._closed)\n        return;\n\n    dumpn(\"*** closing connection \" + this.number +\n          \" on port \" + this._outgoingPort);\n\n    this.input.close();\n    this.output.close();\n    this._closed = true;\n\n    var server = this.server;\n    server._connectionClosed(this);\n\n    // If an error triggered a server shutdown, act on it now\n    if (server._doQuit)\n      server.stop(function() { /* not like we can do anything better */ });\n  },\n\n  /**\n   * Initiates processing of this connection, using the data in the given\n   * request.\n   *\n   * @param request : Request\n   *   the request which should be processed\n   */\n  process: function(request)\n  {\n    NS_ASSERT(!this._closed && !this._processed);\n\n    this._processed = true;\n\n    this.request = request;\n    this.server._handler.handleResponse(this);\n  },\n\n  /**\n   * Initiates processing of this connection, generating a response with the\n   * given HTTP error code.\n   *\n   * @param code : uint\n   *   an HTTP code, so in the range [0, 1000)\n   * @param request : Request\n   *   incomplete data about the incoming request (since there were errors\n   *   during its processing\n   */\n  processError: function(code, request)\n  {\n    NS_ASSERT(!this._closed && !this._processed);\n\n    this._processed = true;\n    this.request = request;\n    this.server._handler.handleError(code, this);\n  },\n\n  /** Converts this to a string for debugging purposes. */\n  toString: function()\n  {\n    return \"<Connection(\" + this.number +\n           (this.request ? \", \" + this.request.path : \"\") +\"): \" +\n           (this._closed ? \"closed\" : \"open\") + \">\";\n  },\n\n  requestStarted: function()\n  {\n    this._requestStarted = true;\n  }\n};\n\n\n\n/** Returns an array of count bytes from the given input stream. */\nfunction readBytes(inputStream, count)\n{\n  return new BinaryInputStream(inputStream).readByteArray(count);\n}\n\n\n\n/** Request reader processing states; see RequestReader for details. */\nconst READER_IN_REQUEST_LINE = 0;\nconst READER_IN_HEADERS      = 1;\nconst READER_IN_BODY         = 2;\nconst READER_FINISHED        = 3;\n\n\n/**\n * Reads incoming request data asynchronously, does any necessary preprocessing,\n * and forwards it to the request handler.  Processing occurs in three states:\n *\n *   READER_IN_REQUEST_LINE     Reading the request's status line\n *   READER_IN_HEADERS          Reading headers in the request\n *   READER_IN_BODY             Reading the body of the request\n *   READER_FINISHED            Entire request has been read and processed\n *\n * During the first two stages, initial metadata about the request is gathered\n * into a Request object.  Once the status line and headers have been processed,\n * we start processing the body of the request into the Request.  Finally, when\n * the entire body has been read, we create a Response and hand it off to the\n * ServerHandler to be given to the appropriate request handler.\n *\n * @param connection : Connection\n *   the connection for the request being read\n */\nfunction RequestReader(connection)\n{\n  /** Connection metadata for this request. */\n  this._connection = connection;\n\n  /**\n   * A container providing line-by-line access to the raw bytes that make up the\n   * data which has been read from the connection but has not yet been acted\n   * upon (by passing it to the request handler or by extracting request\n   * metadata from it).\n   */\n  this._data = new LineData();\n\n  /**\n   * The amount of data remaining to be read from the body of this request.\n   * After all headers in the request have been read this is the value in the\n   * Content-Length header, but as the body is read its value decreases to zero.\n   */\n  this._contentLength = 0;\n\n  /** The current state of parsing the incoming request. */\n  this._state = READER_IN_REQUEST_LINE;\n\n  /** Metadata constructed from the incoming request for the request handler. */\n  this._metadata = new Request(connection.port);\n\n  /**\n   * Used to preserve state if we run out of line data midway through a\n   * multi-line header.  _lastHeaderName stores the name of the header, while\n   * _lastHeaderValue stores the value we've seen so far for the header.\n   *\n   * These fields are always either both undefined or both strings.\n   */\n  this._lastHeaderName = this._lastHeaderValue = undefined;\n}\nRequestReader.prototype =\n{\n  // NSIINPUTSTREAMCALLBACK\n\n  /**\n   * Called when more data from the incoming request is available.  This method\n   * then reads the available data from input and deals with that data as\n   * necessary, depending upon the syntax of already-downloaded data.\n   *\n   * @param input : nsIAsyncInputStream\n   *   the stream of incoming data from the connection\n   */\n  onInputStreamReady: function(input)\n  {\n    dumpn(\"*** onInputStreamReady(input=\" + input + \") on thread \" +\n          gThreadManager.currentThread + \" (main is \" +\n          gThreadManager.mainThread + \")\");\n    dumpn(\"*** this._state == \" + this._state);\n\n    // Handle cases where we get more data after a request error has been\n    // discovered but *before* we can close the connection.\n    var data = this._data;\n    if (!data)\n      return;\n\n    try\n    {\n      data.appendBytes(readBytes(input, input.available()));\n    }\n    catch (e)\n    {\n      if (streamClosed(e))\n      {\n        dumpn(\"*** WARNING: unexpected error when reading from socket; will \" +\n              \"be treated as if the input stream had been closed\");\n        dumpn(\"*** WARNING: actual error was: \" + e);\n      }\n\n      // We've lost a race -- input has been closed, but we're still expecting\n      // to read more data.  available() will throw in this case, and since\n      // we're dead in the water now, destroy the connection.\n      dumpn(\"*** onInputStreamReady called on a closed input, destroying \" +\n            \"connection\");\n      this._connection.close();\n      return;\n    }\n\n    switch (this._state)\n    {\n      default:\n        NS_ASSERT(false, \"invalid state: \" + this._state);\n        break;\n\n      case READER_IN_REQUEST_LINE:\n        if (!this._processRequestLine())\n          break;\n        /* fall through */\n\n      case READER_IN_HEADERS:\n        if (!this._processHeaders())\n          break;\n        /* fall through */\n\n      case READER_IN_BODY:\n        this._processBody();\n    }\n\n    if (this._state != READER_FINISHED)\n      input.asyncWait(this, 0, 0, gThreadManager.currentThread);\n  },\n\n  //\n  // see nsISupports.QueryInterface\n  //\n  QueryInterface: function(aIID)\n  {\n    if (aIID.equals(Ci.nsIInputStreamCallback) ||\n        aIID.equals(Ci.nsISupports))\n      return this;\n\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  },\n\n\n  // PRIVATE API\n\n  /**\n   * Processes unprocessed, downloaded data as a request line.\n   *\n   * @returns boolean\n   *   true iff the request line has been fully processed\n   */\n  _processRequestLine: function()\n  {\n    NS_ASSERT(this._state == READER_IN_REQUEST_LINE);\n\n    // Servers SHOULD ignore any empty line(s) received where a Request-Line\n    // is expected (section 4.1).\n    var data = this._data;\n    var line = {};\n    var readSuccess;\n    while ((readSuccess = data.readLine(line)) && line.value == \"\")\n      dumpn(\"*** ignoring beginning blank line...\");\n\n    // if we don't have a full line, wait until we do\n    if (!readSuccess)\n      return false;\n\n    // we have the first non-blank line\n    try\n    {\n      this._parseRequestLine(line.value);\n      this._state = READER_IN_HEADERS;\n      this._connection.requestStarted();\n      return true;\n    }\n    catch (e)\n    {\n      this._handleError(e);\n      return false;\n    }\n  },\n\n  /**\n   * Processes stored data, assuming it is either at the beginning or in\n   * the middle of processing request headers.\n   *\n   * @returns boolean\n   *   true iff header data in the request has been fully processed\n   */\n  _processHeaders: function()\n  {\n    NS_ASSERT(this._state == READER_IN_HEADERS);\n\n    // XXX things to fix here:\n    //\n    // - need to support RFC 2047-encoded non-US-ASCII characters\n\n    try\n    {\n      var done = this._parseHeaders();\n      if (done)\n      {\n        var request = this._metadata;\n\n        // XXX this is wrong for requests with transfer-encodings applied to\n        //     them, particularly chunked (which by its nature can have no\n        //     meaningful Content-Length header)!\n        this._contentLength = request.hasHeader(\"Content-Length\")\n                            ? parseInt(request.getHeader(\"Content-Length\"), 10)\n                            : 0;\n        dumpn(\"_processHeaders, Content-length=\" + this._contentLength);\n\n        this._state = READER_IN_BODY;\n      }\n      return done;\n    }\n    catch (e)\n    {\n      this._handleError(e);\n      return false;\n    }\n  },\n\n  /**\n   * Processes stored data, assuming it is either at the beginning or in\n   * the middle of processing the request body.\n   *\n   * @returns boolean\n   *   true iff the request body has been fully processed\n   */\n  _processBody: function()\n  {\n    NS_ASSERT(this._state == READER_IN_BODY);\n\n    // XXX handle chunked transfer-coding request bodies!\n\n    try\n    {\n      if (this._contentLength > 0)\n      {\n        var data = this._data.purge();\n        var count = Math.min(data.length, this._contentLength);\n        dumpn(\"*** loading data=\" + data + \" len=\" + data.length +\n              \" excess=\" + (data.length - count));\n\n        var bos = new BinaryOutputStream(this._metadata._bodyOutputStream);\n        bos.writeByteArray(data, count);\n        this._contentLength -= count;\n      }\n\n      dumpn(\"*** remaining body data len=\" + this._contentLength);\n      if (this._contentLength == 0)\n      {\n        this._validateRequest();\n        this._state = READER_FINISHED;\n        this._handleResponse();\n        return true;\n      }\n      \n      return false;\n    }\n    catch (e)\n    {\n      this._handleError(e);\n      return false;\n    }\n  },\n\n  /**\n   * Does various post-header checks on the data in this request.\n   *\n   * @throws : HttpError\n   *   if the request was malformed in some way\n   */\n  _validateRequest: function()\n  {\n    NS_ASSERT(this._state == READER_IN_BODY);\n\n    dumpn(\"*** _validateRequest\");\n\n    var metadata = this._metadata;\n    var headers = metadata._headers;\n\n    // 19.6.1.1 -- servers MUST report 400 to HTTP/1.1 requests w/o Host header\n    var identity = this._connection.server.identity;\n    if (metadata._httpVersion.atLeast(nsHttpVersion.HTTP_1_1))\n    {\n      if (!headers.hasHeader(\"Host\"))\n      {\n        dumpn(\"*** malformed HTTP/1.1 or greater request with no Host header!\");\n        throw HTTP_400;\n      }\n\n      // If the Request-URI wasn't absolute, then we need to determine our host.\n      // We have to determine what scheme was used to access us based on the\n      // server identity data at this point, because the request just doesn't\n      // contain enough data on its own to do this, sadly.\n      if (!metadata._host)\n      {\n        var host, port;\n        var hostPort = headers.getHeader(\"Host\");\n        var colon = hostPort.indexOf(\":\");\n        if (colon < 0)\n        {\n          host = hostPort;\n          port = \"\";\n        }\n        else\n        {\n          host = hostPort.substring(0, colon);\n          port = hostPort.substring(colon + 1);\n        }\n\n        // NB: We allow an empty port here because, oddly, a colon may be\n        //     present even without a port number, e.g. \"example.com:\"; in this\n        //     case the default port applies.\n        if (!HOST_REGEX.test(host) || !/^\\d*$/.test(port))\n        {\n          dumpn(\"*** malformed hostname (\" + hostPort + \") in Host \" +\n                \"header, 400 time\");\n          throw HTTP_400;\n        }\n\n        // If we're not given a port, we're stuck, because we don't know what\n        // scheme to use to look up the correct port here, in general.  Since\n        // the HTTPS case requires a tunnel/proxy and thus requires that the\n        // requested URI be absolute (and thus contain the necessary\n        // information), let's assume HTTP will prevail and use that.\n        port = +port || 80;\n\n        var scheme = identity.getScheme(host, port);\n        if (!scheme)\n        {\n          dumpn(\"*** unrecognized hostname (\" + hostPort + \") in Host \" +\n                \"header, 400 time\");\n          throw HTTP_400;\n        }\n\n        metadata._scheme = scheme;\n        metadata._host = host;\n        metadata._port = port;\n      }\n    }\n    else\n    {\n      NS_ASSERT(metadata._host === undefined,\n                \"HTTP/1.0 doesn't allow absolute paths in the request line!\");\n\n      metadata._scheme = identity.primaryScheme;\n      metadata._host = identity.primaryHost;\n      metadata._port = identity.primaryPort;\n    }\n\n    NS_ASSERT(identity.has(metadata._scheme, metadata._host, metadata._port),\n              \"must have a location we recognize by now!\");\n  },\n\n  /**\n   * Handles responses in case of error, either in the server or in the request.\n   *\n   * @param e\n   *   the specific error encountered, which is an HttpError in the case where\n   *   the request is in some way invalid or cannot be fulfilled; if this isn't\n   *   an HttpError we're going to be paranoid and shut down, because that\n   *   shouldn't happen, ever\n   */\n  _handleError: function(e)\n  {\n    // Don't fall back into normal processing!\n    this._state = READER_FINISHED;\n\n    var server = this._connection.server;\n    if (e instanceof HttpError)\n    {\n      var code = e.code;\n    }\n    else\n    {\n      dumpn(\"!!! UNEXPECTED ERROR: \" + e +\n            (e.lineNumber ? \", line \" + e.lineNumber : \"\"));\n\n      // no idea what happened -- be paranoid and shut down\n      code = 500;\n      server._requestQuit();\n    }\n\n    // make attempted reuse of data an error\n    this._data = null;\n\n    this._connection.processError(code, this._metadata);\n  },\n\n  /**\n   * Now that we've read the request line and headers, we can actually hand off\n   * the request to be handled.\n   *\n   * This method is called once per request, after the request line and all\n   * headers and the body, if any, have been received.\n   */\n  _handleResponse: function()\n  {\n    NS_ASSERT(this._state == READER_FINISHED);\n\n    // We don't need the line-based data any more, so make attempted reuse an\n    // error.\n    this._data = null;\n\n    this._connection.process(this._metadata);\n  },\n\n\n  // PARSING\n\n  /**\n   * Parses the request line for the HTTP request associated with this.\n   *\n   * @param line : string\n   *   the request line\n   */\n  _parseRequestLine: function(line)\n  {\n    NS_ASSERT(this._state == READER_IN_REQUEST_LINE);\n\n    dumpn(\"*** _parseRequestLine('\" + line + \"')\");\n\n    var metadata = this._metadata;\n\n    // clients and servers SHOULD accept any amount of SP or HT characters\n    // between fields, even though only a single SP is required (section 19.3)\n    var request = line.split(/[ \\t]+/);\n    if (!request || request.length != 3)\n    {\n      dumpn(\"*** No request in line\");\n      throw HTTP_400;\n    }\n\n    metadata._method = request[0];\n\n    // get the HTTP version\n    var ver = request[2];\n    var match = ver.match(/^HTTP\\/(\\d+\\.\\d+)$/);\n    if (!match)\n    {\n      dumpn(\"*** No HTTP version in line\");\n      throw HTTP_400;\n    }\n\n    // determine HTTP version\n    try\n    {\n      metadata._httpVersion = new nsHttpVersion(match[1]);\n      if (!metadata._httpVersion.atLeast(nsHttpVersion.HTTP_1_0))\n        throw \"unsupported HTTP version\";\n    }\n    catch (e)\n    {\n      // we support HTTP/1.0 and HTTP/1.1 only\n      throw HTTP_501;\n    }\n\n\n    var fullPath = request[1];\n    var serverIdentity = this._connection.server.identity;\n\n    var scheme, host, port;\n\n    if (fullPath.charAt(0) != \"/\")\n    {\n      // No absolute paths in the request line in HTTP prior to 1.1\n      if (!metadata._httpVersion.atLeast(nsHttpVersion.HTTP_1_1))\n      {\n        dumpn(\"*** Metadata version too low\");\n        throw HTTP_400;\n      }\n\n      try\n      {\n        var uri = Cc[\"@mozilla.org/network/io-service;1\"]\n                    .getService(Ci.nsIIOService)\n                    .newURI(fullPath, null, null);\n        fullPath = uri.path;\n        scheme = uri.scheme;\n        host = metadata._host = uri.asciiHost;\n        port = uri.port;\n        if (port === -1)\n        {\n          if (scheme === \"http\")\n          {\n            port = 80;\n          }\n          else if (scheme === \"https\")\n          {\n            port = 443;\n          }\n          else\n          {\n            dumpn(\"*** Unknown scheme: \" + scheme);\n            throw HTTP_400;\n          }\n        }\n      }\n      catch (e)\n      {\n        // If the host is not a valid host on the server, the response MUST be a\n        // 400 (Bad Request) error message (section 5.2).  Alternately, the URI\n        // is malformed.\n        dumpn(\"*** Threw when dealing with URI: \" + e);\n        throw HTTP_400;\n      }\n\n      if (!serverIdentity.has(scheme, host, port) || fullPath.charAt(0) != \"/\")\n      {\n        dumpn(\"*** serverIdentity unknown or path does not start with '/'\");\n        throw HTTP_400;\n      }\n    }\n\n    var splitter = fullPath.indexOf(\"?\");\n    if (splitter < 0)\n    {\n      // _queryString already set in ctor\n      metadata._path = fullPath;\n    }\n    else\n    {\n      metadata._path = fullPath.substring(0, splitter);\n      metadata._queryString = fullPath.substring(splitter + 1);\n    }\n\n    metadata._scheme = scheme;\n    metadata._host = host;\n    metadata._port = port;\n  },\n\n  /**\n   * Parses all available HTTP headers in this until the header-ending CRLFCRLF,\n   * adding them to the store of headers in the request.\n   *\n   * @throws\n   *   HTTP_400 if the headers are malformed\n   * @returns boolean\n   *   true if all headers have now been processed, false otherwise\n   */\n  _parseHeaders: function()\n  {\n    NS_ASSERT(this._state == READER_IN_HEADERS);\n\n    dumpn(\"*** _parseHeaders\");\n\n    var data = this._data;\n\n    var headers = this._metadata._headers;\n    var lastName = this._lastHeaderName;\n    var lastVal = this._lastHeaderValue;\n\n    var line = {};\n    while (true)\n    {\n      dumpn(\"*** Last name: '\" + lastName + \"'\");\n      dumpn(\"*** Last val: '\" + lastVal + \"'\");\n      NS_ASSERT(!((lastVal === undefined) ^ (lastName === undefined)),\n                lastName === undefined ?\n                  \"lastVal without lastName?  lastVal: '\" + lastVal + \"'\" :\n                  \"lastName without lastVal?  lastName: '\" + lastName + \"'\");\n\n      if (!data.readLine(line))\n      {\n        // save any data we have from the header we might still be processing\n        this._lastHeaderName = lastName;\n        this._lastHeaderValue = lastVal;\n        return false;\n      }\n\n      var lineText = line.value;\n      dumpn(\"*** Line text: '\" + lineText + \"'\");\n      var firstChar = lineText.charAt(0);\n\n      // blank line means end of headers\n      if (lineText == \"\")\n      {\n        // we're finished with the previous header\n        if (lastName)\n        {\n          try\n          {\n            headers.setHeader(lastName, lastVal, true);\n          }\n          catch (e)\n          {\n            dumpn(\"*** setHeader threw on last header, e == \" + e);\n            throw HTTP_400;\n          }\n        }\n        else\n        {\n          // no headers in request -- valid for HTTP/1.0 requests\n        }\n\n        // either way, we're done processing headers\n        this._state = READER_IN_BODY;\n        return true;\n      }\n      else if (firstChar == \" \" || firstChar == \"\\t\")\n      {\n        // multi-line header if we've already seen a header line\n        if (!lastName)\n        {\n          dumpn(\"We don't have a header to continue!\");\n          throw HTTP_400;\n        }\n\n        // append this line's text to the value; starts with SP/HT, so no need\n        // for separating whitespace\n        lastVal += lineText;\n      }\n      else\n      {\n        // we have a new header, so set the old one (if one existed)\n        if (lastName)\n        {\n          try\n          {\n            headers.setHeader(lastName, lastVal, true);\n          }\n          catch (e)\n          {\n            dumpn(\"*** setHeader threw on a header, e == \" + e);\n            throw HTTP_400;\n          }\n        }\n\n        var colon = lineText.indexOf(\":\"); // first colon must be splitter\n        if (colon < 1)\n        {\n          dumpn(\"*** No colon or missing header field-name\");\n          throw HTTP_400;\n        }\n\n        // set header name, value (to be set in the next loop, usually)\n        lastName = lineText.substring(0, colon);\n        lastVal = lineText.substring(colon + 1);\n      } // empty, continuation, start of header\n    } // while (true)\n  }\n};\n\n\n/** The character codes for CR and LF. */\nconst CR = 0x0D, LF = 0x0A;\n\n/**\n * Calculates the number of characters before the first CRLF pair in array, or\n * -1 if the array contains no CRLF pair.\n *\n * @param array : Array\n *   an array of numbers in the range [0, 256), each representing a single\n *   character; the first CRLF is the lowest index i where\n *   |array[i] == \"\\r\".charCodeAt(0)| and |array[i+1] == \"\\n\".charCodeAt(0)|,\n *   if such an |i| exists, and -1 otherwise\n * @param start : uint\n *   start index from which to begin searching in array\n * @returns int\n *   the index of the first CRLF if any were present, -1 otherwise\n */\nfunction findCRLF(array, start)\n{\n  for (var i = array.indexOf(CR, start); i >= 0; i = array.indexOf(CR, i + 1))\n  {\n    if (array[i + 1] == LF)\n      return i;\n  }\n  return -1;\n}\n\n\n/**\n * A container which provides line-by-line access to the arrays of bytes with\n * which it is seeded.\n */\nfunction LineData()\n{\n  /** An array of queued bytes from which to get line-based characters. */\n  this._data = [];\n\n  /** Start index from which to search for CRLF. */\n  this._start = 0;\n}\nLineData.prototype =\n{\n  /**\n   * Appends the bytes in the given array to the internal data cache maintained\n   * by this.\n   */\n  appendBytes: function(bytes)\n  {\n    var count = bytes.length;\n    var quantum = 262144; // just above half SpiderMonkey's argument-count limit\n    if (count < quantum)\n    {\n      Array.prototype.push.apply(this._data, bytes);\n      return;\n    }\n\n    // Large numbers of bytes may cause Array.prototype.push to be called with\n    // more arguments than the JavaScript engine supports.  In that case append\n    // bytes in fixed-size amounts until all bytes are appended.\n    for (var start = 0; start < count; start += quantum)\n    {\n      var slice = bytes.slice(start, Math.min(start + quantum, count));\n      Array.prototype.push.apply(this._data, slice);\n    }\n  },\n\n  /**\n   * Removes and returns a line of data, delimited by CRLF, from this.\n   *\n   * @param out\n   *   an object whose \"value\" property will be set to the first line of text\n   *   present in this, sans CRLF, if this contains a full CRLF-delimited line\n   *   of text; if this doesn't contain enough data, the value of the property\n   *   is undefined\n   * @returns boolean\n   *   true if a full line of data could be read from the data in this, false\n   *   otherwise\n   */\n  readLine: function(out)\n  {\n    var data = this._data;\n    var length = findCRLF(data, this._start);\n    if (length < 0)\n    {\n      this._start = data.length;\n\n      // But if our data ends in a CR, we have to back up one, because\n      // the first byte in the next packet might be an LF and if we\n      // start looking at data.length we won't find it.\n      if (data.length > 0 && data[data.length - 1] === CR)\n        --this._start;\n\n      return false;\n    }\n\n    // Reset for future lines.\n    this._start = 0;\n\n    //\n    // We have the index of the CR, so remove all the characters, including\n    // CRLF, from the array with splice, and convert the removed array\n    // (excluding the trailing CRLF characters) into the corresponding string.\n    //\n    var leading = data.splice(0, length + 2);\n    var quantum = 262144;\n    var line = \"\";\n    for (var start = 0; start < length; start += quantum)\n    {\n      var slice = leading.slice(start, Math.min(start + quantum, length));\n      line += String.fromCharCode.apply(null, slice);\n    }\n\n    out.value = line;\n    return true;\n  },\n\n  /**\n   * Removes the bytes currently within this and returns them in an array.\n   *\n   * @returns Array\n   *   the bytes within this when this method is called\n   */\n  purge: function()\n  {\n    var data = this._data;\n    this._data = [];\n    return data;\n  }\n};\n\n\n\n/**\n * Creates a request-handling function for an nsIHttpRequestHandler object.\n */\nfunction createHandlerFunc(handler)\n{\n  return function(metadata, response) { handler.handle(metadata, response); };\n}\n\n\n/**\n * The default handler for directories; writes an HTML response containing a\n * slightly-formatted directory listing.\n */\nfunction defaultIndexHandler(metadata, response)\n{\n  response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\", false);\n\n  var path = htmlEscape(decodeURI(metadata.path));\n\n  //\n  // Just do a very basic bit of directory listings -- no need for too much\n  // fanciness, especially since we don't have a style sheet in which we can\n  // stick rules (don't want to pollute the default path-space).\n  //\n\n  var body = '<html>\\\n                <head>\\\n                  <title>' + path + '</title>\\\n                </head>\\\n                <body>\\\n                  <h1>' + path + '</h1>\\\n                  <ol style=\"list-style-type: none\">';\n\n  var directory = metadata.getProperty(\"directory\");\n  NS_ASSERT(directory && directory.isDirectory());\n\n  var fileList = [];\n  var files = directory.directoryEntries;\n  while (files.hasMoreElements())\n  {\n    var f = files.getNext().QueryInterface(Ci.nsIFile);\n    var name = f.leafName;\n    if (!f.isHidden() &&\n        (name.charAt(name.length - 1) != HIDDEN_CHAR ||\n         name.charAt(name.length - 2) == HIDDEN_CHAR))\n      fileList.push(f);\n  }\n\n  fileList.sort(fileSort);\n\n  for (var i = 0; i < fileList.length; i++)\n  {\n    var file = fileList[i];\n    try\n    {\n      var name = file.leafName;\n      if (name.charAt(name.length - 1) == HIDDEN_CHAR)\n        name = name.substring(0, name.length - 1);\n      var sep = file.isDirectory() ? \"/\" : \"\";\n\n      // Note: using \" to delimit the attribute here because encodeURIComponent\n      //       passes through '.\n      var item = '<li><a href=\"' + encodeURIComponent(name) + sep + '\">' +\n                   htmlEscape(name) + sep +\n                 '</a></li>';\n\n      body += item;\n    }\n    catch (e) { /* some file system error, ignore the file */ }\n  }\n\n  body    += '    </ol>\\\n                </body>\\\n              </html>';\n\n  response.bodyOutputStream.write(body, body.length);\n}\n\n/**\n * Sorts a and b (nsIFile objects) into an aesthetically pleasing order.\n */\nfunction fileSort(a, b)\n{\n  var dira = a.isDirectory(), dirb = b.isDirectory();\n\n  if (dira && !dirb)\n    return -1;\n  if (dirb && !dira)\n    return 1;\n\n  var namea = a.leafName.toLowerCase(), nameb = b.leafName.toLowerCase();\n  return nameb > namea ? -1 : 1;\n}\n\n\n/**\n * Converts an externally-provided path into an internal path for use in\n * determining file mappings.\n *\n * @param path\n *   the path to convert\n * @param encoded\n *   true if the given path should be passed through decodeURI prior to\n *   conversion\n * @throws URIError\n *   if path is incorrectly encoded\n */\nfunction toInternalPath(path, encoded)\n{\n  if (encoded)\n    path = decodeURI(path);\n\n  var comps = path.split(\"/\");\n  for (var i = 0, sz = comps.length; i < sz; i++)\n  {\n    var comp = comps[i];\n    if (comp.charAt(comp.length - 1) == HIDDEN_CHAR)\n      comps[i] = comp + HIDDEN_CHAR;\n  }\n  return comps.join(\"/\");\n}\n\nconst PERMS_READONLY = (4 << 6) | (4 << 3) | 4;\n\n/**\n * Adds custom-specified headers for the given file to the given response, if\n * any such headers are specified.\n *\n * @param file\n *   the file on the disk which is to be written\n * @param metadata\n *   metadata about the incoming request\n * @param response\n *   the Response to which any specified headers/data should be written\n * @throws HTTP_500\n *   if an error occurred while processing custom-specified headers\n */\nfunction maybeAddHeaders(file, metadata, response)\n{\n  var name = file.leafName;\n  if (name.charAt(name.length - 1) == HIDDEN_CHAR)\n    name = name.substring(0, name.length - 1);\n\n  var headerFile = file.parent;\n  headerFile.append(name + HEADERS_SUFFIX);\n\n  if (!headerFile.exists())\n    return;\n\n  const PR_RDONLY = 0x01;\n  var fis = new FileInputStream(headerFile, PR_RDONLY, PERMS_READONLY,\n                                Ci.nsIFileInputStream.CLOSE_ON_EOF);\n\n  try\n  {\n    var lis = new ConverterInputStream(fis, \"UTF-8\", 1024, 0x0);\n    lis.QueryInterface(Ci.nsIUnicharLineInputStream);\n\n    var line = {value: \"\"};\n    var more = lis.readLine(line);\n\n    if (!more && line.value == \"\")\n      return;\n\n\n    // request line\n\n    var status = line.value;\n    if (status.indexOf(\"HTTP \") == 0)\n    {\n      status = status.substring(5);\n      var space = status.indexOf(\" \");\n      var code, description;\n      if (space < 0)\n      {\n        code = status;\n        description = \"\";\n      }\n      else\n      {\n        code = status.substring(0, space);\n        description = status.substring(space + 1, status.length);\n      }\n    \n      response.setStatusLine(metadata.httpVersion, parseInt(code, 10), description);\n\n      line.value = \"\";\n      more = lis.readLine(line);\n    }\n\n    // headers\n    while (more || line.value != \"\")\n    {\n      var header = line.value;\n      var colon = header.indexOf(\":\");\n\n      response.setHeader(header.substring(0, colon),\n                         header.substring(colon + 1, header.length),\n                         false); // allow overriding server-set headers\n\n      line.value = \"\";\n      more = lis.readLine(line);\n    }\n  }\n  catch (e)\n  {\n    dumpn(\"WARNING: error in headers for \" + metadata.path + \": \" + e);\n    throw HTTP_500;\n  }\n  finally\n  {\n    fis.close();\n  }\n}\n\n\n/**\n * An object which handles requests for a server, executing default and\n * overridden behaviors as instructed by the code which uses and manipulates it.\n * Default behavior includes the paths / and /trace (diagnostics), with some\n * support for HTTP error pages for various codes and fallback to HTTP 500 if\n * those codes fail for any reason.\n *\n * @param server : nsHttpServer\n *   the server in which this handler is being used\n */\nfunction ServerHandler(server)\n{\n  // FIELDS\n\n  /**\n   * The nsHttpServer instance associated with this handler.\n   */\n  this._server = server;\n\n  /**\n   * A FileMap object containing the set of path->nsILocalFile mappings for\n   * all directory mappings set in the server (e.g., \"/\" for /var/www/html/,\n   * \"/foo/bar/\" for /local/path/, and \"/foo/bar/baz/\" for /local/path2).\n   *\n   * Note carefully: the leading and trailing \"/\" in each path (not file) are\n   * removed before insertion to simplify the code which uses this.  You have\n   * been warned!\n   */\n  this._pathDirectoryMap = new FileMap();\n\n  /**\n   * Custom request handlers for the server in which this resides.  Path-handler\n   * pairs are stored as property-value pairs in this property.\n   *\n   * @see ServerHandler.prototype._defaultPaths\n   */\n  this._overridePaths = {};\n\n  /**\n   * Custom request handlers for the path prefixes on the server in which this\n   * resides.  Path-handler pairs are stored as property-value pairs in this\n   * property.\n   *\n   * @see ServerHandler.prototype._defaultPaths\n   */\n  this._overridePrefixes = {};\n\n  /**\n   * Custom request handlers for the error handlers in the server in which this\n   * resides.  Path-handler pairs are stored as property-value pairs in this\n   * property.\n   *\n   * @see ServerHandler.prototype._defaultErrors\n   */\n  this._overrideErrors = {};\n\n  /**\n   * Maps file extensions to their MIME types in the server, overriding any\n   * mapping that might or might not exist in the MIME service.\n   */\n  this._mimeMappings = {};\n\n  /**\n   * The default handler for requests for directories, used to serve directories\n   * when no index file is present.\n   */\n  this._indexHandler = defaultIndexHandler;\n\n  /** Per-path state storage for the server. */\n  this._state = {};\n\n  /** Entire-server state storage. */\n  this._sharedState = {};\n\n  /** Entire-server state storage for nsISupports values. */\n  this._objectState = {};\n}\nServerHandler.prototype =\n{\n  // PUBLIC API\n\n  /**\n   * Handles a request to this server, responding to the request appropriately\n   * and initiating server shutdown if necessary.\n   *\n   * This method never throws an exception.\n   *\n   * @param connection : Connection\n   *   the connection for this request\n   */\n  handleResponse: function(connection)\n  {\n    var request = connection.request;\n    var response = new Response(connection);\n\n    var path = request.path;\n    dumpn(\"*** path == \" + path);\n\n    // indicate if the response is built asynchronously\n    // or not. For some handlers, it will be true.\n    // it allows to not close the response\n    // after the call of the handler.\n    var asyncResp = false;\n    try\n    {\n      try\n      {\n        if (path in this._overridePaths)\n        {\n          // explicit paths first, then files based on existing directory mappings,\n          // then (if the file doesn't exist) built-in server default paths\n          dumpn(\"calling override for \" + path);\n          let handler = this._overridePaths[path]\n          handler(request, response);\n          if ('isAsync' in handler && handler.isAsync) {\n            asyncResp = true;\n          }\n        }\n        else\n        {\n          var longestPrefix = \"\";\n          for (let prefix in this._overridePrefixes) {\n            if (prefix.length > longestPrefix.length &&\n                path.substr(0, prefix.length) == prefix)\n            {\n              longestPrefix = prefix;\n            }\n          }\n          if (longestPrefix.length > 0)\n          {\n            dumpn(\"calling prefix override for \" + longestPrefix);\n            let handler = this._overridePrefixes[longestPrefix]\n            handler(request, response);\n            if ('isAsync' in handler && handler.isAsync) {\n                asyncResp = true;\n            }\n          }\n          else\n          {\n            this._handleDefault(request, response);\n          }\n        }\n      }\n      catch (e)\n      {\n        if (response.partiallySent())\n        {\n          response.abort(e);\n          return;\n        }\n\n        if (!(e instanceof HttpError))\n        {\n          dumpn(\"*** unexpected error: e == \" + e);\n          throw HTTP_500;\n        }\n        if (e.code !== 404)\n          throw e;\n\n        dumpn(\"*** default: \" + (path in this._defaultPaths));\n\n        response = new Response(connection);\n        if (path in this._defaultPaths)\n          this._defaultPaths[path](request, response);\n        else\n          throw HTTP_404;\n      }\n    }\n    catch (e)\n    {\n      if (response.partiallySent())\n      {\n        response.abort(e);\n        return;\n      }\n\n      var errorCode = \"internal\";\n\n      try\n      {\n        if (!(e instanceof HttpError))\n          throw e;\n\n        errorCode = e.code;\n        dumpn(\"*** errorCode == \" + errorCode);\n\n        response = new Response(connection);\n        if (e.customErrorHandling)\n          e.customErrorHandling(response);\n        this._handleError(errorCode, request, response);\n        return;\n      }\n      catch (e2)\n      {\n        dumpn(\"*** error handling \" + errorCode + \" error: \" +\n              \"e2 == \" + e2 + \", shutting down server\");\n\n        connection.server._requestQuit();\n        response.abort(e2);\n        return;\n      }\n    }\n    if (!asyncResp) {\n        response.complete();\n    }\n  },\n\n  //\n  // see nsIHttpServer.registerFile\n  //\n  registerFile: function(path, file)\n  {\n    if (!file)\n    {\n      dumpn(\"*** unregistering '\" + path + \"' mapping\");\n      delete this._overridePaths[path];\n      return;\n    }\n\n    dumpn(\"*** registering '\" + path + \"' as mapping to \" + file.path);\n    file = file.clone();\n\n    var self = this;\n    this._overridePaths[path] =\n      function(request, response)\n      {\n        if (!file.exists())\n          throw HTTP_404;\n\n        response.setStatusLine(request.httpVersion, 200, \"OK\");\n        self._writeFileResponse(request, file, response, 0, file.fileSize);\n      };\n  },\n\n  //\n  // see nsIHttpServer.registerPathHandler\n  //\n  registerPathHandler: function(path, handler)\n  {\n    // XXX true path validation!\n    if (path.charAt(0) != \"/\")\n      throw Cr.NS_ERROR_INVALID_ARG;\n\n    this._handlerToField(handler, this._overridePaths, path, true);\n  },\n\n  //\n  // see nsIHttpServer.registerPrefixHandler\n  //\n  registerPrefixHandler: function(path, handler)\n  {\n    // XXX true path validation!\n    if (path.charAt(0) != \"/\" || path.charAt(path.length - 1) != \"/\")\n      throw Cr.NS_ERROR_INVALID_ARG;\n\n    this._handlerToField(handler, this._overridePrefixes, path, true);\n  },\n\n  //\n  // see nsIHttpServer.registerDirectory\n  //\n  registerDirectory: function(path, directory)\n  {\n    // strip off leading and trailing '/' so that we can use lastIndexOf when\n    // determining exactly how a path maps onto a mapped directory --\n    // conditional is required here to deal with \"/\".substring(1, 0) being\n    // converted to \"/\".substring(0, 1) per the JS specification\n    var key = path.length == 1 ? \"\" : path.substring(1, path.length - 1);\n\n    // the path-to-directory mapping code requires that the first character not\n    // be \"/\", or it will go into an infinite loop\n    if (key.charAt(0) == \"/\")\n      throw Cr.NS_ERROR_INVALID_ARG;\n\n    key = toInternalPath(key, false);\n\n    if (directory)\n    {\n      dumpn(\"*** mapping '\" + path + \"' to the location \" + directory.path);\n      this._pathDirectoryMap.put(key, directory);\n    }\n    else\n    {\n      dumpn(\"*** removing mapping for '\" + path + \"'\");\n      this._pathDirectoryMap.put(key, null);\n    }\n  },\n\n  //\n  // see nsIHttpServer.registerErrorHandler\n  //\n  registerErrorHandler: function(err, handler)\n  {\n    if (!(err in HTTP_ERROR_CODES))\n      dumpn(\"*** WARNING: registering non-HTTP/1.1 error code \" +\n            \"(\" + err + \") handler -- was this intentional?\");\n\n    this._handlerToField(handler, this._overrideErrors, err);\n  },\n\n  //\n  // see nsIHttpServer.setIndexHandler\n  //\n  setIndexHandler: function(handler)\n  {\n    if (!handler)\n      handler = defaultIndexHandler;\n    else if (typeof(handler) != \"function\")\n      handler = createHandlerFunc(handler);\n\n    this._indexHandler = handler;\n  },\n\n  //\n  // see nsIHttpServer.registerContentType\n  //\n  registerContentType: function(ext, type)\n  {\n    if (!type)\n      delete this._mimeMappings[ext];\n    else\n      this._mimeMappings[ext] = headerUtils.normalizeFieldValue(type);\n  },\n\n  // PRIVATE API\n\n  /**\n   * Sets or remove (if handler is null) a handler in an object with a key.\n   *\n   * @param handler\n   *   a handler, either function or an nsIHttpRequestHandler\n   * @param dict\n   *   The object to attach the handler to.\n   * @param key\n   *   The field name of the handler.\n   */\n  _handlerToField: function(handler, dict, key, asynchronousHandler)\n  {\n    // for convenience, handler can be a function if this is run from xpcshell\n    if (typeof(handler) == \"function\")\n      dict[key] = handler;\n    else if (handler)\n      dict[key] = createHandlerFunc(handler);\n    else {\n      delete dict[key];\n      return;\n    }\n    dict[key].isAsync = asynchronousHandler;\n  },\n\n  /**\n   * Handles a request which maps to a file in the local filesystem (if a base\n   * path has already been set; otherwise the 404 error is thrown).\n   *\n   * @param metadata : Request\n   *   metadata for the incoming request\n   * @param response : Response\n   *   an uninitialized Response to the given request, to be initialized by a\n   *   request handler\n   * @throws HTTP_###\n   *   if an HTTP error occurred (usually HTTP_404); note that in this case the\n   *   calling code must handle post-processing of the response\n   */\n  _handleDefault: function(metadata, response)\n  {\n    dumpn(\"*** _handleDefault()\");\n\n    response.setStatusLine(metadata.httpVersion, 200, \"OK\");\n\n    var path = metadata.path;\n    NS_ASSERT(path.charAt(0) == \"/\", \"invalid path: <\" + path + \">\");\n\n    // determine the actual on-disk file; this requires finding the deepest\n    // path-to-directory mapping in the requested URL\n    var file = this._getFileForPath(path);\n\n    // the \"file\" might be a directory, in which case we either serve the\n    // contained index.html or make the index handler write the response\n    if (file.exists() && file.isDirectory())\n    {\n      file.append(\"index.html\"); // make configurable?\n      if (!file.exists() || file.isDirectory())\n      {\n        metadata._ensurePropertyBag();\n        metadata._bag.setPropertyAsInterface(\"directory\", file.parent);\n        this._indexHandler(metadata, response);\n        return;\n      }\n    }\n\n    // alternately, the file might not exist\n    if (!file.exists())\n      throw HTTP_404;\n\n    var start, end;\n    if (metadata._httpVersion.atLeast(nsHttpVersion.HTTP_1_1) &&\n        metadata.hasHeader(\"Range\") &&\n        this._getTypeFromFile(file) !== SJS_TYPE)\n    {\n      var rangeMatch = metadata.getHeader(\"Range\").match(/^bytes=(\\d+)?-(\\d+)?$/);\n      if (!rangeMatch)\n      {\n        dumpn(\"*** Range header bogosity: '\" + metadata.getHeader(\"Range\") + \"'\");\n        throw HTTP_400;\n      }\n\n      if (rangeMatch[1] !== undefined)\n        start = parseInt(rangeMatch[1], 10);\n\n      if (rangeMatch[2] !== undefined)\n        end = parseInt(rangeMatch[2], 10);\n\n      if (start === undefined && end === undefined)\n      {\n        dumpn(\"*** More Range header bogosity: '\" + metadata.getHeader(\"Range\") + \"'\");\n        throw HTTP_400;\n      }\n\n      // No start given, so the end is really the count of bytes from the\n      // end of the file.\n      if (start === undefined)\n      {\n        start = Math.max(0, file.fileSize - end);\n        end   = file.fileSize - 1;\n      }\n\n      // start and end are inclusive\n      if (end === undefined || end >= file.fileSize)\n        end = file.fileSize - 1;\n\n      if (start !== undefined && start >= file.fileSize) {\n        var HTTP_416 = new HttpError(416, \"Requested Range Not Satisfiable\");\n        HTTP_416.customErrorHandling = function(errorResponse)\n        {\n          maybeAddHeaders(file, metadata, errorResponse);\n        };\n        throw HTTP_416;\n      }\n\n      if (end < start)\n      {\n        response.setStatusLine(metadata.httpVersion, 200, \"OK\");\n        start = 0;\n        end = file.fileSize - 1;\n      }\n      else\n      {\n        response.setStatusLine(metadata.httpVersion, 206, \"Partial Content\");\n        var contentRange = \"bytes \" + start + \"-\" + end + \"/\" + file.fileSize;\n        response.setHeader(\"Content-Range\", contentRange);\n      }\n    }\n    else\n    {\n      start = 0;\n      end = file.fileSize - 1;\n    }\n\n    // finally...\n    dumpn(\"*** handling '\" + path + \"' as mapping to \" + file.path + \" from \" +\n          start + \" to \" + end + \" inclusive\");\n    this._writeFileResponse(metadata, file, response, start, end - start + 1);\n  },\n\n  /**\n   * Writes an HTTP response for the given file, including setting headers for\n   * file metadata.\n   *\n   * @param metadata : Request\n   *   the Request for which a response is being generated\n   * @param file : nsILocalFile\n   *   the file which is to be sent in the response\n   * @param response : Response\n   *   the response to which the file should be written\n   * @param offset: uint\n   *   the byte offset to skip to when writing\n   * @param count: uint\n   *   the number of bytes to write\n   */\n  _writeFileResponse: function(metadata, file, response, offset, count)\n  {\n    const PR_RDONLY = 0x01;\n\n    var type = this._getTypeFromFile(file);\n    if (type === SJS_TYPE)\n    {\n      var fis = new FileInputStream(file, PR_RDONLY, PERMS_READONLY,\n                                    Ci.nsIFileInputStream.CLOSE_ON_EOF);\n\n      try\n      {\n        var sis = new ScriptableInputStream(fis);\n        var s = Cu.Sandbox(gGlobalObject);\n        s.importFunction(dump, \"dump\");\n        s.importFunction(atob, \"atob\");\n        s.importFunction(btoa, \"btoa\");\n\n        // Define a basic key-value state-preservation API across requests, with\n        // keys initially corresponding to the empty string.\n        var self = this;\n        var path = metadata.path;\n        s.importFunction(function getState(k)\n        {\n          return self._getState(path, k);\n        });\n        s.importFunction(function setState(k, v)\n        {\n          self._setState(path, k, v);\n        });\n        s.importFunction(function getSharedState(k)\n        {\n          return self._getSharedState(k);\n        });\n        s.importFunction(function setSharedState(k, v)\n        {\n          self._setSharedState(k, v);\n        });\n        s.importFunction(function getObjectState(k, callback)\n        {\n          callback(self._getObjectState(k));\n        });\n        s.importFunction(function setObjectState(k, v)\n        {\n          self._setObjectState(k, v);\n        });\n        s.importFunction(function registerPathHandler(p, h)\n        {\n          self.registerPathHandler(p, h);\n        });\n\n        // Make it possible for sjs files to access their location\n        this._setState(path, \"__LOCATION__\", file.path);\n\n        try\n        {\n          // Alas, the line number in errors dumped to console when calling the\n          // request handler is simply an offset from where we load the SJS file.\n          // Work around this in a reasonably non-fragile way by dynamically\n          // getting the line number where we evaluate the SJS file.  Don't\n          // separate these two lines!\n          var line = new Error().lineNumber;\n          Cu.evalInSandbox(sis.read(file.fileSize), s, \"latest\");\n        }\n        catch (e)\n        {\n          dumpn(\"*** syntax error in SJS at \" + file.path + \": \" + e);\n          throw HTTP_500;\n        }\n\n        try\n        {\n          s.handleRequest(metadata, response);\n        }\n        catch (e)\n        {\n          dump(\"*** error running SJS at \" + file.path + \": \" +\n               e + \" on line \" +\n               (e instanceof Error\n               ? e.lineNumber + \" in httpd.js\"\n               : (e.lineNumber - line)) + \"\\n\");\n          throw HTTP_500;\n        }\n      }\n      finally\n      {\n        fis.close();\n      }\n    }\n    else\n    {\n      try\n      {\n        response.setHeader(\"Last-Modified\",\n                           toDateString(file.lastModifiedTime),\n                           false);\n      }\n      catch (e) { /* lastModifiedTime threw, ignore */ }\n\n      response.setHeader(\"Content-Type\", type, false);\n      maybeAddHeaders(file, metadata, response);\n      response.setHeader(\"Content-Length\", \"\" + count, false);\n\n      var fis = new FileInputStream(file, PR_RDONLY, PERMS_READONLY,\n                                    Ci.nsIFileInputStream.CLOSE_ON_EOF);\n\n      offset = offset || 0;\n      count  = count || file.fileSize;\n      NS_ASSERT(offset === 0 || offset < file.fileSize, \"bad offset\");\n      NS_ASSERT(count >= 0, \"bad count\");\n      NS_ASSERT(offset + count <= file.fileSize, \"bad total data size\");\n\n      try\n      {\n        if (offset !== 0)\n        {\n          // Seek (or read, if seeking isn't supported) to the correct offset so\n          // the data sent to the client matches the requested range.\n          if (fis instanceof Ci.nsISeekableStream)\n            fis.seek(Ci.nsISeekableStream.NS_SEEK_SET, offset);\n          else\n            new ScriptableInputStream(fis).read(offset);\n        }\n      }\n      catch (e)\n      {\n        fis.close();\n        throw e;\n      }\n\n      let writeMore = function ()\n      {\n        gThreadManager.currentThread\n                      .dispatch(writeData, Ci.nsIThread.DISPATCH_NORMAL);\n      }\n\n      var input = new BinaryInputStream(fis);\n      var output = new BinaryOutputStream(response.bodyOutputStream);\n      var writeData =\n        {\n          run: function()\n          {\n            var chunkSize = Math.min(65536, count);\n            count -= chunkSize;\n            NS_ASSERT(count >= 0, \"underflow\");\n\n            try\n            {\n              var data = input.readByteArray(chunkSize);\n              NS_ASSERT(data.length === chunkSize,\n                        \"incorrect data returned?  got \" + data.length +\n                        \", expected \" + chunkSize);\n              output.writeByteArray(data, data.length);\n              if (count === 0)\n              {\n                fis.close();\n                response.finish();\n              }\n              else\n              {\n                writeMore();\n              }\n            }\n            catch (e)\n            {\n              try\n              {\n                fis.close();\n              }\n              finally\n              {\n                response.finish();\n              }\n              throw e;\n            }\n          }\n        };\n\n      writeMore();\n\n      // Now that we know copying will start, flag the response as async.\n      response.processAsync();\n    }\n  },\n\n  /**\n   * Get the value corresponding to a given key for the given path for SJS state\n   * preservation across requests.\n   *\n   * @param path : string\n   *   the path from which the given state is to be retrieved\n   * @param k : string\n   *   the key whose corresponding value is to be returned\n   * @returns string\n   *   the corresponding value, which is initially the empty string\n   */\n  _getState: function(path, k)\n  {\n    var state = this._state;\n    if (path in state && k in state[path])\n      return state[path][k];\n    return \"\";\n  },\n\n  /**\n   * Set the value corresponding to a given key for the given path for SJS state\n   * preservation across requests.\n   *\n   * @param path : string\n   *   the path from which the given state is to be retrieved\n   * @param k : string\n   *   the key whose corresponding value is to be set\n   * @param v : string\n   *   the value to be set\n   */\n  _setState: function(path, k, v)\n  {\n    if (typeof v !== \"string\")\n      throw new Error(\"non-string value passed\");\n    var state = this._state;\n    if (!(path in state))\n      state[path] = {};\n    state[path][k] = v;\n  },\n\n  /**\n   * Get the value corresponding to a given key for SJS state preservation\n   * across requests.\n   *\n   * @param k : string\n   *   the key whose corresponding value is to be returned\n   * @returns string\n   *   the corresponding value, which is initially the empty string\n   */\n  _getSharedState: function(k)\n  {\n    var state = this._sharedState;\n    if (k in state)\n      return state[k];\n    return \"\";\n  },\n\n  /**\n   * Set the value corresponding to a given key for SJS state preservation\n   * across requests.\n   *\n   * @param k : string\n   *   the key whose corresponding value is to be set\n   * @param v : string\n   *   the value to be set\n   */\n  _setSharedState: function(k, v)\n  {\n    if (typeof v !== \"string\")\n      throw new Error(\"non-string value passed\");\n    this._sharedState[k] = v;\n  },\n\n  /**\n   * Returns the object associated with the given key in the server for SJS\n   * state preservation across requests.\n   *\n   * @param k : string\n   *  the key whose corresponding object is to be returned\n   * @returns nsISupports\n   *  the corresponding object, or null if none was present\n   */\n  _getObjectState: function(k)\n  {\n    if (typeof k !== \"string\")\n      throw new Error(\"non-string key passed\");\n    return this._objectState[k] || null;\n  },\n\n  /**\n   * Sets the object associated with the given key in the server for SJS\n   * state preservation across requests.\n   *\n   * @param k : string\n   *  the key whose corresponding object is to be set\n   * @param v : nsISupports\n   *  the object to be associated with the given key; may be null\n   */\n  _setObjectState: function(k, v)\n  {\n    if (typeof k !== \"string\")\n      throw new Error(\"non-string key passed\");\n    if (typeof v !== \"object\")\n      throw new Error(\"non-object value passed\");\n    if (v && !(\"QueryInterface\" in v))\n    {\n      throw new Error(\"must pass an nsISupports; use wrappedJSObject to ease \" +\n                      \"pain when using the server from JS\");\n    }\n\n    this._objectState[k] = v;\n  },\n\n  /**\n   * Gets a content-type for the given file, first by checking for any custom\n   * MIME-types registered with this handler for the file's extension, second by\n   * asking the global MIME service for a content-type, and finally by failing\n   * over to application/octet-stream.\n   *\n   * @param file : nsIFile\n   *   the nsIFile for which to get a file type\n   * @returns string\n   *   the best content-type which can be determined for the file\n   */\n  _getTypeFromFile: function(file)\n  {\n    try\n    {\n      var name = file.leafName;\n      var dot = name.lastIndexOf(\".\");\n      if (dot > 0)\n      {\n        var ext = name.slice(dot + 1);\n        if (ext in this._mimeMappings)\n          return this._mimeMappings[ext];\n      }\n      return Cc[\"@mozilla.org/uriloader/external-helper-app-service;1\"]\n               .getService(Ci.nsIMIMEService)\n               .getTypeFromFile(file);\n    }\n    catch (e)\n    {\n      return \"application/octet-stream\";\n    }\n  },\n\n  /**\n   * Returns the nsILocalFile which corresponds to the path, as determined using\n   * all registered path->directory mappings and any paths which are explicitly\n   * overridden.\n   *\n   * @param path : string\n   *   the server path for which a file should be retrieved, e.g. \"/foo/bar\"\n   * @throws HttpError\n   *   when the correct action is the corresponding HTTP error (i.e., because no\n   *   mapping was found for a directory in path, the referenced file doesn't\n   *   exist, etc.)\n   * @returns nsILocalFile\n   *   the file to be sent as the response to a request for the path\n   */\n  _getFileForPath: function(path)\n  {\n    // decode and add underscores as necessary\n    try\n    {\n      path = toInternalPath(path, true);\n    }\n    catch (e)\n    {\n      dumpn(\"*** toInternalPath threw \" + e);\n      throw HTTP_400; // malformed path\n    }\n\n    // next, get the directory which contains this path\n    var pathMap = this._pathDirectoryMap;\n\n    // An example progression of tmp for a path \"/foo/bar/baz/\" might be:\n    // \"foo/bar/baz/\", \"foo/bar/baz\", \"foo/bar\", \"foo\", \"\"\n    var tmp = path.substring(1);\n    while (true)\n    {\n      // do we have a match for current head of the path?\n      var file = pathMap.get(tmp);\n      if (file)\n      {\n        // XXX hack; basically disable showing mapping for /foo/bar/ when the\n        //     requested path was /foo/bar, because relative links on the page\n        //     will all be incorrect -- we really need the ability to easily\n        //     redirect here instead\n        if (tmp == path.substring(1) &&\n            tmp.length != 0 &&\n            tmp.charAt(tmp.length - 1) != \"/\")\n          file = null;\n        else\n          break;\n      }\n\n      // if we've finished trying all prefixes, exit\n      if (tmp == \"\")\n        break;\n\n      tmp = tmp.substring(0, tmp.lastIndexOf(\"/\"));\n    }\n\n    // no mapping applies, so 404\n    if (!file)\n      throw HTTP_404;\n\n\n    // last, get the file for the path within the determined directory\n    var parentFolder = file.parent;\n    var dirIsRoot = (parentFolder == null);\n\n    // Strategy here is to append components individually, making sure we\n    // never move above the given directory; this allows paths such as\n    // \"<file>/foo/../bar\" but prevents paths such as \"<file>/../base-sibling\";\n    // this component-wise approach also means the code works even on platforms\n    // which don't use \"/\" as the directory separator, such as Windows\n    var leafPath = path.substring(tmp.length + 1);\n    var comps = leafPath.split(\"/\");\n    for (var i = 0, sz = comps.length; i < sz; i++)\n    {\n      var comp = comps[i];\n\n      if (comp == \"..\")\n        file = file.parent;\n      else if (comp == \".\" || comp == \"\")\n        continue;\n      else\n        file.append(comp);\n\n      if (!dirIsRoot && file.equals(parentFolder))\n        throw HTTP_403;\n    }\n\n    return file;\n  },\n\n  /**\n   * Writes the error page for the given HTTP error code over the given\n   * connection.\n   *\n   * @param errorCode : uint\n   *   the HTTP error code to be used\n   * @param connection : Connection\n   *   the connection on which the error occurred\n   */\n  handleError: function(errorCode, connection)\n  {\n    var response = new Response(connection);\n\n    dumpn(\"*** error in request: \" + errorCode);\n\n    this._handleError(errorCode, new Request(connection.port), response);\n  }, \n\n  /**\n   * Handles a request which generates the given error code, using the\n   * user-defined error handler if one has been set, gracefully falling back to\n   * the x00 status code if the code has no handler, and failing to status code\n   * 500 if all else fails.\n   *\n   * @param errorCode : uint\n   *   the HTTP error which is to be returned\n   * @param metadata : Request\n   *   metadata for the request, which will often be incomplete since this is an\n   *   error\n   * @param response : Response\n   *   an uninitialized Response should be initialized when this method\n   *   completes with information which represents the desired error code in the\n   *   ideal case or a fallback code in abnormal circumstances (i.e., 500 is a\n   *   fallback for 505, per HTTP specs)\n   */\n  _handleError: function(errorCode, metadata, response)\n  {\n    if (!metadata)\n      throw Cr.NS_ERROR_NULL_POINTER;\n\n    var errorX00 = errorCode - (errorCode % 100);\n\n    try\n    {\n      if (!(errorCode in HTTP_ERROR_CODES))\n        dumpn(\"*** WARNING: requested invalid error: \" + errorCode);\n\n      // RFC 2616 says that we should try to handle an error by its class if we\n      // can't otherwise handle it -- if that fails, we revert to handling it as\n      // a 500 internal server error, and if that fails we throw and shut down\n      // the server\n\n      // actually handle the error\n      try\n      {\n        if (errorCode in this._overrideErrors)\n          this._overrideErrors[errorCode](metadata, response);\n        else\n          this._defaultErrors[errorCode](metadata, response);\n      }\n      catch (e)\n      {\n        if (response.partiallySent())\n        {\n          response.abort(e);\n          return;\n        }\n\n        // don't retry the handler that threw\n        if (errorX00 == errorCode)\n          throw HTTP_500;\n\n        dumpn(\"*** error in handling for error code \" + errorCode + \", \" +\n              \"falling back to \" + errorX00 + \"...\");\n        response = new Response(response._connection);\n        if (errorX00 in this._overrideErrors)\n          this._overrideErrors[errorX00](metadata, response);\n        else if (errorX00 in this._defaultErrors)\n          this._defaultErrors[errorX00](metadata, response);\n        else\n          throw HTTP_500;\n      }\n    }\n    catch (e)\n    {\n      if (response.partiallySent())\n      {\n        response.abort();\n        return;\n      }\n\n      // we've tried everything possible for a meaningful error -- now try 500\n      dumpn(\"*** error in handling for error code \" + errorX00 + \", falling \" +\n            \"back to 500...\");\n\n      try\n      {\n        response = new Response(response._connection);\n        if (500 in this._overrideErrors)\n          this._overrideErrors[500](metadata, response);\n        else\n          this._defaultErrors[500](metadata, response);\n      }\n      catch (e2)\n      {\n        dumpn(\"*** multiple errors in default error handlers!\");\n        dumpn(\"*** e == \" + e + \", e2 == \" + e2);\n        response.abort(e2);\n        return;\n      }\n    }\n\n    response.complete();\n  },\n\n  // FIELDS\n\n  /**\n   * This object contains the default handlers for the various HTTP error codes.\n   */\n  _defaultErrors:\n  {\n    400: function(metadata, response)\n    {\n      // none of the data in metadata is reliable, so hard-code everything here\n      response.setStatusLine(\"1.1\", 400, \"Bad Request\");\n      response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\", false);\n\n      var body = \"Bad request\\n\";\n      response.bodyOutputStream.write(body, body.length);\n    },\n    403: function(metadata, response)\n    {\n      response.setStatusLine(metadata.httpVersion, 403, \"Forbidden\");\n      response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\", false);\n\n      var body = \"<html>\\\n                    <head><title>403 Forbidden</title></head>\\\n                    <body>\\\n                      <h1>403 Forbidden</h1>\\\n                    </body>\\\n                  </html>\";\n      response.bodyOutputStream.write(body, body.length);\n    },\n    404: function(metadata, response)\n    {\n      response.setStatusLine(metadata.httpVersion, 404, \"Not Found\");\n      response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\", false);\n\n      var body = \"<html>\\\n                    <head><title>404 Not Found</title></head>\\\n                    <body>\\\n                      <h1>404 Not Found</h1>\\\n                      <p>\\\n                        <span style='font-family: monospace;'>\" +\n                          htmlEscape(metadata.path) +\n                       \"</span> was not found.\\\n                      </p>\\\n                    </body>\\\n                  </html>\";\n      response.bodyOutputStream.write(body, body.length);\n    },\n    416: function(metadata, response)\n    {\n      response.setStatusLine(metadata.httpVersion,\n                            416,\n                            \"Requested Range Not Satisfiable\");\n      response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\", false);\n\n      var body = \"<html>\\\n                   <head>\\\n                    <title>416 Requested Range Not Satisfiable</title></head>\\\n                    <body>\\\n                     <h1>416 Requested Range Not Satisfiable</h1>\\\n                     <p>The byte range was not valid for the\\\n                        requested resource.\\\n                     </p>\\\n                    </body>\\\n                  </html>\";\n      response.bodyOutputStream.write(body, body.length);\n    },\n    500: function(metadata, response)\n    {\n      response.setStatusLine(metadata.httpVersion,\n                             500,\n                             \"Internal Server Error\");\n      response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\", false);\n\n      var body = \"<html>\\\n                    <head><title>500 Internal Server Error</title></head>\\\n                    <body>\\\n                      <h1>500 Internal Server Error</h1>\\\n                      <p>Something's broken in this server and\\\n                        needs to be fixed.</p>\\\n                    </body>\\\n                  </html>\";\n      response.bodyOutputStream.write(body, body.length);\n    },\n    501: function(metadata, response)\n    {\n      response.setStatusLine(metadata.httpVersion, 501, \"Not Implemented\");\n      response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\", false);\n\n      var body = \"<html>\\\n                    <head><title>501 Not Implemented</title></head>\\\n                    <body>\\\n                      <h1>501 Not Implemented</h1>\\\n                      <p>This server is not (yet) Apache.</p>\\\n                    </body>\\\n                  </html>\";\n      response.bodyOutputStream.write(body, body.length);\n    },\n    505: function(metadata, response)\n    {\n      response.setStatusLine(\"1.1\", 505, \"HTTP Version Not Supported\");\n      response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\", false);\n\n      var body = \"<html>\\\n                    <head><title>505 HTTP Version Not Supported</title></head>\\\n                    <body>\\\n                      <h1>505 HTTP Version Not Supported</h1>\\\n                      <p>This server only supports HTTP/1.0 and HTTP/1.1\\\n                        connections.</p>\\\n                    </body>\\\n                  </html>\";\n      response.bodyOutputStream.write(body, body.length);\n    }\n  },\n\n  /**\n   * Contains handlers for the default set of URIs contained in this server.\n   */\n  _defaultPaths:\n  {\n    \"/\": function(metadata, response)\n    {\n      response.setStatusLine(metadata.httpVersion, 200, \"OK\");\n      response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\", false);\n\n      var body = \"<html>\\\n                    <head><title>httpd.js</title></head>\\\n                    <body>\\\n                      <h1>httpd.js</h1>\\\n                      <p>If you're seeing this page, httpd.js is up and\\\n                        serving requests!  Now set a base path and serve some\\\n                        files!</p>\\\n                    </body>\\\n                  </html>\";\n\n      response.bodyOutputStream.write(body, body.length);\n    },\n\n    \"/trace\": function(metadata, response)\n    {\n      response.setStatusLine(metadata.httpVersion, 200, \"OK\");\n      response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\", false);\n\n      var body = \"Request-URI: \" +\n                 metadata.scheme + \"://\" + metadata.host + \":\" + metadata.port +\n                 metadata.path + \"\\n\\n\";\n      body += \"Request (semantically equivalent, slightly reformatted):\\n\\n\";\n      body += metadata.method + \" \" + metadata.path;\n\n      if (metadata.queryString)\n        body +=  \"?\" + metadata.queryString;\n        \n      body += \" HTTP/\" + metadata.httpVersion + \"\\r\\n\";\n\n      var headEnum = metadata.headers;\n      while (headEnum.hasMoreElements())\n      {\n        var fieldName = headEnum.getNext()\n                                .QueryInterface(Ci.nsISupportsString)\n                                .data;\n        body += fieldName + \": \" + metadata.getHeader(fieldName) + \"\\r\\n\";\n      }\n\n      response.bodyOutputStream.write(body, body.length);\n    }\n  }\n};\n\n\n/**\n * Maps absolute paths to files on the local file system (as nsILocalFiles).\n */\nfunction FileMap()\n{\n  /** Hash which will map paths to nsILocalFiles. */\n  this._map = {};\n}\nFileMap.prototype =\n{\n  // PUBLIC API\n\n  /**\n   * Maps key to a clone of the nsILocalFile value if value is non-null;\n   * otherwise, removes any extant mapping for key.\n   *\n   * @param key : string\n   *   string to which a clone of value is mapped\n   * @param value : nsILocalFile\n   *   the file to map to key, or null to remove a mapping\n   */\n  put: function(key, value)\n  {\n    if (value)\n      this._map[key] = value.clone();\n    else\n      delete this._map[key];\n  },\n\n  /**\n   * Returns a clone of the nsILocalFile mapped to key, or null if no such\n   * mapping exists.\n   *\n   * @param key : string\n   *   key to which the returned file maps\n   * @returns nsILocalFile\n   *   a clone of the mapped file, or null if no mapping exists\n   */\n  get: function(key)\n  {\n    var val = this._map[key];\n    return val ? val.clone() : null;\n  }\n};\n\n\n// Response CONSTANTS\n\n// token       = *<any CHAR except CTLs or separators>\n// CHAR        = <any US-ASCII character (0-127)>\n// CTL         = <any US-ASCII control character (0-31) and DEL (127)>\n// separators  = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n//             | \",\" | \";\" | \":\" | \"\\\" | <\">\n//             | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n//             | \"{\" | \"}\" | SP  | HT\nconst IS_TOKEN_ARRAY =\n  [0, 0, 0, 0, 0, 0, 0, 0, //   0\n   0, 0, 0, 0, 0, 0, 0, 0, //   8\n   0, 0, 0, 0, 0, 0, 0, 0, //  16\n   0, 0, 0, 0, 0, 0, 0, 0, //  24\n\n   0, 1, 0, 1, 1, 1, 1, 1, //  32\n   0, 0, 1, 1, 0, 1, 1, 0, //  40\n   1, 1, 1, 1, 1, 1, 1, 1, //  48\n   1, 1, 0, 0, 0, 0, 0, 0, //  56\n\n   0, 1, 1, 1, 1, 1, 1, 1, //  64\n   1, 1, 1, 1, 1, 1, 1, 1, //  72\n   1, 1, 1, 1, 1, 1, 1, 1, //  80\n   1, 1, 1, 0, 0, 0, 1, 1, //  88\n\n   1, 1, 1, 1, 1, 1, 1, 1, //  96\n   1, 1, 1, 1, 1, 1, 1, 1, // 104\n   1, 1, 1, 1, 1, 1, 1, 1, // 112\n   1, 1, 1, 0, 1, 0, 1];   // 120\n\n\n/**\n * Determines whether the given character code is a CTL.\n *\n * @param code : uint\n *   the character code\n * @returns boolean\n *   true if code is a CTL, false otherwise\n */\nfunction isCTL(code)\n{\n  return (code >= 0 && code <= 31) || (code == 127);\n}\n\n/**\n * Represents a response to an HTTP request, encapsulating all details of that\n * response.  This includes all headers, the HTTP version, status code and\n * explanation, and the entity itself.\n *\n * @param connection : Connection\n *   the connection over which this response is to be written\n */\nfunction Response(connection)\n{\n  /** The connection over which this response will be written. */\n  this._connection = connection;\n\n  /**\n   * The HTTP version of this response; defaults to 1.1 if not set by the\n   * handler.\n   */\n  this._httpVersion = nsHttpVersion.HTTP_1_1;\n\n  /**\n   * The HTTP code of this response; defaults to 200.\n   */\n  this._httpCode = 200;\n\n  /**\n   * The description of the HTTP code in this response; defaults to \"OK\".\n   */\n  this._httpDescription = \"OK\";\n\n  /**\n   * An nsIHttpHeaders object in which the headers in this response should be\n   * stored.  This property is null after the status line and headers have been\n   * written to the network, and it may be modified up until it is cleared,\n   * except if this._finished is set first (in which case headers are written\n   * asynchronously in response to a finish() call not preceded by\n   * flushHeaders()).\n   */\n  this._headers = new nsHttpHeaders();\n\n  /**\n   * Set to true when this response is ended (completely constructed if possible\n   * and the connection closed); further actions on this will then fail.\n   */\n  this._ended = false;\n\n  /**\n   * A stream used to hold data written to the body of this response.\n   */\n  this._bodyOutputStream = null;\n\n  /**\n   * A stream containing all data that has been written to the body of this\n   * response so far.  (Async handlers make the data contained in this\n   * unreliable as a way of determining content length in general, but auxiliary\n   * saved information can sometimes be used to guarantee reliability.)\n   */\n  this._bodyInputStream = null;\n\n  /**\n   * A stream copier which copies data to the network.  It is initially null\n   * until replaced with a copier for response headers; when headers have been\n   * fully sent it is replaced with a copier for the response body, remaining\n   * so for the duration of response processing.\n   */\n  this._asyncCopier = null;\n\n  /**\n   * True if this response has been designated as being processed\n   * asynchronously rather than for the duration of a single call to\n   * nsIHttpRequestHandler.handle.\n   */\n  this._processAsync = false;\n\n  /**\n   * True iff finish() has been called on this, signaling that no more changes\n   * to this may be made.\n   */\n  this._finished = false;\n\n  /**\n   * True iff powerSeized() has been called on this, signaling that this\n   * response is to be handled manually by the response handler (which may then\n   * send arbitrary data in response, even non-HTTP responses).\n   */\n  this._powerSeized = false;\n}\nResponse.prototype =\n{\n  // PUBLIC CONSTRUCTION API\n\n  //\n  // see nsIHttpResponse.bodyOutputStream\n  //\n  get bodyOutputStream()\n  {\n    if (this._finished)\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n\n    if (!this._bodyOutputStream)\n    {\n      var pipe = new Pipe(true, false, Response.SEGMENT_SIZE, PR_UINT32_MAX,\n                          null);\n      this._bodyOutputStream = pipe.outputStream;\n      this._bodyInputStream = pipe.inputStream;\n      if (this._processAsync || this._powerSeized)\n        this._startAsyncProcessor();\n    }\n\n    return this._bodyOutputStream;\n  },\n\n  //\n  // see nsIHttpResponse.write\n  //\n  write: function(data)\n  {\n    if (this._finished)\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n\n    var dataAsString = String(data);\n    this.bodyOutputStream.write(dataAsString, dataAsString.length);\n  },\n\n  //\n  // see nsIHttpResponse.setStatusLine\n  //\n  setStatusLine: function(httpVersion, code, description)\n  {\n    if (!this._headers || this._finished || this._powerSeized)\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n    this._ensureAlive();\n\n    if (!(code >= 0 && code < 1000))\n      throw Cr.NS_ERROR_INVALID_ARG;\n\n    try\n    {\n      var httpVer;\n      // avoid version construction for the most common cases\n      if (!httpVersion || httpVersion == \"1.1\")\n        httpVer = nsHttpVersion.HTTP_1_1;\n      else if (httpVersion == \"1.0\")\n        httpVer = nsHttpVersion.HTTP_1_0;\n      else\n        httpVer = new nsHttpVersion(httpVersion);\n    }\n    catch (e)\n    {\n      throw Cr.NS_ERROR_INVALID_ARG;\n    }\n\n    // Reason-Phrase = *<TEXT, excluding CR, LF>\n    // TEXT          = <any OCTET except CTLs, but including LWS>\n    //\n    // XXX this ends up disallowing octets which aren't Unicode, I think -- not\n    //     much to do if description is IDL'd as string\n    if (!description)\n      description = \"\";\n    for (var i = 0; i < description.length; i++)\n      if (isCTL(description.charCodeAt(i)) && description.charAt(i) != \"\\t\")\n        throw Cr.NS_ERROR_INVALID_ARG;\n\n    // set the values only after validation to preserve atomicity\n    this._httpDescription = description;\n    this._httpCode = code;\n    this._httpVersion = httpVer;\n  },\n\n  //\n  // see nsIHttpResponse.setHeader\n  //\n  setHeader: function(name, value, merge)\n  {\n    if (!this._headers || this._finished || this._powerSeized)\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n    this._ensureAlive();\n\n    this._headers.setHeader(name, value, merge);\n  },\n\n  //\n  // see nsIHttpResponse.processAsync\n  //\n  processAsync: function()\n  {\n    if (this._finished)\n      throw Cr.NS_ERROR_UNEXPECTED;\n    if (this._powerSeized)\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n    if (this._processAsync)\n      return;\n    this._ensureAlive();\n\n    dumpn(\"*** processing connection \" + this._connection.number + \" async\");\n    this._processAsync = true;\n\n    /*\n     * Either the bodyOutputStream getter or this method is responsible for\n     * starting the asynchronous processor and catching writes of data to the\n     * response body of async responses as they happen, for the purpose of\n     * forwarding those writes to the actual connection's output stream.\n     * If bodyOutputStream is accessed first, calling this method will create\n     * the processor (when it first is clear that body data is to be written\n     * immediately, not buffered).  If this method is called first, accessing\n     * bodyOutputStream will create the processor.  If only this method is\n     * called, we'll write nothing, neither headers nor the nonexistent body,\n     * until finish() is called.  Since that delay is easily avoided by simply\n     * getting bodyOutputStream or calling write(\"\"), we don't worry about it.\n     */\n    if (this._bodyOutputStream && !this._asyncCopier)\n      this._startAsyncProcessor();\n  },\n\n  //\n  // see nsIHttpResponse.seizePower\n  //\n  seizePower: function()\n  {\n    if (this._processAsync)\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n    if (this._finished)\n      throw Cr.NS_ERROR_UNEXPECTED;\n    if (this._powerSeized)\n      return;\n    this._ensureAlive();\n\n    dumpn(\"*** forcefully seizing power over connection \" +\n          this._connection.number + \"...\");\n\n    // Purge any already-written data without sending it.  We could as easily\n    // swap out the streams entirely, but that makes it possible to acquire and\n    // unknowingly use a stale reference, so we require there only be one of\n    // each stream ever for any response to avoid this complication.\n    if (this._asyncCopier)\n      this._asyncCopier.cancel(Cr.NS_BINDING_ABORTED);\n    this._asyncCopier = null;\n    if (this._bodyOutputStream)\n    {\n      var input = new BinaryInputStream(this._bodyInputStream);\n      var avail;\n      while ((avail = input.available()) > 0)\n        input.readByteArray(avail);\n    }\n\n    this._powerSeized = true;\n    if (this._bodyOutputStream)\n      this._startAsyncProcessor();\n  },\n\n  //\n  // see nsIHttpResponse.finish\n  //\n  finish: function()\n  {\n    if (!this._processAsync && !this._powerSeized)\n      throw Cr.NS_ERROR_UNEXPECTED;\n    if (this._finished)\n      return;\n\n    dumpn(\"*** finishing connection \" + this._connection.number);\n    this._startAsyncProcessor(); // in case bodyOutputStream was never accessed\n    if (this._bodyOutputStream)\n      this._bodyOutputStream.close();\n    this._finished = true;\n  },\n\n\n  // NSISUPPORTS\n\n  //\n  // see nsISupports.QueryInterface\n  //\n  QueryInterface: function(iid)\n  {\n    if (iid.equals(Ci.nsIHttpResponse) || iid.equals(Ci.nsISupports))\n      return this;\n\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  },\n\n\n  // POST-CONSTRUCTION API (not exposed externally)\n\n  /**\n   * The HTTP version number of this, as a string (e.g. \"1.1\").\n   */\n  get httpVersion()\n  {\n    this._ensureAlive();\n    return this._httpVersion.toString();\n  },\n\n  /**\n   * The HTTP status code of this response, as a string of three characters per\n   * RFC 2616.\n   */\n  get httpCode()\n  {\n    this._ensureAlive();\n\n    var codeString = (this._httpCode < 10 ? \"0\" : \"\") +\n                     (this._httpCode < 100 ? \"0\" : \"\") +\n                     this._httpCode;\n    return codeString;\n  },\n\n  /**\n   * The description of the HTTP status code of this response, or \"\" if none is\n   * set.\n   */\n  get httpDescription()\n  {\n    this._ensureAlive();\n\n    return this._httpDescription;\n  },\n\n  /**\n   * The headers in this response, as an nsHttpHeaders object.\n   */\n  get headers()\n  {\n    this._ensureAlive();\n\n    return this._headers;\n  },\n\n  //\n  // see nsHttpHeaders.getHeader\n  //\n  getHeader: function(name)\n  {\n    this._ensureAlive();\n\n    return this._headers.getHeader(name);\n  },\n\n  /**\n   * Determines whether this response may be abandoned in favor of a newly\n   * constructed response.  A response may be abandoned only if it is not being\n   * sent asynchronously and if raw control over it has not been taken from the\n   * server.\n   *\n   * @returns boolean\n   *   true iff no data has been written to the network\n   */\n  partiallySent: function()\n  {\n    dumpn(\"*** partiallySent()\");\n    return this._processAsync || this._powerSeized;\n  },\n\n  /**\n   * If necessary, kicks off the remaining request processing needed to be done\n   * after a request handler performs its initial work upon this response.\n   */\n  complete: function()\n  {\n    dumpn(\"*** complete()\");\n    if (this._processAsync || this._powerSeized)\n    {\n      NS_ASSERT(this._processAsync ^ this._powerSeized,\n                \"can't both send async and relinquish power\");\n      return;\n    }\n\n    NS_ASSERT(!this.partiallySent(), \"completing a partially-sent response?\");\n\n    this._startAsyncProcessor();\n\n    // Now make sure we finish processing this request!\n    if (this._bodyOutputStream)\n      this._bodyOutputStream.close();\n  },\n\n  /**\n   * Abruptly ends processing of this response, usually due to an error in an\n   * incoming request but potentially due to a bad error handler.  Since we\n   * cannot handle the error in the usual way (giving an HTTP error page in\n   * response) because data may already have been sent (or because the response\n   * might be expected to have been generated asynchronously or completely from\n   * scratch by the handler), we stop processing this response and abruptly\n   * close the connection.\n   *\n   * @param e : Error\n   *   the exception which precipitated this abort, or null if no such exception\n   *   was generated\n   */\n  abort: function(e)\n  {\n    dumpn(\"*** abort(<\" + e + \">)\");\n\n    // This response will be ended by the processor if one was created.\n    var copier = this._asyncCopier;\n    if (copier)\n    {\n      // We dispatch asynchronously here so that any pending writes of data to\n      // the connection will be deterministically written.  This makes it easier\n      // to specify exact behavior, and it makes observable behavior more\n      // predictable for clients.  Note that the correctness of this depends on\n      // callbacks in response to _waitToReadData in WriteThroughCopier\n      // happening asynchronously with respect to the actual writing of data to\n      // bodyOutputStream, as they currently do; if they happened synchronously,\n      // an event which ran before this one could write more data to the\n      // response body before we get around to canceling the copier.  We have\n      // tests for this in test_seizepower.js, however, and I can't think of a\n      // way to handle both cases without removing bodyOutputStream access and\n      // moving its effective write(data, length) method onto Response, which\n      // would be slower and require more code than this anyway.\n      gThreadManager.currentThread.dispatch({\n        run: function()\n        {\n          dumpn(\"*** canceling copy asynchronously...\");\n          copier.cancel(Cr.NS_ERROR_UNEXPECTED);\n        }\n      }, Ci.nsIThread.DISPATCH_NORMAL);\n    }\n    else\n    {\n      this.end();\n    }\n  },\n\n  /**\n   * Closes this response's network connection, marks the response as finished,\n   * and notifies the server handler that the request is done being processed.\n   */\n  end: function()\n  {\n    NS_ASSERT(!this._ended, \"ending this response twice?!?!\");\n\n    this._connection.close();\n    if (this._bodyOutputStream)\n      this._bodyOutputStream.close();\n\n    this._finished = true;\n    this._ended = true;\n  },\n\n  // PRIVATE IMPLEMENTATION\n\n  /**\n   * Sends the status line and headers of this response if they haven't been\n   * sent and initiates the process of copying data written to this response's\n   * body to the network.\n   */\n  _startAsyncProcessor: function()\n  {\n    dumpn(\"*** _startAsyncProcessor()\");\n\n    // Handle cases where we're being called a second time.  The former case\n    // happens when this is triggered both by complete() and by processAsync(),\n    // while the latter happens when processAsync() in conjunction with sent\n    // data causes abort() to be called.\n    if (this._asyncCopier || this._ended)\n    {\n      dumpn(\"*** ignoring second call to _startAsyncProcessor\");\n      return;\n    }\n\n    // Send headers if they haven't been sent already and should be sent, then\n    // asynchronously continue to send the body.\n    if (this._headers && !this._powerSeized)\n    {\n      this._sendHeaders();\n      return;\n    }\n\n    this._headers = null;\n    this._sendBody();\n  },\n\n  /**\n   * Signals that all modifications to the response status line and headers are\n   * complete and then sends that data over the network to the client.  Once\n   * this method completes, a different response to the request that resulted\n   * in this response cannot be sent -- the only possible action in case of\n   * error is to abort the response and close the connection.\n   */\n  _sendHeaders: function()\n  {\n    dumpn(\"*** _sendHeaders()\");\n\n    NS_ASSERT(this._headers);\n    NS_ASSERT(!this._powerSeized);\n\n    // request-line\n    var statusLine = \"HTTP/\" + this.httpVersion + \" \" +\n                     this.httpCode + \" \" +\n                     this.httpDescription + \"\\r\\n\";\n\n    // header post-processing\n\n    var headers = this._headers;\n    headers.setHeader(\"Connection\", \"close\", false);\n    headers.setHeader(\"Server\", \"httpd.js\", false);\n    if (!headers.hasHeader(\"Date\"))\n      headers.setHeader(\"Date\", toDateString(Date.now()), false);\n\n    // Any response not being processed asynchronously must have an associated\n    // Content-Length header for reasons of backwards compatibility with the\n    // initial server, which fully buffered every response before sending it.\n    // Beyond that, however, it's good to do this anyway because otherwise it's\n    // impossible to test behaviors that depend on the presence or absence of a\n    // Content-Length header.\n    if (!this._processAsync)\n    {\n      dumpn(\"*** non-async response, set Content-Length\");\n\n      var bodyStream = this._bodyInputStream;\n      var avail = bodyStream ? bodyStream.available() : 0;\n\n      // XXX assumes stream will always report the full amount of data available\n      headers.setHeader(\"Content-Length\", \"\" + avail, false);\n    }\n\n\n    // construct and send response\n    dumpn(\"*** header post-processing completed, sending response head...\");\n\n    // request-line\n    var preambleData = [statusLine];\n\n    // headers\n    var headEnum = headers.enumerator;\n    while (headEnum.hasMoreElements())\n    {\n      var fieldName = headEnum.getNext()\n                              .QueryInterface(Ci.nsISupportsString)\n                              .data;\n      var values = headers.getHeaderValues(fieldName);\n      for (var i = 0, sz = values.length; i < sz; i++)\n        preambleData.push(fieldName + \": \" + values[i] + \"\\r\\n\");\n    }\n\n    // end request-line/headers\n    preambleData.push(\"\\r\\n\");\n\n    var preamble = preambleData.join(\"\");\n\n    var responseHeadPipe = new Pipe(true, false, 0, PR_UINT32_MAX, null);\n    responseHeadPipe.outputStream.write(preamble, preamble.length);\n\n    var response = this;\n    var copyObserver =\n      {\n        onStartRequest: function(request, cx)\n        {\n          dumpn(\"*** preamble copying started\");\n        },\n\n        onStopRequest: function(request, cx, statusCode)\n        {\n          dumpn(\"*** preamble copying complete \" +\n                \"[status=0x\" + statusCode.toString(16) + \"]\");\n\n          if (!Components.isSuccessCode(statusCode))\n          {\n            dumpn(\"!!! header copying problems: non-success statusCode, \" +\n                  \"ending response\");\n\n            response.end();\n          }\n          else\n          {\n            response._sendBody();\n          }\n        },\n\n        QueryInterface: function(aIID)\n        {\n          if (aIID.equals(Ci.nsIRequestObserver) || aIID.equals(Ci.nsISupports))\n            return this;\n\n          throw Cr.NS_ERROR_NO_INTERFACE;\n        }\n      };\n\n    var headerCopier = this._asyncCopier =\n      new WriteThroughCopier(responseHeadPipe.inputStream,\n                             this._connection.output,\n                             copyObserver, null);\n\n    responseHeadPipe.outputStream.close();\n\n    // Forbid setting any more headers or modifying the request line.\n    this._headers = null;\n  },\n\n  /**\n   * Asynchronously writes the body of the response (or the entire response, if\n   * seizePower() has been called) to the network.\n   */\n  _sendBody: function()\n  {\n    dumpn(\"*** _sendBody\");\n\n    NS_ASSERT(!this._headers, \"still have headers around but sending body?\");\n\n    // If no body data was written, we're done\n    if (!this._bodyInputStream)\n    {\n      dumpn(\"*** empty body, response finished\");\n      this.end();\n      return;\n    }\n\n    var response = this;\n    var copyObserver =\n      {\n        onStartRequest: function(request, context)\n        {\n          dumpn(\"*** onStartRequest\");\n        },\n\n        onStopRequest: function(request, cx, statusCode)\n        {\n          dumpn(\"*** onStopRequest [status=0x\" + statusCode.toString(16) + \"]\");\n\n          if (statusCode === Cr.NS_BINDING_ABORTED)\n          {\n            dumpn(\"*** terminating copy observer without ending the response\");\n          }\n          else\n          {\n            if (!Components.isSuccessCode(statusCode))\n              dumpn(\"*** WARNING: non-success statusCode in onStopRequest\");\n\n            response.end();\n          }\n        },\n\n        QueryInterface: function(aIID)\n        {\n          if (aIID.equals(Ci.nsIRequestObserver) || aIID.equals(Ci.nsISupports))\n            return this;\n\n          throw Cr.NS_ERROR_NO_INTERFACE;\n        }\n      };\n\n    dumpn(\"*** starting async copier of body data...\");\n    this._asyncCopier =\n      new WriteThroughCopier(this._bodyInputStream, this._connection.output,\n                            copyObserver, null);\n  },\n\n  /** Ensures that this hasn't been ended. */\n  _ensureAlive: function()\n  {\n    NS_ASSERT(!this._ended, \"not handling response lifetime correctly\");\n  }\n};\n\n/**\n * Size of the segments in the buffer used in storing response data and writing\n * it to the socket.\n */\nResponse.SEGMENT_SIZE = 8192;\n\n/** Serves double duty in WriteThroughCopier implementation. */\nfunction notImplemented()\n{\n  throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n}\n\n/** Returns true iff the given exception represents stream closure. */\nfunction streamClosed(e)\n{\n  return e === Cr.NS_BASE_STREAM_CLOSED ||\n         (typeof e === \"object\" && e.result === Cr.NS_BASE_STREAM_CLOSED);\n}\n\n/** Returns true iff the given exception represents a blocked stream. */\nfunction wouldBlock(e)\n{\n  return e === Cr.NS_BASE_STREAM_WOULD_BLOCK ||\n         (typeof e === \"object\" && e.result === Cr.NS_BASE_STREAM_WOULD_BLOCK);\n}\n\n/**\n * Copies data from source to sink as it becomes available, when that data can\n * be written to sink without blocking.\n *\n * @param source : nsIAsyncInputStream\n *   the stream from which data is to be read\n * @param sink : nsIAsyncOutputStream\n *   the stream to which data is to be copied\n * @param observer : nsIRequestObserver\n *   an observer which will be notified when the copy starts and finishes\n * @param context : nsISupports\n *   context passed to observer when notified of start/stop\n * @throws NS_ERROR_NULL_POINTER\n *   if source, sink, or observer are null\n */\nfunction WriteThroughCopier(source, sink, observer, context)\n{\n  if (!source || !sink || !observer)\n    throw Cr.NS_ERROR_NULL_POINTER;\n\n  /** Stream from which data is being read. */\n  this._source = source;\n\n  /** Stream to which data is being written. */\n  this._sink = sink;\n\n  /** Observer watching this copy. */\n  this._observer = observer;\n\n  /** Context for the observer watching this. */\n  this._context = context;\n\n  /**\n   * True iff this is currently being canceled (cancel has been called, the\n   * callback may not yet have been made).\n   */\n  this._canceled = false;\n\n  /**\n   * False until all data has been read from input and written to output, at\n   * which point this copy is completed and cancel() is asynchronously called.\n   */\n  this._completed = false;\n\n  /** Required by nsIRequest, meaningless. */\n  this.loadFlags = 0;\n  /** Required by nsIRequest, meaningless. */\n  this.loadGroup = null;\n  /** Required by nsIRequest, meaningless. */\n  this.name = \"response-body-copy\";\n\n  /** Status of this request. */\n  this.status = Cr.NS_OK;\n\n  /** Arrays of byte strings waiting to be written to output. */\n  this._pendingData = [];\n\n  // start copying\n  try\n  {\n    observer.onStartRequest(this, context);\n    this._waitToReadData();\n    this._waitForSinkClosure();\n  }\n  catch (e)\n  {\n    dumpn(\"!!! error starting copy: \" + e +\n          (\"lineNumber\" in e ? \", line \" + e.lineNumber : \"\"));\n    dumpn(e.stack);\n    this.cancel(Cr.NS_ERROR_UNEXPECTED);\n  }\n}\nWriteThroughCopier.prototype =\n{\n  /* nsISupports implementation */\n\n  QueryInterface: function(iid)\n  {\n    if (iid.equals(Ci.nsIInputStreamCallback) ||\n        iid.equals(Ci.nsIOutputStreamCallback) ||\n        iid.equals(Ci.nsIRequest) ||\n        iid.equals(Ci.nsISupports))\n    {\n      return this;\n    }\n\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  },\n\n\n  // NSIINPUTSTREAMCALLBACK\n\n  /**\n   * Receives a more-data-in-input notification and writes the corresponding\n   * data to the output.\n   *\n   * @param input : nsIAsyncInputStream\n   *   the input stream on whose data we have been waiting\n   */\n  onInputStreamReady: function(input)\n  {\n    if (this._source === null)\n      return;\n\n    dumpn(\"*** onInputStreamReady\");\n\n    //\n    // Ordinarily we'll read a non-zero amount of data from input, queue it up\n    // to be written and then wait for further callbacks.  The complications in\n    // this method are the cases where we deviate from that behavior when errors\n    // occur or when copying is drawing to a finish.\n    //\n    // The edge cases when reading data are:\n    //\n    //   Zero data is read\n    //     If zero data was read, we're at the end of available data, so we can\n    //     should stop reading and move on to writing out what we have (or, if\n    //     we've already done that, onto notifying of completion).\n    //   A stream-closed exception is thrown\n    //     This is effectively a less kind version of zero data being read; the\n    //     only difference is that we notify of completion with that result\n    //     rather than with NS_OK.\n    //   Some other exception is thrown\n    //     This is the least kind result.  We don't know what happened, so we\n    //     act as though the stream closed except that we notify of completion\n    //     with the result NS_ERROR_UNEXPECTED.\n    //\n\n    var bytesWanted = 0, bytesConsumed = -1;\n    try\n    {\n      input = new BinaryInputStream(input);\n\n      bytesWanted = Math.min(input.available(), Response.SEGMENT_SIZE);\n      dumpn(\"*** input wanted: \" + bytesWanted);\n\n      if (bytesWanted > 0)\n      {\n        var data = input.readByteArray(bytesWanted);\n        bytesConsumed = data.length;\n        this._pendingData.push(String.fromCharCode.apply(String, data));\n      }\n\n      dumpn(\"*** \" + bytesConsumed + \" bytes read\");\n\n      // Handle the zero-data edge case in the same place as all other edge\n      // cases are handled.\n      if (bytesWanted === 0)\n        throw Cr.NS_BASE_STREAM_CLOSED;\n    }\n    catch (e)\n    {\n      if (streamClosed(e))\n      {\n        dumpn(\"*** input stream closed\");\n        e = bytesWanted === 0 ? Cr.NS_OK : Cr.NS_ERROR_UNEXPECTED;\n      }\n      else\n      {\n        dumpn(\"!!! unexpected error reading from input, canceling: \" + e);\n        e = Cr.NS_ERROR_UNEXPECTED;\n      }\n\n      this._doneReadingSource(e);\n      return;\n    }\n\n    var pendingData = this._pendingData;\n\n    NS_ASSERT(bytesConsumed > 0);\n    NS_ASSERT(pendingData.length > 0, \"no pending data somehow?\");\n    NS_ASSERT(pendingData[pendingData.length - 1].length > 0,\n              \"buffered zero bytes of data?\");\n\n    NS_ASSERT(this._source !== null);\n\n    // Reading has gone great, and we've gotten data to write now.  What if we\n    // don't have a place to write that data, because output went away just\n    // before this read?  Drop everything on the floor, including new data, and\n    // cancel at this point.\n    if (this._sink === null)\n    {\n      pendingData.length = 0;\n      this._doneReadingSource(Cr.NS_ERROR_UNEXPECTED);\n      return;\n    }\n\n    // Okay, we've read the data, and we know we have a place to write it.  We\n    // need to queue up the data to be written, but *only* if none is queued\n    // already -- if data's already queued, the code that actually writes the\n    // data will make sure to wait on unconsumed pending data.\n    try\n    {\n      if (pendingData.length === 1)\n        this._waitToWriteData();\n    }\n    catch (e)\n    {\n      dumpn(\"!!! error waiting to write data just read, swallowing and \" +\n            \"writing only what we already have: \" + e);\n      this._doneWritingToSink(Cr.NS_ERROR_UNEXPECTED);\n      return;\n    }\n\n    // Whee!  We successfully read some data, and it's successfully queued up to\n    // be written.  All that remains now is to wait for more data to read.\n    try\n    {\n      this._waitToReadData();\n    }\n    catch (e)\n    {\n      dumpn(\"!!! error waiting to read more data: \" + e);\n      this._doneReadingSource(Cr.NS_ERROR_UNEXPECTED);\n    }\n  },\n\n\n  // NSIOUTPUTSTREAMCALLBACK\n\n  /**\n   * Callback when data may be written to the output stream without blocking, or\n   * when the output stream has been closed.\n   *\n   * @param output : nsIAsyncOutputStream\n   *   the output stream on whose writability we've been waiting, also known as\n   *   this._sink\n   */\n  onOutputStreamReady: function(output)\n  {\n    if (this._sink === null)\n      return;\n\n    dumpn(\"*** onOutputStreamReady\");\n\n    var pendingData = this._pendingData;\n    if (pendingData.length === 0)\n    {\n      // There's no pending data to write.  The only way this can happen is if\n      // we're waiting on the output stream's closure, so we can respond to a\n      // copying failure as quickly as possible (rather than waiting for data to\n      // be available to read and then fail to be copied).  Therefore, we must\n      // be done now -- don't bother to attempt to write anything and wrap\n      // things up.\n      dumpn(\"!!! output stream closed prematurely, ending copy\");\n\n      this._doneWritingToSink(Cr.NS_ERROR_UNEXPECTED);\n      return;\n    }\n\n\n    NS_ASSERT(pendingData[0].length > 0, \"queued up an empty quantum?\");\n\n    //\n    // Write out the first pending quantum of data.  The possible errors here\n    // are:\n    //\n    //   The write might fail because we can't write that much data\n    //     Okay, we've written what we can now, so re-queue what's left and\n    //     finish writing it out later.\n    //   The write failed because the stream was closed\n    //     Discard pending data that we can no longer write, stop reading, and\n    //     signal that copying finished.\n    //   Some other error occurred.\n    //     Same as if the stream were closed, but notify with the status\n    //     NS_ERROR_UNEXPECTED so the observer knows something was wonky.\n    //\n\n    try\n    {\n      var quantum = pendingData[0];\n\n      // XXX |quantum| isn't guaranteed to be ASCII, so we're relying on\n      //     undefined behavior!  We're only using this because writeByteArray\n      //     is unusably broken for asynchronous output streams; see bug 532834\n      //     for details.\n      var bytesWritten = output.write(quantum, quantum.length);\n      if (bytesWritten === quantum.length)\n        pendingData.shift();\n      else\n        pendingData[0] = quantum.substring(bytesWritten);\n\n      dumpn(\"*** wrote \" + bytesWritten + \" bytes of data\");\n    }\n    catch (e)\n    {\n      if (wouldBlock(e))\n      {\n        NS_ASSERT(pendingData.length > 0,\n                  \"stream-blocking exception with no data to write?\");\n        NS_ASSERT(pendingData[0].length > 0,\n                  \"stream-blocking exception with empty quantum?\");\n        this._waitToWriteData();\n        return;\n      }\n\n      if (streamClosed(e))\n        dumpn(\"!!! output stream prematurely closed, signaling error...\");\n      else\n        dumpn(\"!!! unknown error: \" + e + \", quantum=\" + quantum);\n\n      this._doneWritingToSink(Cr.NS_ERROR_UNEXPECTED);\n      return;\n    }\n\n    // The day is ours!  Quantum written, now let's see if we have more data\n    // still to write.\n    try\n    {\n      if (pendingData.length > 0)\n      {\n        this._waitToWriteData();\n        return;\n      }\n    }\n    catch (e)\n    {\n      dumpn(\"!!! unexpected error waiting to write pending data: \" + e);\n      this._doneWritingToSink(Cr.NS_ERROR_UNEXPECTED);\n      return;\n    }\n\n    // Okay, we have no more pending data to write -- but might we get more in\n    // the future?\n    if (this._source !== null)\n    {\n      /*\n       * If we might, then wait for the output stream to be closed.  (We wait\n       * only for closure because we have no data to write -- and if we waited\n       * for a specific amount of data, we would get repeatedly notified for no\n       * reason if over time the output stream permitted more and more data to\n       * be written to it without blocking.)\n       */\n       this._waitForSinkClosure();\n    }\n    else\n    {\n      /*\n       * On the other hand, if we can't have more data because the input\n       * stream's gone away, then it's time to notify of copy completion.\n       * Victory!\n       */\n      this._sink = null;\n      this._cancelOrDispatchCancelCallback(Cr.NS_OK);\n    }\n  },\n\n\n  // NSIREQUEST\n\n  /** Returns true if the cancel observer hasn't been notified yet. */\n  isPending: function()\n  {\n    return !this._completed;\n  },\n\n  /** Not implemented, don't use! */\n  suspend: notImplemented,\n  /** Not implemented, don't use! */\n  resume: notImplemented,\n\n  /**\n   * Cancels data reading from input, asynchronously writes out any pending\n   * data, and causes the observer to be notified with the given error code when\n   * all writing has finished.\n   *\n   * @param status : nsresult\n   *   the status to pass to the observer when data copying has been canceled\n   */\n  cancel: function(status)\n  {\n    dumpn(\"*** cancel(\" + status.toString(16) + \")\");\n\n    if (this._canceled)\n    {\n      dumpn(\"*** suppressing a late cancel\");\n      return;\n    }\n\n    this._canceled = true;\n    this.status = status;\n\n    // We could be in the middle of absolutely anything at this point.  Both\n    // input and output might still be around, we might have pending data to\n    // write, and in general we know nothing about the state of the world.  We\n    // therefore must assume everything's in progress and take everything to its\n    // final steady state (or so far as it can go before we need to finish\n    // writing out remaining data).\n\n    this._doneReadingSource(status);\n  },\n\n\n  // PRIVATE IMPLEMENTATION\n\n  /**\n   * Stop reading input if we haven't already done so, passing e as the status\n   * when closing the stream, and kick off a copy-completion notice if no more\n   * data remains to be written.\n   *\n   * @param e : nsresult\n   *   the status to be used when closing the input stream\n   */\n  _doneReadingSource: function(e)\n  {\n    dumpn(\"*** _doneReadingSource(0x\" + e.toString(16) + \")\");\n\n    this._finishSource(e);\n    if (this._pendingData.length === 0)\n      this._sink = null;\n    else\n      NS_ASSERT(this._sink !== null, \"null output?\");\n\n    // If we've written out all data read up to this point, then it's time to\n    // signal completion.\n    if (this._sink === null)\n    {\n      NS_ASSERT(this._pendingData.length === 0, \"pending data still?\");\n      this._cancelOrDispatchCancelCallback(e);\n    }\n  },\n\n  /**\n   * Stop writing output if we haven't already done so, discard any data that\n   * remained to be sent, close off input if it wasn't already closed, and kick\n   * off a copy-completion notice.\n   *\n   * @param e : nsresult\n   *   the status to be used when closing input if it wasn't already closed\n   */\n  _doneWritingToSink: function(e)\n  {\n    dumpn(\"*** _doneWritingToSink(0x\" + e.toString(16) + \")\");\n\n    this._pendingData.length = 0;\n    this._sink = null;\n    this._doneReadingSource(e);\n  },\n\n  /**\n   * Completes processing of this copy: either by canceling the copy if it\n   * hasn't already been canceled using the provided status, or by dispatching\n   * the cancel callback event (with the originally provided status, of course)\n   * if it already has been canceled.\n   *\n   * @param status : nsresult\n   *   the status code to use to cancel this, if this hasn't already been\n   *   canceled\n   */\n  _cancelOrDispatchCancelCallback: function(status)\n  {\n    dumpn(\"*** _cancelOrDispatchCancelCallback(\" + status + \")\");\n\n    NS_ASSERT(this._source === null, \"should have finished input\");\n    NS_ASSERT(this._sink === null, \"should have finished output\");\n    NS_ASSERT(this._pendingData.length === 0, \"should have no pending data\");\n\n    if (!this._canceled)\n    {\n      this.cancel(status);\n      return;\n    }\n\n    var self = this;\n    var event =\n      {\n        run: function()\n        {\n          dumpn(\"*** onStopRequest async callback\");\n\n          self._completed = true;\n          try\n          {\n            self._observer.onStopRequest(self, self._context, self.status);\n          }\n          catch (e)\n          {\n            NS_ASSERT(false,\n                      \"how are we throwing an exception here?  we control \" +\n                      \"all the callers!  \" + e);\n          }\n        }\n      };\n\n    gThreadManager.currentThread.dispatch(event, Ci.nsIThread.DISPATCH_NORMAL);\n  },\n\n  /**\n   * Kicks off another wait for more data to be available from the input stream.\n   */\n  _waitToReadData: function()\n  {\n    dumpn(\"*** _waitToReadData\");\n    this._source.asyncWait(this, 0, Response.SEGMENT_SIZE,\n                           gThreadManager.mainThread);\n  },\n\n  /**\n   * Kicks off another wait until data can be written to the output stream.\n   */\n  _waitToWriteData: function()\n  {\n    dumpn(\"*** _waitToWriteData\");\n\n    var pendingData = this._pendingData;\n    NS_ASSERT(pendingData.length > 0, \"no pending data to write?\");\n    NS_ASSERT(pendingData[0].length > 0, \"buffered an empty write?\");\n\n    this._sink.asyncWait(this, 0, pendingData[0].length,\n                         gThreadManager.mainThread);\n  },\n\n  /**\n   * Kicks off a wait for the sink to which data is being copied to be closed.\n   * We wait for stream closure when we don't have any data to be copied, rather\n   * than waiting to write a specific amount of data.  We can't wait to write\n   * data because the sink might be infinitely writable, and if no data appears\n   * in the source for a long time we might have to spin quite a bit waiting to\n   * write, waiting to write again, &c.  Waiting on stream closure instead means\n   * we'll get just one notification if the sink dies.  Note that when data\n   * starts arriving from the sink we'll resume waiting for data to be written,\n   * dropping this closure-only callback entirely.\n   */\n  _waitForSinkClosure: function()\n  {\n    dumpn(\"*** _waitForSinkClosure\");\n\n    this._sink.asyncWait(this, Ci.nsIAsyncOutputStream.WAIT_CLOSURE_ONLY, 0,\n                         gThreadManager.mainThread);\n  },\n\n  /**\n   * Closes input with the given status, if it hasn't already been closed;\n   * otherwise a no-op.\n   *\n   * @param status : nsresult\n   *   status code use to close the source stream if necessary\n   */\n  _finishSource: function(status)\n  {\n    dumpn(\"*** _finishSource(\" + status.toString(16) + \")\");\n\n    if (this._source !== null)\n    {\n      this._source.closeWithStatus(status);\n      this._source = null;\n    }\n  }\n};\n\n\n/**\n * A container for utility functions used with HTTP headers.\n */\nconst headerUtils =\n{\n  /**\n   * Normalizes fieldName (by converting it to lowercase) and ensures it is a\n   * valid header field name (although not necessarily one specified in RFC\n   * 2616).\n   *\n   * @throws NS_ERROR_INVALID_ARG\n   *   if fieldName does not match the field-name production in RFC 2616\n   * @returns string\n   *   fieldName converted to lowercase if it is a valid header, for characters\n   *   where case conversion is possible\n   */\n  normalizeFieldName: function(fieldName)\n  {\n    if (fieldName == \"\")\n    {\n      dumpn(\"*** Empty fieldName\");\n      throw Cr.NS_ERROR_INVALID_ARG;\n    }\n\n    for (var i = 0, sz = fieldName.length; i < sz; i++)\n    {\n      if (!IS_TOKEN_ARRAY[fieldName.charCodeAt(i)])\n      {\n        dumpn(fieldName + \" is not a valid header field name!\");\n        throw Cr.NS_ERROR_INVALID_ARG;\n      }\n    }\n\n    return fieldName //.toLowerCase();\n  },\n\n  /**\n   * Ensures that fieldValue is a valid header field value (although not\n   * necessarily as specified in RFC 2616 if the corresponding field name is\n   * part of the HTTP protocol), normalizes the value if it is, and\n   * returns the normalized value.\n   *\n   * @param fieldValue : string\n   *   a value to be normalized as an HTTP header field value\n   * @throws NS_ERROR_INVALID_ARG\n   *   if fieldValue does not match the field-value production in RFC 2616\n   * @returns string\n   *   fieldValue as a normalized HTTP header field value\n   */\n  normalizeFieldValue: function(fieldValue)\n  {\n    // field-value    = *( field-content | LWS )\n    // field-content  = <the OCTETs making up the field-value\n    //                  and consisting of either *TEXT or combinations\n    //                  of token, separators, and quoted-string>\n    // TEXT           = <any OCTET except CTLs,\n    //                  but including LWS>\n    // LWS            = [CRLF] 1*( SP | HT )\n    //\n    // quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n    // qdtext         = <any TEXT except <\">>\n    // quoted-pair    = \"\\\" CHAR\n    // CHAR           = <any US-ASCII character (octets 0 - 127)>\n\n    // Any LWS that occurs between field-content MAY be replaced with a single\n    // SP before interpreting the field value or forwarding the message\n    // downstream (section 4.2); we replace 1*LWS with a single SP\n    var val = fieldValue.replace(/(?:(?:\\r\\n)?[ \\t]+)+/g, \" \");\n\n    // remove leading/trailing LWS (which has been converted to SP)\n    val = val.replace(/^ +/, \"\").replace(/ +$/, \"\");\n\n    // that should have taken care of all CTLs, so val should contain no CTLs\n    dumpn(\"*** Normalized value: '\" + val + \"'\");\n    for (var i = 0, len = val.length; i < len; i++)\n      if (isCTL(val.charCodeAt(i)))\n      {\n        dump(\"*** Char \" + i + \" has charcode \" + val.charCodeAt(i));\n        throw Cr.NS_ERROR_INVALID_ARG;\n      }\n\n    // XXX disallows quoted-pair where CHAR is a CTL -- will not invalidly\n    //     normalize, however, so this can be construed as a tightening of the\n    //     spec and not entirely as a bug\n    return val;\n  }\n};\n\n\n\n/**\n * Converts the given string into a string which is safe for use in an HTML\n * context.\n *\n * @param str : string\n *   the string to make HTML-safe\n * @returns string\n *   an HTML-safe version of str\n */\nfunction htmlEscape(str)\n{\n  // this is naive, but it'll work\n  var s = \"\";\n  for (var i = 0; i < str.length; i++)\n    s += \"&#\" + str.charCodeAt(i) + \";\";\n  return s;\n}\n\n\n/**\n * Constructs an object representing an HTTP version (see section 3.1).\n *\n * @param versionString\n *   a string of the form \"#.#\", where # is an non-negative decimal integer with\n *   or without leading zeros\n * @throws\n *   if versionString does not specify a valid HTTP version number\n */\nfunction nsHttpVersion(versionString)\n{\n  var matches = /^(\\d+)\\.(\\d+)$/.exec(versionString);\n  if (!matches)\n    throw \"Not a valid HTTP version!\";\n\n  /** The major version number of this, as a number. */\n  this.major = parseInt(matches[1], 10);\n\n  /** The minor version number of this, as a number. */\n  this.minor = parseInt(matches[2], 10);\n\n  if (isNaN(this.major) || isNaN(this.minor) ||\n      this.major < 0    || this.minor < 0)\n    throw \"Not a valid HTTP version!\";\n}\nnsHttpVersion.prototype =\n{\n  /**\n   * Returns the standard string representation of the HTTP version represented\n   * by this (e.g., \"1.1\").\n   */\n  toString: function ()\n  {\n    return this.major + \".\" + this.minor;\n  },\n\n  /**\n   * Returns true if this represents the same HTTP version as otherVersion,\n   * false otherwise.\n   *\n   * @param otherVersion : nsHttpVersion\n   *   the version to compare against this\n   */\n  equals: function (otherVersion)\n  {\n    return this.major == otherVersion.major &&\n           this.minor == otherVersion.minor;\n  },\n\n  /** True if this >= otherVersion, false otherwise. */\n  atLeast: function(otherVersion)\n  {\n    return this.major > otherVersion.major ||\n           (this.major == otherVersion.major &&\n            this.minor >= otherVersion.minor);\n  }\n};\n\nnsHttpVersion.HTTP_1_0 = new nsHttpVersion(\"1.0\");\nnsHttpVersion.HTTP_1_1 = new nsHttpVersion(\"1.1\");\n\n\n/**\n * An object which stores HTTP headers for a request or response.\n *\n * Note that since headers are case-insensitive, this object converts headers to\n * lowercase before storing them.  This allows the getHeader and hasHeader\n * methods to work correctly for any case of a header, but it means that the\n * values returned by .enumerator may not be equal case-sensitively to the\n * values passed to setHeader when adding headers to this.\n */\nfunction nsHttpHeaders()\n{\n  /**\n   * A hash of headers, with header field names as the keys and header field\n   * values as the values.  Header field names are case-insensitive, but upon\n   * insertion here they are converted to lowercase.  Header field values are\n   * normalized upon insertion to contain no leading or trailing whitespace.\n   *\n   * Note also that per RFC 2616, section 4.2, two headers with the same name in\n   * a message may be treated as one header with the same field name and a field\n   * value consisting of the separate field values joined together with a \",\" in\n   * their original order.  This hash stores multiple headers with the same name\n   * in this manner.\n   */\n  this._headers = {};\n}\nnsHttpHeaders.prototype =\n{\n  /**\n   * Sets the header represented by name and value in this.\n   *\n   * @param name : string\n   *   the header name\n   * @param value : string\n   *   the header value\n   * @throws NS_ERROR_INVALID_ARG\n   *   if name or value is not a valid header component\n   */\n  setHeader: function(fieldName, fieldValue, merge)\n  {\n    var name = headerUtils.normalizeFieldName(fieldName);\n    var value = headerUtils.normalizeFieldValue(fieldValue);\n\n    // The following three headers are stored as arrays because their real-world\n    // syntax prevents joining individual headers into a single header using \n    // \",\".  See also <http://hg.mozilla.org/mozilla-central/diff/9b2a99adc05e/netwerk/protocol/http/src/nsHttpHeaderArray.cpp#l77>\n    if (merge && name in this._headers)\n    {\n      if (name === \"www-authenticate\" ||\n          name === \"proxy-authenticate\" ||\n          name === \"set-cookie\") \n      {\n        this._headers[name].push(value);\n      }\n      else \n      {\n        this._headers[name][0] += \",\" + value;\n        NS_ASSERT(this._headers[name].length === 1,\n            \"how'd a non-special header have multiple values?\")\n      }\n    }\n    else\n    {\n      this._headers[name] = [value];\n    }\n  },\n\n  /**\n   * Returns the value for the header specified by this.\n   *\n   * @throws NS_ERROR_INVALID_ARG\n   *   if fieldName does not constitute a valid header field name\n   * @throws NS_ERROR_NOT_AVAILABLE\n   *   if the given header does not exist in this\n   * @returns string\n   *   the field value for the given header, possibly with non-semantic changes\n   *   (i.e., leading/trailing whitespace stripped, whitespace runs replaced\n   *   with spaces, etc.) at the option of the implementation; multiple \n   *   instances of the header will be combined with a comma, except for \n   *   the three headers noted in the description of getHeaderValues\n   */\n  getHeader: function(fieldName)\n  {\n    return this.getHeaderValues(fieldName).join(\"\\n\");\n  },\n\n  /**\n   * Returns the value for the header specified by fieldName as an array.\n   *\n   * @throws NS_ERROR_INVALID_ARG\n   *   if fieldName does not constitute a valid header field name\n   * @throws NS_ERROR_NOT_AVAILABLE\n   *   if the given header does not exist in this\n   * @returns [string]\n   *   an array of all the header values in this for the given\n   *   header name.  Header values will generally be collapsed\n   *   into a single header by joining all header values together\n   *   with commas, but certain headers (Proxy-Authenticate,\n   *   WWW-Authenticate, and Set-Cookie) violate the HTTP spec\n   *   and cannot be collapsed in this manner.  For these headers\n   *   only, the returned array may contain multiple elements if\n   *   that header has been added more than once.\n   */\n  getHeaderValues: function(fieldName)\n  {\n    var name = headerUtils.normalizeFieldName(fieldName);\n\n    if (name in this._headers)\n      return this._headers[name];\n    else\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n  },\n\n  /**\n   * Returns true if a header with the given field name exists in this, false\n   * otherwise.\n   *\n   * @param fieldName : string\n   *   the field name whose existence is to be determined in this\n   * @throws NS_ERROR_INVALID_ARG\n   *   if fieldName does not constitute a valid header field name\n   * @returns boolean\n   *   true if the header's present, false otherwise\n   */\n  hasHeader: function(fieldName)\n  {\n    var name = headerUtils.normalizeFieldName(fieldName);\n    return (name in this._headers);\n  },\n\n  /**\n   * Returns a new enumerator over the field names of the headers in this, as\n   * nsISupportsStrings.  The names returned will be in lowercase, regardless of\n   * how they were input using setHeader (header names are case-insensitive per\n   * RFC 2616).\n   */\n  get enumerator()\n  {\n    var headers = [];\n    for (var i in this._headers)\n    {\n      var supports = new SupportsString();\n      supports.data = i;\n      headers.push(supports);\n    }\n\n    return new nsSimpleEnumerator(headers);\n  }\n};\n\n\n/**\n * Constructs an nsISimpleEnumerator for the given array of items.\n *\n * @param items : Array\n *   the items, which must all implement nsISupports\n */\nfunction nsSimpleEnumerator(items)\n{\n  this._items = items;\n  this._nextIndex = 0;\n}\nnsSimpleEnumerator.prototype =\n{\n  hasMoreElements: function()\n  {\n    return this._nextIndex < this._items.length;\n  },\n  getNext: function()\n  {\n    if (!this.hasMoreElements())\n      throw Cr.NS_ERROR_NOT_AVAILABLE;\n\n    return this._items[this._nextIndex++];\n  },\n  QueryInterface: function(aIID)\n  {\n    if (Ci.nsISimpleEnumerator.equals(aIID) ||\n        Ci.nsISupports.equals(aIID))\n      return this;\n\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  }\n};\n\n\n/**\n * A representation of the data in an HTTP request.\n *\n * @param port : uint\n *   the port on which the server receiving this request runs\n */\nfunction Request(port)\n{\n  /** Method of this request, e.g. GET or POST. */\n  this._method = \"\";\n\n  /** Path of the requested resource; empty paths are converted to '/'. */\n  this._path = \"\";\n\n  /** Query string, if any, associated with this request (not including '?'). */\n  this._queryString = \"\";\n\n  /** Scheme of requested resource, usually http, always lowercase. */\n  this._scheme = \"http\";\n\n  /** Hostname on which the requested resource resides. */\n  this._host = undefined;\n\n  /** Port number over which the request was received. */\n  this._port = port;\n\n  var bodyPipe = new Pipe(false, false, 0, PR_UINT32_MAX, null);\n\n  /** Stream from which data in this request's body may be read. */\n  this._bodyInputStream = bodyPipe.inputStream;\n\n  /** Stream to which data in this request's body is written. */\n  this._bodyOutputStream = bodyPipe.outputStream;\n\n  /**\n   * The headers in this request.\n   */\n  this._headers = new nsHttpHeaders();\n\n  /**\n   * For the addition of ad-hoc properties and new functionality without having\n   * to change nsIHttpRequest every time; currently lazily created, as its only\n   * use is in directory listings.\n   */\n  this._bag = null;\n}\nRequest.prototype =\n{\n  // SERVER METADATA\n\n  //\n  // see nsIHttpRequest.scheme\n  //\n  get scheme()\n  {\n    return this._scheme;\n  },\n\n  //\n  // see nsIHttpRequest.host\n  //\n  get host()\n  {\n    return this._host;\n  },\n\n  //\n  // see nsIHttpRequest.port\n  //\n  get port()\n  {\n    return this._port;\n  },\n\n  // REQUEST LINE\n\n  //\n  // see nsIHttpRequest.method\n  //\n  get method()\n  {\n    return this._method;\n  },\n\n  //\n  // see nsIHttpRequest.httpVersion\n  //\n  get httpVersion()\n  {\n    return this._httpVersion.toString();\n  },\n\n  //\n  // see nsIHttpRequest.path\n  //\n  get path()\n  {\n    return this._path;\n  },\n\n  //\n  // see nsIHttpRequest.queryString\n  //\n  get queryString()\n  {\n    return this._queryString;\n  },\n\n  // HEADERS\n\n  //\n  // see nsIHttpRequest.getHeader\n  //\n  getHeader: function(name)\n  {\n    return this._headers.getHeader(name);\n  },\n\n  //\n  // see nsIHttpRequest.hasHeader\n  //\n  hasHeader: function(name)\n  {\n    return this._headers.hasHeader(name);\n  },\n\n  //\n  // see nsIHttpRequest.headers\n  //\n  get headers()\n  {\n    return this._headers.enumerator;\n  },\n\n  //\n  // see nsIPropertyBag.enumerator\n  //\n  get enumerator()\n  {\n    this._ensurePropertyBag();\n    return this._bag.enumerator;\n  },\n\n  //\n  // see nsIHttpRequest.headers\n  //\n  get bodyInputStream()\n  {\n    return this._bodyInputStream;\n  },\n\n  //\n  // see nsIPropertyBag.getProperty\n  //\n  getProperty: function(name) \n  {\n    this._ensurePropertyBag();\n    return this._bag.getProperty(name);\n  },\n\n\n  // NSISUPPORTS\n\n  //\n  // see nsISupports.QueryInterface\n  //\n  QueryInterface: function(iid)\n  {\n    if (iid.equals(Ci.nsIHttpRequest) || iid.equals(Ci.nsISupports))\n      return this;\n\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  },\n\n\n  // PRIVATE IMPLEMENTATION\n  \n  /** Ensures a property bag has been created for ad-hoc behaviors. */\n  _ensurePropertyBag: function()\n  {\n    if (!this._bag)\n      this._bag = new WritablePropertyBag();\n  }\n};\n\n\n// XPCOM trappings\n\nthis.NSGetFactory = XPCOMUtils.generateNSGetFactory([nsHttpServer]);\n\n/**\n * Creates a new HTTP server listening for loopback traffic on the given port,\n * starts it, and runs the server until the server processes a shutdown request,\n * spinning an event loop so that events posted by the server's socket are\n * processed.\n *\n * This method is primarily intended for use in running this script from within\n * xpcshell and running a functional HTTP server without having to deal with\n * non-essential details.\n *\n * Note that running multiple servers using variants of this method probably\n * doesn't work, simply due to how the internal event loop is spun and stopped.\n *\n * @note\n *   This method only works with Mozilla 1.9 (i.e., Firefox 3 or trunk code);\n *   you should use this server as a component in Mozilla 1.8.\n * @param port\n *   the port on which the server will run, or -1 if there exists no preference\n *   for a specific port; note that attempting to use some values for this\n *   parameter (particularly those below 1024) may cause this method to throw or\n *   may result in the server being prematurely shut down\n * @param basePath\n *   a local directory from which requests will be served (i.e., if this is\n *   \"/home/jwalden/\" then a request to /index.html will load\n *   /home/jwalden/index.html); if this is omitted, only the default URLs in\n *   this server implementation will be functional\n */\nfunction server(port, basePath)\n{\n  if (basePath)\n  {\n    var lp = Cc[\"@mozilla.org/file/local;1\"]\n               .createInstance(Ci.nsILocalFile);\n    lp.initWithPath(basePath);\n  }\n\n  // if you're running this, you probably want to see debugging info\n  DEBUG = true;\n\n  var srv = new nsHttpServer();\n  if (lp)\n    srv.registerDirectory(\"/\", lp);\n  srv.registerContentType(\"sjs\", SJS_TYPE);\n  srv.identity.setPrimary(\"http\", \"localhost\", port);\n  srv.start(port);\n\n  var thread = gThreadManager.currentThread;\n  while (!srv.isStopped())\n    thread.processNextEvent(true);\n\n  // get rid of any pending requests\n  while (thread.hasPendingEvents())\n    thread.processNextEvent(true);\n\n  DEBUG = false;\n}\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/navigation.js":"\nconst Cc = Components.classes;\nconst Ci = Components.interfaces;\nconst Cr = Components.results;\nconst Cu = Components.utils;\n\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nCu.import(\"resource://gre/modules/Services.jsm\");\nCu.import(\"resource://slimerjs/slUtils.jsm\");\n\nconst IDS = Ci.nsIDocShell;\nconst IWN = Ci.nsIWebNavigation;\n\n\nfunction makeLoadFlag(type, flags) { return type | (flags << 16);}\n\nconst LOAD_LINK = makeLoadFlag(IDS.LOAD_CMD_NORMAL, IWN.LOAD_FLAGS_IS_LINK);\nconst LOAD_HISTORY = makeLoadFlag(IDS.LOAD_CMD_HISTORY, IWN.LOAD_FLAGS_NONE);\n\nfunction Navigation() {\n}\n\nNavigation.prototype = {\n    classID          : Components.ID(\"{5a5f9d66-53b5-4541-8225-cae868541bc2}\"),\n    classDescription: \"Navigation manager for SlimerJS\",\n    QueryInterface   : XPCOMUtils.generateQI([Ci.nsIContentPolicy]),\n\n    // short shouldLoad(in unsigned long aContentType, in nsIURI aContentLocation,\n    //                  in nsIURI aRequestOrigin, in nsISupports aContext,\n    //                  in ACString aMimeTypeGuess, in nsISupports aExtra, in nsIPrincipal aRequestPrincipal);\n    shouldLoad : function(aContentType, aContentLocation, aRequestOrigin, aContext, aMimeTypeGuess, aExtra) {\n        let result = Ci.nsIContentPolicy.ACCEPT;\n\n        // ignore content that is not a document\n        if (Ci.nsIContentPolicy.TYPE_DOCUMENT != aContentType\n            && Ci.nsIContentPolicy.TYPE_SUBDOCUMENT != aContentType) {\n          return result;\n        }\n\n        // ignore content that is loaded from chrome, about, resource protocols etc..\n        if (aContentLocation.scheme != 'http'\n            && aContentLocation.scheme != 'https'\n            && aContentLocation.scheme != 'ftp'\n            && aContentLocation.scheme != 'file'\n            ){\n            return result;\n        }\n\n        //------ retrieve the corresponding webpage object\n        let [webpage, navtype] = this._findWebpage(aContext);\n        if (!webpage)\n            return result;\n\n        // call the navigationRequest callback\n        webpage.navigationRequested(aContentLocation.spec, navtype, !webpage.navigationLocked,\n                                    (Ci.nsIContentPolicy.TYPE_DOCUMENT == aContentType));\n\n\n        // if the navigation request is blocked, refuse the content\n        if (webpage.navigationLocked) {\n            result = Ci.nsIContentPolicy.REJECT_REQUEST;\n        }\n        return result;\n    },\n\n    // short shouldProcess(in unsigned long aContentType, in nsIURI aContentLocation,\n    //                  in nsIURI aRequestOrigin, in nsISupports aContext,\n    //                  in ACString aMimeType, in nsISupports aExtra, in nsIPrincipal aRequestPrincipal);\n    shouldProcess : function(aContentType, aContentLocation, aRequestOrigin, aContext, aMimeType, aExtra) {\n        return Ci.nsIContentPolicy.ACCEPT;\n    },\n\n    /**\n     * @param mixed aContext it could be\n     *     - the element that own the content (<browser>, <iframe>...)\n     *     - or the window\n     *     - or the document (of the content ?).\n     */\n    _findWebpage : function(aContext) {\n        // this function mimic NS_CP_GetDocShellFromContext\n        if (!aContext) {\n            return [null, null];\n        }\n\n        // in the case where we receive a DOM element: this is can be a xul <browser>\n        // for top window or an html <(i)frame> ...\n        try {\n            let node = aContext.QueryInterface(Ci.nsIDOMElement);\n            let docshell = this._getDocShell(node.contentWindow);\n\n            if (node.localName != 'browser') {\n                // this is an html frame : retrieve the corresponding browser\n                node = docshell.chromeEventHandler;\n                if (!node) {\n                   return [null, null];\n                }\n                docshell = node.docShell;\n            }\n\n            let navType = this._getNavType(docshell);\n            return [(node.webpage?node.webpage: null), navType];\n        }\n        catch(e){}\n\n        // in the case where we receive a window\n        // FIXME do we receive always a chrome window?\n        try {\n            aContext = aContext.QueryInterface(Ci.nsIDOMWindow);\n            if (aContext instanceof Ci.nsIDOMChromeWindow) {\n                let browser = aContext.document.getElementById('webpage');\n                if (browser) {\n                    let navType = this._getNavType(browser.docShell);\n                    return [browser.webpage, navType];\n                }\n                return [null, null];\n            }\n            else {\n                return this._getWebpageAndNavType(aContext);\n            }\n        }\n        catch(e){}\n\n        // in the case where we receive a document\n        let doc;\n        try {\n            doc = aContext.QueryInterface(Ci.nsIDOMDocument);\n            return this._getWebPageAndNavType(doc.defaultView);\n        }\n        catch(e){}\n        return [null, null];\n    },\n\n    _getDocShell : function(contentWindow) {\n        try {\n            return contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)\n                        .getInterface(IWN)\n                        .QueryInterface(IDS)\n        }\n        catch(e) {\n            return null;\n        }\n    },\n    _getWebPageAndNavType : function (contentWindow) {\n        let dc = this._getDocShell(contentWindow);\n        if (dc)\n            return [this._getWebPage(dc), this._getNavType(dc)];\n        return [null, null]\n    },\n    _getWebPage : function(docshell) {\n        return slUtils.getWebpageFromDocShell(docshell);\n    },\n    _getNavType : function(docshell) {\n        let navType = \"Undefined\";\n\n        // FIXME it seems that the loadType on the docshell is not updated\n        // at this time, and we have the value of the previous loading.\n        // so the value of navtype is not correct. We should not use it :-/\n        /*dump(\"loadType=\"+docshell.loadType+\"\\n\")\n        if (docshell.loadType & IDS.LOAD_CMD_RELOAD) {\n            navType = \"Reload\";\n        }\n        else if (docshell.loadType & IDS.LOAD_CMD_HISTORY\n                 ||docshell.loadType & IDS.LOAD_CMD_PUSHSTATE) {\n            navType = \"BackOrForward\";\n        }\n        else if (docshell.loadType == LOAD_LINK) {\n            navType = \"LinkClicked\";\n        }\n        else if (docshell.loadType & IDS.LOAD_CMD_NORMAL) {\n            navType = \"Other\"\n        }*/\n        //FIXME: \"FormSubmitted\" \"FormResubmitted\"\n\n        return navType;\n    }\n}\n\nthis.NSGetFactory = XPCOMUtils.generateNSGetFactory([Navigation]);\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/nsPrompter.js":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n// copy of toolkit/components/prompts/src/nsPrompter.js\n\n\"use strict\";\n\nconst Cc = Components.classes;\nconst Ci = Components.interfaces;\nconst Cr = Components.results;\nconst Cu = Components.utils;\n\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nCu.import(\"resource://gre/modules/Services.jsm\");\nCu.import(\"resource://slimerjs/slUtils.jsm\");\nCu.import(\"resource://slimerjs/slConfiguration.jsm\");\n\nvar geckoVersion = Services.appinfo.platformVersion.split('.')[0];\n\nfunction Prompter() {\n    // Note that EmbedPrompter clones this implementation.\n}\n\nPrompter.prototype = {\n    classID          : Components.ID(\"{47c45611-1cfe-4f5e-9749-dc5c78ce8b40}\"),\n    QueryInterface   : XPCOMUtils.generateQI([Ci.nsIPromptFactory, Ci.nsIPromptService, Ci.nsIPromptService2]),\n\n\n    /* ----------  private members  ---------- */\n\n    pickPrompter : function (domWin) {\n        return new ModalPrompter(domWin);\n    },\n\n\n    /* ----------  nsIPromptFactory  ---------- */\n\n\n    getPrompt : function (domWin, iid) {\n        // This is still kind of dumb; the C++ code delegated to login manager\n        // here, which in turn calls back into us via nsIPromptService2.\n        if (iid.equals(Ci.nsIAuthPrompt2) || iid.equals(Ci.nsIAuthPrompt)) {\n            try {\n                let pwmgr = Cc[\"@mozilla.org/passwordmanager/authpromptfactory;1\"].\n                            getService(Ci.nsIPromptFactory);\n                return pwmgr.getPrompt(domWin, iid);\n            } catch (e) {\n                Cu.reportError(\"nsPrompter: Delegation to password manager failed: \" + e);\n            }\n        }\n        let p = new ModalPrompter(domWin);\n        p.QueryInterface(iid);\n        return p;\n    },\n\n\n    /* ----------  nsIPromptService  ---------- */\n\n\n    alert : function (domWin, title, text) {\n        let p = this.pickPrompter(domWin);\n        p.alert(title, text);\n    },\n\n    alertCheck : function (domWin, title, text, checkLabel, checkValue) {\n        let p = this.pickPrompter(domWin);\n        p.alertCheck(title, text, checkLabel, checkValue);\n    },\n\n    confirm : function (domWin, title, text) {\n        let p = this.pickPrompter(domWin);\n        return p.confirm(title, text);\n    },\n\n    confirmCheck : function (domWin, title, text, checkLabel, checkValue) {\n        let p = this.pickPrompter(domWin);\n        return p.confirmCheck(title, text, checkLabel, checkValue);\n    },\n\n    confirmEx : function (domWin, title, text, flags, button0, button1, button2, checkLabel, checkValue) {\n        let p = this.pickPrompter(domWin);\n        return p.confirmEx(title, text,  flags, button0, button1, button2, checkLabel, checkValue);\n    },\n\n    prompt : function (domWin, title, text, value, checkLabel, checkValue) {\n        let p = this.pickPrompter(domWin);\n        return p.nsIPrompt_prompt(title, text, value, checkLabel, checkValue);\n    },\n\n    promptUsernameAndPassword : function (domWin, title, text, user, pass, checkLabel, checkValue) {\n        let p = this.pickPrompter(domWin);\n        return p.nsIPrompt_promptUsernameAndPassword(title, text, user, pass, checkLabel, checkValue);\n    },\n\n    promptPassword : function (domWin, title, text, pass, checkLabel, checkValue) {\n        let p = this.pickPrompter(domWin);\n        return p.nsIPrompt_promptPassword(title, text, pass, checkLabel, checkValue);\n    },\n\n    select : function (domWin, title, text, count, list, selected) {\n        let p = this.pickPrompter(domWin);\n        return p.select(title, text, count, list, selected);\n    },\n\n\n    /* ----------  nsIPromptService2  ---------- */\n\n\n    promptAuth : function (domWin, channel, level, authInfo, checkLabel, checkValue) {\n        let p = this.pickPrompter(domWin);\n        return p.promptAuth(channel, level, authInfo, checkLabel, checkValue);\n    },\n\n    asyncPromptAuth : function (domWin, channel, callback, context, level, authInfo, checkLabel, checkValue) {\n        let p = this.pickPrompter(domWin);\n        return p.asyncPromptAuth(channel, callback, context, level, authInfo, checkLabel, checkValue);\n    },\n\n};\n\n\n// Common utils not specific to a particular prompter style.\nlet PromptUtils = {\n\n    getLocalizedString : function (key, formatArgs) {\n        if (formatArgs)\n            return this.strBundle.formatStringFromName(key, formatArgs, formatArgs.length);\n        return this.strBundle.GetStringFromName(key);\n    },\n\n    confirmExHelper : function (flags, button0, button1, button2) {\n\n        const BUTTON_DEFAULT_MASK = 0x03000000;\n        let defaultButtonNum = (flags & BUTTON_DEFAULT_MASK) >> 24;\n        let isDelayEnabled = (flags & Ci.nsIPrompt.BUTTON_DELAY_ENABLE);\n\n        // Flags can be used to select a specific pre-defined button label or\n        // a caller-supplied string (button0/button1/button2). If no flags are\n        // set for a button, then the button won't be shown.\n        let argText = [button0, button1, button2];\n        let buttonLabels = [null, null, null];\n        for (let i = 0; i < 3; i++) {\n            let buttonLabel;\n            switch (flags & 0xff) {\n              case Ci.nsIPrompt.BUTTON_TITLE_OK:\n                buttonLabel = PromptUtils.getLocalizedString(\"OK\");\n                break;\n              case Ci.nsIPrompt.BUTTON_TITLE_CANCEL:\n                buttonLabel = PromptUtils.getLocalizedString(\"Cancel\");\n                break;\n              case Ci.nsIPrompt.BUTTON_TITLE_YES:\n                buttonLabel = PromptUtils.getLocalizedString(\"Yes\");\n                break;\n              case Ci.nsIPrompt.BUTTON_TITLE_NO:\n                buttonLabel = PromptUtils.getLocalizedString(\"No\");\n                break;\n              case Ci.nsIPrompt.BUTTON_TITLE_SAVE:\n                buttonLabel = PromptUtils.getLocalizedString(\"Save\");\n                break;\n              case Ci.nsIPrompt.BUTTON_TITLE_DONT_SAVE:\n                buttonLabel = PromptUtils.getLocalizedString(\"DontSave\");\n                break;\n              case Ci.nsIPrompt.BUTTON_TITLE_REVERT:\n                buttonLabel = PromptUtils.getLocalizedString(\"Revert\");\n                break;\n              case Ci.nsIPrompt.BUTTON_TITLE_IS_STRING:\n                buttonLabel = argText[i];\n                break;\n            }\n            if (buttonLabel)\n                buttonLabels[i] = buttonLabel;\n            flags >>= 8;\n        }\n\n        return [buttonLabels[0], buttonLabels[1], buttonLabels[2], defaultButtonNum, isDelayEnabled];\n    },\n\n    // Fire a dialog open/close event. Used by tabbrowser to focus the\n    // tab which is triggering a prompt.\n    //\n    // Bug 611553 - should make these notifications instead of events.\n    fireDialogEvent : function (domWin, eventName) {\n        let event = domWin.document.createEvent(\"Events\");\n        event.initEvent(eventName, true, true);\n        domWin.dispatchEvent(event);\n    },\n\n    getAuthInfo : function (authInfo) {\n        let username, password;\n\n        let flags = authInfo.flags;\n        if (flags & Ci.nsIAuthInformation.NEED_DOMAIN && authInfo.domain)\n            username = authInfo.domain + \"\\\\\" + authInfo.username;\n        else\n            username = authInfo.username;\n\n        password = authInfo.password;\n\n        return [username, password];\n    },\n\n    setAuthInfo : function (authInfo, username, password) {\n        let flags = authInfo.flags;\n        if (flags & Ci.nsIAuthInformation.NEED_DOMAIN) {\n            // Domain is separated from username by a backslash\n            let idx = username.indexOf(\"\\\\\");\n            if (idx == -1) {\n                authInfo.username = username;\n            } else {\n                authInfo.domain   =  username.substring(0, idx);\n                authInfo.username =  username.substring(idx+1);\n            }\n        } else {\n            authInfo.username = username;\n        }\n        authInfo.password = password;\n    },\n\n    // Copied from login manager\n    getFormattedHostname : function (uri) {\n        let scheme = uri.scheme;\n        let hostname = scheme + \"://\" + uri.host;\n\n        // If the URI explicitly specified a port, only include it when\n        // it's not the default. (We never want \"http://foo.com:80\")\n        let port = uri.port;\n        if (port != -1) {\n            let handler = Services.io.getProtocolHandler(scheme);\n            if (port != handler.defaultPort)\n                hostname += \":\" + port;\n        }\n\n        return hostname;\n    },\n\n    // Copied from login manager\n    getAuthTarget : function (aChannel, aAuthInfo) {\n        let hostname, realm;\n\n        // If our proxy is demanding authentication, don't use the\n        // channel's actual destination.\n        if (aAuthInfo.flags & Ci.nsIAuthInformation.AUTH_PROXY) {\n            if (!(aChannel instanceof Ci.nsIProxiedChannel))\n                throw \"proxy auth needs nsIProxiedChannel\";\n\n            let info = aChannel.proxyInfo;\n            if (!info)\n                throw \"proxy auth needs nsIProxyInfo\";\n\n            // Proxies don't have a scheme, but we'll use \"moz-proxy://\"\n            // so that it's more obvious what the login is for.\n            let idnService = Cc[\"@mozilla.org/network/idn-service;1\"].\n                             getService(Ci.nsIIDNService);\n            hostname = \"moz-proxy://\" +\n                        idnService.convertUTF8toACE(info.host) +\n                        \":\" + info.port;\n            realm = aAuthInfo.realm;\n            if (!realm)\n                realm = hostname;\n\n            return [hostname, realm];\n        }\n\n        hostname = this.getFormattedHostname(aChannel.URI);\n\n        // If a HTTP WWW-Authenticate header specified a realm, that value\n        // will be available here. If it wasn't set or wasn't HTTP, we'll use\n        // the formatted hostname instead.\n        realm = aAuthInfo.realm;\n        if (!realm)\n            realm = hostname;\n\n        return [hostname, realm];\n    },\n\n\n    makeAuthMessage : function (channel, authInfo) {\n        let isProxy    = (authInfo.flags & Ci.nsIAuthInformation.AUTH_PROXY);\n        let isPassOnly = (authInfo.flags & Ci.nsIAuthInformation.ONLY_PASSWORD);\n\n        let username = authInfo.username;\n        let [displayHost, realm] = this.getAuthTarget(channel, authInfo);\n\n        // Suppress \"the site says: $realm\" when we synthesized a missing realm.\n        if (!authInfo.realm && !isProxy)\n            realm = \"\";\n\n        // Trim obnoxiously long realms.\n        if (realm.length > 150) {\n            realm = realm.substring(0, 150);\n            // Append \"...\" (or localized equivalent).\n            realm += this.ellipsis;\n        }\n\n        let text;\n        if (geckoVersion < 50) {\n            if (isProxy) {\n                text = PromptUtils.getLocalizedString(\"EnterLoginForProxy\", [realm, displayHost]);\n            } else if (isPassOnly) {\n                text = PromptUtils.getLocalizedString(\"EnterPasswordFor\", [username, displayHost]);\n            } else if (!realm) {\n                text = PromptUtils.getLocalizedString(\"EnterUserPasswordFor\", [displayHost]);\n            } else {\n                text = PromptUtils.getLocalizedString(\"EnterLoginForRealm\", [realm, displayHost]);\n            }\n        }\n        else if (geckoVersion == 50) {\n            let isCrossOrig = (authInfo.flags &\n                               Ci.nsIAuthInformation.CROSS_ORIGIN_SUB_RESOURCE);\n            if (isProxy) {\n                text = PromptUtils.getLocalizedString(\"EnterLoginForProxy2\", [realm, displayHost]);\n            } else if (isPassOnly) {\n                text = PromptUtils.getLocalizedString(\"EnterPasswordFor\", [username, displayHost]);\n            } else if (isCrossOrig) {\n                text = PromptUtils.getLocalizedString(\"EnterUserPasswordForCrossOrigin\", [displayHost]);\n            } else if (!realm) {\n                text = PromptUtils.getLocalizedString(\"EnterUserPasswordFor2\", [displayHost]);\n            } else {\n                text = PromptUtils.getLocalizedString(\"EnterLoginForRealm2\", [realm, displayHost]);\n            }\n        }\n        else {\n            let isCrossOrig = (authInfo.flags &\n                               Ci.nsIAuthInformation.CROSS_ORIGIN_SUB_RESOURCE);\n            if (isProxy) {\n                text = PromptUtils.getLocalizedString(\"EnterLoginForProxy3\", [realm, displayHost]);\n            } else if (isPassOnly) {\n                text = PromptUtils.getLocalizedString(\"EnterPasswordFor\", [username, displayHost]);\n            } else if (isCrossOrig) {\n                text = PromptUtils.getLocalizedString(\"EnterUserPasswordForCrossOrigin2\", [displayHost]);\n            } else if (!realm) {\n                text = PromptUtils.getLocalizedString(\"EnterUserPasswordFor2\", [displayHost]);\n            } else {\n                text = PromptUtils.getLocalizedString(\"EnterLoginForRealm3\", [realm, displayHost]);\n            }\n        }\n        return text;\n    },\n\n    objectToPropBag : function (obj) {\n        let bag = Cc[\"@mozilla.org/hash-property-bag;1\"].\n                  createInstance(Ci.nsIWritablePropertyBag2);\n        bag.QueryInterface(Ci.nsIWritablePropertyBag);\n\n        for (let propName in obj)\n            bag.setProperty(propName, obj[propName]);\n\n        return bag;\n    },\n\n    propBagToObject : function (propBag, obj) {\n        // Here we iterate over the object's original properties, not the bag\n        // (ie, the prompt can't return more/different properties than were\n        // passed in). This just helps ensure that the caller provides default\n        // values, lest the prompt forget to set them.\n        for (let propName in obj)\n            obj[propName] = propBag.getProperty(propName);\n    },\n    \n    isSlowScriptDialog : function (title) {\n        return this.domBundle.GetStringFromName(\"KillScriptTitle\") === title;\n    }\n};\n\nXPCOMUtils.defineLazyGetter(PromptUtils, \"strBundle\", function () {\n    let bunService = Cc[\"@mozilla.org/intl/stringbundle;1\"].\n                     getService(Ci.nsIStringBundleService);\n    let bundle = bunService.createBundle(\"chrome://global/locale/commonDialogs.properties\");\n    if (!bundle)\n        throw \"String bundle for Prompter not present!\";\n    return bundle;\n});\n\nXPCOMUtils.defineLazyGetter(PromptUtils, \"domBundle\", function () {\n    let bunService = Cc[\"@mozilla.org/intl/stringbundle;1\"].\n                     getService(Ci.nsIStringBundleService);\n    let bundle = bunService.createBundle(\"chrome://global/locale/dom/dom.properties\");\n    if (!bundle)\n        throw \"String dom bundle for Prompter not present!\";\n    return bundle;\n});\n\nXPCOMUtils.defineLazyGetter(PromptUtils, \"ellipsis\", function () {\n    let ellipsis = \"\\u2026\";\n    try {\n        ellipsis = Services.prefs.getComplexValue(\"intl.ellipsis\", Ci.nsIPrefLocalizedString).data;\n    } catch (e) { }\n    return ellipsis;\n});\n\n\nfunction openModalWindow(domWin, uri, args) {\n    // There's an implied contract that says modal prompts should still work\n    // when no \"parent\" window is passed for the dialog (eg, the \"Master\n    // Password\" dialog does this).  These prompts must be shown even if there\n    // are *no* visible windows at all.\n    // There's also a requirement for prompts to be blocked if a window is\n    // passed and that window is hidden (eg, auth prompts are supressed if the\n    // passed window is the hidden window).\n    // See bug 875157 comment 30 for more...\n    if (domWin) {\n        // a domWin was passed, so we can apply the check for it being hidden.\n        let winUtils = domWin.QueryInterface(Ci.nsIInterfaceRequestor)\n            .getInterface(Ci.nsIDOMWindowUtils);\n\n        if (winUtils && !winUtils.isParentWindowMainWidgetVisible) {\n            throw Components.Exception(\"Cannot call openModalWindow on a hidden window\",\n                Cr.NS_ERROR_NOT_AVAILABLE);\n        }\n    } else {\n        // We try and find a window to use as the parent, but don't consider\n        // if that is visible before showing the prompt.\n        domWin = Services.ww.activeWindow;\n        // domWin may still be null here if there are _no_ windows open.\n    }\n    // Note that we don't need to fire DOMWillOpenModalDialog and\n    // DOMModalDialogClosed events here, wwatcher's OpenWindowInternal\n    // will do that. Similarly for enterModalState / leaveModalState.\n\n    Services.ww.openWindow(domWin, uri, \"_blank\", \"centerscreen,chrome,modal,titlebar\", args);\n}\n\nfunction openTabPrompt(domWin, tabPrompt, args) {\n    PromptUtils.fireDialogEvent(domWin, \"DOMWillOpenModalDialog\");\n\n    let winUtils = domWin.QueryInterface(Ci.nsIInterfaceRequestor)\n                         .getInterface(Ci.nsIDOMWindowUtils);\n    let callerWin = winUtils.enterModalStateWithWindow();\n\n    // We provide a callback so the prompt can close itself. We don't want to\n    // wait for this event loop to return... Otherwise the presence of other\n    // prompts on the call stack would in this dialog appearing unresponsive\n    // until the other prompts had been closed.\n    let callbackInvoked = false;\n    function onPromptClose(forceCleanup) {\n        if (!newPrompt && !forceCleanup)\n            return;\n        callbackInvoked = true;\n        if (newPrompt)\n            tabPrompt.removePrompt(newPrompt);\n\n        winUtils.leaveModalStateWithWindow(callerWin);\n\n        PromptUtils.fireDialogEvent(domWin, \"DOMModalDialogClosed\");\n    }\n\n    let newPrompt;\n    try {\n        // tab-modal prompts need to watch for navigation changes, give it the\n        // domWindow to watch for pagehide events.\n        args.domWindow = domWin;\n        args.promptActive = true;\n\n        newPrompt = tabPrompt.appendPrompt(args, onPromptClose);\n\n        // TODO since we don't actually open a window, need to check if\n        // there's other stuff in nsWindowWatcher::OpenWindowInternal\n        // that we might need to do here as well.\n\n        let thread = Services.tm.currentThread;\n        while (args.promptActive)\n            thread.processNextEvent(true);\n        delete args.promptActive;\n\n        if (args.promptAborted)\n            throw Components.Exception(\"prompt aborted by user\", Cr.NS_ERROR_NOT_AVAILABLE);\n    } finally {\n        // If the prompt unexpectedly failed to invoke the callback, do so here.\n        if (!callbackInvoked)\n            onPromptClose(true);\n    }\n}\n\nfunction ModalPrompter(domWin) {\n    this.domWin = domWin;\n}\nModalPrompter.prototype = {\n    domWin : null,\n    /*\n     * Default to not using a tab-modal prompt, unless the caller opts in by\n     * QIing to nsIWritablePropertyBag and setting the value of this property\n     * to true.\n     */\n    allowTabModal : false,\n\n    QueryInterface : XPCOMUtils.generateQI([Ci.nsIPrompt, Ci.nsIAuthPrompt,\nCi.nsIAuthPrompt2, Ci.nsIWritablePropertyBag2]),\n\n\n    /* ---------- internal methods ---------- */\n\n\n    openPrompt : function (args) {\n//FIXME HERE: call webpage callback\n\n        // If we can't do a tab modal prompt, fallback to using a window-modal dialog.\n        const COMMON_DIALOG = \"chrome://global/content/commonDialog.xul\";\n        const SELECT_DIALOG = \"chrome://global/content/selectDialog.xul\";\n\n        let uri = (args.promptType == \"select\") ? SELECT_DIALOG : COMMON_DIALOG;\n\n        let propBag = PromptUtils.objectToPropBag(args);\n        openModalWindow(this.domWin, uri, propBag);\n        PromptUtils.propBagToObject(propBag, args);\n    },\n\n    _findWebPage : function () {\n        return slUtils.getWebpageFromContentWindow(this.domWin)\n    },\n\n    /*\n     * ---------- interface disambiguation ----------\n     *\n     * nsIPrompt and nsIAuthPrompt share 3 method names with slightly\n     * different arguments. All but prompt() have the same number of\n     * arguments, so look at the arg types to figure out how we're being\n     * called. :-(\n     */\n    prompt : function() {\n        // also, the nsIPrompt flavor has 5 args instead of 6.\n        if (typeof arguments[2] == \"object\")\n            return this.nsIPrompt_prompt.apply(this, arguments);\n        return this.nsIAuthPrompt_prompt.apply(this, arguments);\n    },\n\n    promptUsernameAndPassword : function() {\n        // Both have 6 args, so use types.\n        if (typeof arguments[2] == \"object\")\n            return this.nsIPrompt_promptUsernameAndPassword.apply(this, arguments);\n        return this.nsIAuthPrompt_promptUsernameAndPassword.apply(this, arguments);\n    },\n\n    promptPassword : function() {\n        // Both have 5 args, so use types.\n        if (typeof arguments[2] == \"object\")\n            return this.nsIPrompt_promptPassword.apply(this, arguments);\n        return this.nsIAuthPrompt_promptPassword.apply(this, arguments);\n    },\n\n\n    /* ----------  nsIPrompt  ---------- */\n\n\n    alert : function (title, text) {\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"Alert\");\n        let webpage = this._findWebPage();\n        if (webpage) {\n            if (webpage.onAlert) {\n                webpage.onAlert(text);\n            }\n            return;\n        }\n\n        let args = {\n            promptType: \"alert\",\n            title:      title,\n            text:       text,\n        };\n\n        this.openPrompt(args);\n    },\n\n    alertCheck : function (title, text, checkLabel, checkValue) {\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"Alert\");\n\n        let args = {\n            promptType: \"alertCheck\",\n            title:      title,\n            text:       text,\n            checkLabel: checkLabel,\n            checked:    checkValue.value,\n        };\n\n        this.openPrompt(args);\n\n        // Checkbox state always returned, even if cancel clicked.\n        checkValue.value = args.checked;\n    },\n\n    confirm : function (title, text) {\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"Confirm\");\n\n        let webpage = this._findWebPage();\n        if (webpage) {\n            if (webpage.onConfirm) {\n                let ok = webpage.onConfirm(text, title);\n                return !!ok;\n            }\n            return false;\n        }\n\n        let args = {\n            promptType: \"confirm\",\n            title:      title,\n            text:       text,\n            ok:         false,\n        };\n\n        //this.openPrompt(args);\n\n        // Did user click Ok or Cancel?\n        return args.ok;\n    },\n\n    confirmCheck : function (title, text, checkLabel, checkValue) {\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"ConfirmCheck\");\n\n        let webpage = this._findWebPage();\n        if (webpage) {\n            if (webpage.onConfirm) {\n                let chk = { label: checkLabel, checked: checkValue.value };\n                let buttons = [\"Ok\", \"Cancel\"];\n                let ok = webpage.onConfirm(text, title, buttons, chk);\n                checkValue.value = !!chk.checked;\n                if (ok === 0) {\n                    ok = true;\n                }\n                else if (ok === 1) {\n                    ok = false;\n                }\n                return (!!ok);\n            }\n            return false;\n        }\n\n        let args = {\n            promptType: \"confirmCheck\",\n            title:      title,\n            text:       text,\n            checkLabel: checkLabel,\n            checked:    checkValue.value,\n            ok:         false,\n        };\n\n        //this.openPrompt(args);\n\n        // Checkbox state always returned, even if cancel clicked.\n        //checkValue.value = args.checked;\n\n        // Did user click Ok or Cancel?\n        return args.ok;\n    },\n\n    confirmEx : function (title, text, flags, button0, button1, button2,\n                          checkLabel, checkValue) {\n\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"Confirm\");\n\n        let args = {\n            promptType:  \"confirmEx\",\n            title:       title,\n            text:        text,\n            checkLabel:  checkLabel,\n            checked:     checkValue.value,\n            ok:          false,\n            buttonNumClicked: 1,\n        };\n\n        let [label0, label1, label2, defaultButtonNum, isDelayEnabled] =\n            PromptUtils.confirmExHelper(flags, button0, button1, button2);\n\n        args.defaultButtonNum = defaultButtonNum;\n        args.enableDelay = isDelayEnabled;\n\n        let buttons = [];\n        if (label0) {\n            args.button0Label = label0;\n            buttons.push(label0);\n            if (label1) {\n                args.button1Label = label1;\n                buttons.push(label1);\n                if (label2) {\n                    args.button2Label = label2;\n                    buttons.push(label2);\n                }\n            }\n        }\n        let webpage = this._findWebPage();\n        if (webpage) {\n            if (PromptUtils.isSlowScriptDialog(title)) {\n                if (webpage.onLongRunningScript) {\n                    webpage.stopJavaScript.__interrupt__ = false;\n                    webpage.onLongRunningScript(text.split('\\n')[2]);\n                    return Number(webpage.stopJavaScript.__interrupt__);\n                }\n                return 0;\n            }\n            if (webpage.onConfirm) {\n                let chk = { label: checkLabel, checked: checkValue.value };\n                let ok = webpage.onConfirm(text, title, buttons, chk);\n                checkValue.value = !!chk.checked;\n                if (ok === true) {\n                    ok = 0;\n                }\n                else if (ok === false) {\n                    ok = 1;\n                }\n                else {\n                    ok = parseInt(ok, 10);\n                    if (isNaN(ok)) {\n                        ok = 0;\n                    }\n                }\n                return ok;\n            }\n            return 0;\n        }\n\n        //this.openPrompt(args);\n\n        // Checkbox state always returned, even if cancel clicked.\n        //checkValue.value = args.checked;\n\n        // Get the number of the button the user clicked.\n        return args.buttonNumClicked;\n    },\n\n    nsIPrompt_prompt : function (title, text, value, checkLabel, checkValue) {\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"Prompt\");\n\n        let webpage = this._findWebPage();\n        if (webpage) {\n            if (!webpage.onPrompt) {\n                return false;\n            }\n            var result = webpage.onPrompt(text, value.value);\n\n            if (result === null) {\n                return false;\n            }\n            value.value = result;\n            return true;\n        }\n\n        let args = {\n            promptType: \"prompt\",\n            title:      title,\n            text:       text,\n            value:      value.value,\n            checkLabel: checkLabel,\n            checked:    checkValue.value,\n            ok:         false,\n        };\n\n        //this.openPrompt(args);\n\n        // Did user click Ok or Cancel?\n        let ok  = args.ok;\n        if (ok) {\n            checkValue.value = args.checked;\n            value.value      = args.value;\n        }\n\n        return ok;\n    },\n\n    nsIPrompt_promptUsernameAndPassword : function (title, text, user, pass, checkLabel, checkValue) {\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"PromptUsernameAndPassword2\");\n\n        let args = {\n            promptType: \"promptUserAndPass\",\n            title:      title,\n            text:       text,\n            user:       user.value,\n            pass:       pass.value,\n            checkLabel: checkLabel,\n            checked:    checkValue.value,\n            ok:         false,\n        };\n\n        this.openPrompt(args);\n\n        // Did user click Ok or Cancel?\n        let ok  = args.ok;\n        if (ok) {\n            checkValue.value = args.checked;\n            user.value       = args.user;\n            pass.value       = args.pass;\n        }\n\n        return ok;\n    },\n\n    nsIPrompt_promptPassword : function (title, text, pass, checkLabel, checkValue) {\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"PromptPassword2\");\n\n        let args = {\n            promptType: \"promptPassword\",\n            title:      title,\n            text:       text,\n            pass:       pass.value,\n            checkLabel: checkLabel,\n            checked:    checkValue.value,\n            ok:         false,\n        }\n\n        this.openPrompt(args);\n\n        // Did user click Ok or Cancel?\n        let ok  = args.ok;\n        if (ok) {\n            checkValue.value = args.checked;\n            pass.value       = args.pass;\n        }\n\n        return ok;\n    },\n\n    select : function (title, text, count, list, selected) {\n        if (!title)\n            title = PromptUtils.getLocalizedString(\"Select\");\n\n        let args = {\n            promptType: \"select\",\n            title:      title,\n            text:       text,\n            list:       list,\n            selected:   -1,\n            ok:         false,\n        };\n\n        this.openPrompt(args);\n\n        // Did user click Ok or Cancel?\n        let ok  = args.ok;\n        if (ok)\n            selected.value = args.selected;\n\n        return ok;\n    },\n\n\n    /* ----------  nsIAuthPrompt  ---------- */\n\n\n    nsIAuthPrompt_prompt : function (title, text, passwordRealm, savePassword, defaultText, result) {\n        // The passwordRealm and savePassword args were ignored by nsPrompt.cpp\n        if (defaultText)\n            result.value = defaultText;\n        return this.nsIPrompt_prompt(title, text, result, null, {});\n    },\n\n    nsIAuthPrompt_promptUsernameAndPassword : function (title, text, passwordRealm, savePassword, user, pass) {\n        // The passwordRealm and savePassword args were ignored by nsPrompt.cpp\n        return this.nsIPrompt_promptUsernameAndPassword(title, text, user, pass, null, {});\n    },\n\n    nsIAuthPrompt_promptPassword : function (title, text, passwordRealm, savePassword, pass) {\n        // The passwordRealm and savePassword args were ignored by nsPrompt.cpp\n        return this.nsIPrompt_promptPassword(title, text, pass, null, {});\n    },\n\n\n    /* ----------  nsIAuthPrompt2  ---------- */\n\n\n    promptAuth : function (channel, level, authInfo, checkLabel, checkValue) {\n        let message = PromptUtils.makeAuthMessage(channel, authInfo);\n        let [username, password] = PromptUtils.getAuthInfo(authInfo);\n        let [host, realm]  = PromptUtils.getAuthTarget(channel, authInfo);\n        let credentials = {\n            username:       username,\n            password:       password\n        };\n\n        let ok = this._slimerPromptUsernameAndPassword(channel.URI.spec, authInfo, credentials, realm);\n        if (ok) {\n            if (checkValue) {\n                checkValue.value = false;\n            }\n            PromptUtils.setAuthInfo(authInfo, credentials.username, credentials.password);\n        }\n        return ok;\n    },\n\n    asyncPromptAuth : function (channel, callback, context, level, authInfo, checkLabel, checkValue) {\n        // Nothing calls this directly; netwerk ends up going through\n        // nsIPromptService::GetPrompt, which delegates to login manager.\n        // Login manger handles the async bits itself, and only calls out\n        // promptAuth, never asyncPromptAuth.\n        //\n        // Bug 565582 will change this.\n        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n    },\n\n    _slimerPromptUsernameAndPassword : function (url, authInfo, credentials, realm) {\n        if (authInfo.flags & Ci.nsIAuthInformation.AUTH_PROXY) {\n            if (slConfiguration.proxyType == 'http' || slConfiguration.proxyType == 'socks5'\n                || slConfiguration.proxyType == 'socks') {\n//FIXME : check number of attempts\n                credentials.username = slConfiguration.proxyAuthUser;\n                credentials.password = slConfiguration.proxyAuthPassword;\n                return true;\n            }\n            return false;\n        }\n        let webpage;\n        let browser = slUtils.getBrowserFromContentWindow(this.domWin);\n        if (browser) {\n            webpage = browser.webpage;\n        }\n        if (!webpage) {\n            return false;\n        }\n\n        let onlyPassword = (authInfo.flags & Ci.nsIAuthInformation.ONLY_PASSWORD);\n        if (authInfo.flags & Ci.nsIAuthInformation.PREVIOUS_FAILED) {\n            browser.authAttempts ++;\n            let max = (webpage.settings.maxAuthAttempts === undefined?3:webpage.settings.maxAuthAttempts);\n            if (browser.authAttempts >= max) {\n                return false;\n            }\n        }\n        if (onlyPassword\n            && webpage.settings.password != ''\n            && webpage.settings.password != null\n            && webpage.settings.password != undefined\n            ) {\n            credentials.password = webpage.settings.password;\n        }\n        else if (!onlyPassword\n                 && webpage.settings.userName != ''\n                 && webpage.settings.userName != null\n                 && webpage.settings.userName != undefined \n                 && webpage.settings.password != ''\n                 && webpage.settings.password != null\n                 && webpage.settings.password != undefined\n                 ) {\n            credentials.username = webpage.settings.userName;\n            credentials.password = webpage.settings.password;\n        }\n        else if (webpage.onAuthPrompt) {\n            let type = (authInfo.flags & Ci.nsIAuthInformation.AUTH_PROXY? 'proxy': 'http');\n            return webpage.onAuthPrompt(type, url, realm, credentials);\n        }\n        return true;\n    },\n\n    /* ----------  nsIWritablePropertyBag2 ---------- */\n\n    // Only a partial implementation, for one specific use case...\n\n    setPropertyAsBool : function(name, value) {\n        if (name == \"allowTabModal\")\n            this.allowTabModal = value;\n        else\n            throw Cr.NS_ERROR_ILLEGAL_VALUE;\n    },\n};\n\n\nfunction AuthPromptAdapterFactory() {\n}\nAuthPromptAdapterFactory.prototype = {\n    classID          : Components.ID(\"{d49b3b06-afc2-4f72-9f9e-baffae1a4d8c}\"),\n    QueryInterface   : XPCOMUtils.generateQI([Ci.nsIAuthPromptAdapterFactory]),\n\n    /* ----------  nsIAuthPromptAdapterFactory ---------- */\n\n    createAdapter : function (oldPrompter) {\n        return new AuthPromptAdapter(oldPrompter);\n    }\n};\n\n\n// Takes an nsIAuthPrompt implementation, wraps it with a nsIAuthPrompt2 shell.\nfunction AuthPromptAdapter(oldPrompter) {\n    this.oldPrompter = oldPrompter;\n}\nAuthPromptAdapter.prototype = {\n    QueryInterface : XPCOMUtils.generateQI([Ci.nsIAuthPrompt2]),\n    oldPrompter    : null,\n\n    /* ----------  nsIAuthPrompt2 ---------- */\n\n    promptAuth : function (channel, level, authInfo, checkLabel, checkValue) {\n        let message = PromptUtils.makeAuthMessage(channel, authInfo);\n\n        let [username, password] = PromptUtils.getAuthInfo(authInfo);\n        let userParam = { value: username };\n        let passParam = { value: password };\n\n        let [host, realm]  = PromptUtils.getAuthTarget(channel, authInfo);\n        let authTarget = host + \" (\" + realm + \")\";\n\n        let ok;\n        if (authInfo.flags & Ci.nsIAuthInformation.ONLY_PASSWORD)\n            ok = this.oldPrompter.promptPassword(null, message, authTarget, Ci.nsIAuthPrompt.SAVE_PASSWORD_PERMANENTLY, passParam);\n        else\n            ok = this.oldPrompter.promptUsernameAndPassword(null, message, authTarget, Ci.nsIAuthPrompt.SAVE_PASSWORD_PERMANENTLY, userParam, passParam);\n\n        if (ok)\n            PromptUtils.setAuthInfo(authInfo, userParam.value, passParam.value);\n        return ok;\n    },\n\n    asyncPromptAuth : function (channel, callback, context, level, authInfo, checkLabel, checkValue) {\n        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n    }\n};\n\n\n// Wrapper using the old embedding contractID, since it's already common in\n// the addon ecosystem.\nfunction EmbedPrompter() {\n}\nEmbedPrompter.prototype = new Prompter();\nEmbedPrompter.prototype.classID          = Components.ID(\"{5598347d-7573-47b9-ae3c-a9c4e3f0e56b}\");\n\nvar component = [Prompter, EmbedPrompter, AuthPromptAdapterFactory];\nthis.NSGetFactory = XPCOMUtils.generateNSGetFactory(component);\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/components/SiteSpecificUserAgent.js":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst Cu = Components.utils;\nconst Cc = Components.classes;\nconst Ci = Components.interfaces;\n\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nCu.import(\"resource://gre/modules/UserAgentOverrides.jsm\");\nCu.import(\"resource://slimerjs/slUtils.jsm\");\n\nconst HTTP_PROTO_HANDLER = Cc[\"@mozilla.org/network/protocol;1?name=http\"]\n                             .getService(Ci.nsIHttpProtocolHandler);\n\nfunction SiteSpecificUserAgent() {}\n\nSiteSpecificUserAgent.prototype = {\n    // GECKO 22+\n  getUserAgentForURIAndWindow: function ssua_getUserAgentForURIAndWindow(aURI, aWindow) {    \n    let webpage = slUtils.getWebpageFromContentWindow(aWindow);\n    if (webpage && 'userAgent' in webpage.settings && webpage.settings.userAgent) {\n        return webpage.settings.userAgent;\n    }\n    else {\n        return UserAgentOverrides.getOverrideForURI(aURI) || HTTP_PROTO_HANDLER.userAgent;\n    }\n  },\n\n  //  GECKO < 22\n  getUserAgentForURI: function ssua_getUserAgentForURI(aURI) {\n    let webpage = slUtils.getWebpageFromURI(aURI);\n    if (webpage && 'userAgent' in webpage.settings && webpage.settings.userAgent) {\n        return webpage.settings.userAgent;\n    }\n    else {\n        return UserAgentOverrides.getOverrideForURI(aURI) || HTTP_PROTO_HANDLER.userAgent;\n    }\n  },\n\n  classID: Components.ID(\"{7602b9c0-6413-4769-893b-271245785445}\"),\n  QueryInterface: XPCOMUtils.generateQI([Ci.nsISiteSpecificUserAgent])\n};\n\nthis.NSGetFactory = XPCOMUtils.generateNSGetFactory([SiteSpecificUserAgent]);\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/defaults/preferences/debug.js":"pref(\"nglayout.debug.disable_xul_cache\", true);\npref(\"nglayout.debug.disable_xul_fastload\", true);\npref(\"javascript.options.strict.debug\", true);","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/defaults/preferences/prefs.js":"\npref(\"toolkit.defaultChromeURI\", \"chrome://slimerjs/content/slimerjs.xul\");\npref(\"browser.dom.window.dump.enabled\", true);\npref(\"javascript.options.strict\", true);\npref(\"browser.cache.disk.enable\", false);\npref(\"app.update.enabled\", false);\npref(\"extensions.update.enabled\", false);\npref(\"dom.report_all_js_exceptions\", true);\n\npref(\"browser.fixup.alternate.enabled\", false);\n\n// enable long running script callback on pages\npref(\"dom.max_script_run_time\", 10);\n\n// disable warnings about long chrome script run time\npref(\"dom.max_chrome_script_run_time\", 0);\n\n// for xulrunner, to display error pages instead of alert box\npref(\"browser.xul.error_pages.enabled\", true);\n\n// disable popup blocker\npref(\"dom.disable_open_during_load\", false);\npref(\"dom.popup_maximum\", -1);\n\n// says how to open new window when window.open is called\npref(\"browser.link.open_newwindow\", 3);\npref(\"browser.link.open_newwindow.restriction\", 0);\npref(\"browser.link.open_external\", 1);\n\npref(\"dom.allow_scripts_to_close_windows\", true);\n\n// deprecated since Gecko 50\npref(\"dom.mozTCPSocket.enabled\", true);\n\n//Enable plugin crash protection\n//http://kb.mozillazine.org/Plugin-container_and_out-of-process_plugins\npref('dom.ipc.plugins.enabled', true);\n\npref('security.tls.version.min', 1); // no SSLv3 support\n\npref('extensions.defaultProviders.enabled', false);\n\n// Disable Telemetry.\npref(\"datareporting.healthreport.service.enabled\", false);\npref(\"datareporting.healthreport.uploadEnabled\", false);\npref(\"datareporting.policy.dataSubmissionEnabled\", false);\npref(\"toolkit.telemetry.unified\", false);\n\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/modules/hello/people.js":"console.log(\"and people\");\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/modules/hello/world.js":"\n\nconsole.log(\"hello world\");\nrequire('./people');\nslimer.exit()\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/modules/slimer-sdk/bootstrap.js":"\nif (slimer.hasFeature('coffeescript')) {\n    // load the coffee-script module so it can register .coffee extensions\n    require('@coffee-script/coffee-script');\n}\n\nvar fs = require('fs');\n\nfs.readFileSync = function(path, encoding) {\n    return fs.read(path);\n}\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/modules/slimer-sdk/path.js":"\n// Just a stub for the path module needed by CoffeeScript\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/modules/slimer-sdk/system.js":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\nconst { Cc, Ci, Cu, Cr } = require('chrome');\n\nvar fs = require('fs');\n\nCu.import('resource://slimerjs/slConfiguration.jsm');\nCu.import(\"resource://gre/modules/Services.jsm\");\n\nvar xulRuntime = Cc[\"@mozilla.org/xre/app-info;1\"]\n                 .getService(Ci.nsIXULRuntime);\n\nvar httphandler =  Cc[\"@mozilla.org/network/protocol;1?name=http\"]\n                    .getService(Ci.nsIHttpProtocolHandler);\n\nvar oscpu = httphandler.oscpu;\n\nvar _isWindows = false;\n\nvar OS = {\n    architecture: '32bit',\n    name: xulRuntime.OS.toLowerCase(),\n    version: '',\n    isWindows : () => _isWindows\n};\n\nif (OS.name == 'linux') {\n    if (oscpu.indexOf('64') != -1) {\n        OS.architecture = '64bit';\n    }\n}\nelse if (/Mac/i.test(oscpu)) {\n    if (oscpu.indexOf('PPC') != -1)\n        OS.architecture = 'ppc';\n    else\n        OS.architecture = '64bit';\n\n    OS.version = /([0-9\\.ba]+)$/i.exec(oscpu)[1];\n}\nelse if (/windows/i.test(oscpu)) {\n    if (oscpu.indexOf('64') != -1) {\n        OS.architecture = '64bit';\n    }\n    OS.version = /(\\d+\\.\\d+)/.exec(oscpu)[1];\n\n    switch (OS.version) { // matches values in Phantomjs\n        case \"4.0\":\n        case \"3.5\":\n        case \"3.51\":\n            OS.version = \"NT\"; break;\n        case \"5.0\":\n            OS.version = \"2000\"; break;\n        case \"5.1\":\n            OS.version = \"XP\"; break;\n        case \"5.2\":\n            OS.version = \"2003\"; break;\n        case \"6.0\":\n            OS.version = \"Vista\"; break;\n        case \"6.1\":\n            OS.version = \"7\"; break;\n        case \"6.2\":\n            OS.version = \"8\"; break;\n        case \"6.3\":\n            OS.version = \"8.1\"; break;\n        case \"10.0\":\n            OS.version = \"10\"; break;\n    }\n    _isWindows = true;\n}\n\nvar envService = Cc[\"@mozilla.org/process/environment;1\"].\n          getService(Ci.nsIEnvironment);\nvar environment;\n\n// we use a Proxy object to access to environment variable\n// so we can get and set any environment variable, even those which don't exist yet\nvar environmentHandler = {\n    has : function (obj, prop) {\n        return envService.exists(prop);\n    },\n    get : function (obj, prop) {\n        if (envService.exists(prop))\n            return envService.get(prop);\n        return \"\";\n    },\n    set : function (obj, prop, value) {\n        if (!envService.exists(prop))\n            slConfiguration.envs.push(prop);\n        return envService.set(prop, value);\n    },\n    ownKeys : function(obj) {\n        return slConfiguration.envs;\n    },\n    getOwnPropertyDescriptor: function(target, prop) {\n        if (!envService.exists(prop))\n            return undefined;\n        return {\n            value: envService.get(prop),\n            enumerable: true,\n            configurable: true,\n            writable: true\n        }\n    },\n    defineProperty: function(prop, { value }){\n        if (!envService.exists(prop)) {\n            slConfiguration.envs.push(prop);\n        }\n        envService.set(prop, value);\n    },\n\n    \n    // obsolete properties since Firefox 33\n\n    hasOwn : function (obj, prop) {\n        return envService.exists(prop);\n    },\n    getOwnPropertyNames : function(obj) {\n        return slConfiguration.envs;\n    },\n    keys : function(obj) {\n        return slConfiguration.envs;\n    },\n\n    // obsolete? Not defined in Proxy spec\n    getPropertyDescriptor: function(prop) {\n        return this.getOwnPropertyDescriptor(prop)\n    },\n    getPropertyNames : function(obj) {\n        return slConfiguration.envs;\n    },\n    enumerate : function(obj) {\n        return slConfiguration.envs;\n    },\n    iterate : function(obj) {\n        var props = slConfiguration.envs, i = 0;\n        return {\n            next: function() {\n            if (i === props.length) throw StopIteration;\n                return props[i++];\n            }\n        };\n    },\n\n}\nenvironment = new Proxy({}, environmentHandler);\n\nObject.defineProperty(exports, 'os', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        return OS;\n    }\n});\n\nObject.defineProperty(exports, 'pid', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        //Cu.reportError(\"system.pid not implemented\");\n        return 0;  // no Mozilla API to retrieve the PID :-/\n    }\n});\n\nObject.defineProperty(exports, 'platform', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        return \"slimerjs\";\n    }\n});\n\nObject.defineProperty(exports, 'env', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        return environment;\n    }\n});\n\nObject.defineProperty(exports, 'args', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        return slConfiguration.args;\n    }\n});\n\nvar stdout = null;\nvar stderr = null;\nvar stdin = null;\n\nvar currentEncoding = '';\n\nfunction getOutput(file, stream) {\n    if (_isWindows) {\n        return {\n            write: dump,\n            writeLine: function (data) {\n                dump(data + '\\n');\n            }\n        }\n    }\n    if (stream) {\n        if (currentEncoding == slConfiguration.outputEncoding) {\n            return stream;\n        }\n        stream.close();\n    }\n    currentEncoding = slConfiguration.outputEncoding;\n    if (currentEncoding == 'binary') {\n        stream = fs.open(file, { mode:'bw'});\n    }\n    else {\n        stream = fs.open(file,\n                         { mode:'w',\n                           charset:currentEncoding,\n                           nobuffer:true});\n    }\n    return stream;\n}\n\nObject.defineProperty(exports, 'stdout', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        stdout = getOutput('/dev/stdout', stdout);\n        return stdout;\n    }\n});\n\nObject.defineProperty(exports, 'stderr', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        stderr = getOutput('/dev/stderr', stderr);\n        return stderr;\n    }\n});\n\nObject.defineProperty(exports, 'stdin', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        if (_isWindows) {\n            throw Error(\"system.stdin is not supported on Windows\")\n        }\n        if (!stdin) {\n            // it fails if we open with \"rb\" mode\n            stdin = fs.open('/dev/stdin', 'rb');\n        }\n        return stdin;\n    }\n});\n\nObject.defineProperty(exports, 'standardout', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        stdout = getOutput('/dev/stdout', stdout);\n        return stdout;\n    }\n});\n\nObject.defineProperty(exports, 'standarderr', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        stderr = getOutput('/dev/stderr', stderr);\n        return stderr;\n    }\n});\n\nObject.defineProperty(exports, 'standardin', {\n    enumerable: true,\n    writeable: false,\n    get: function() {\n        if (_isWindows) {\n            throw Error(\"system.standardin is not supported on Windows\")\n        }\n        if (!stdin) {\n            // it fails if we open with \"rb\" mode\n            stdin = fs.open('/dev/stdin', 'rb');\n        }\n        return stdin;\n    }\n});\n\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/modules/slimer-sdk/vm.js":"\n// Just a stub for the vm module needed by CoffeeScript\n\n/*\nconst { Cc, Ci, Cu, Cr } = require('chrome');\n\nfunction createSandbox(proto) {\n    var options = {\n        sandboxName: options.name,\n        sandboxPrototype: proto,\n        wantXHRConstructor: false,\n        wantComponents: false,\n        wantXrays: true,\n    };\n\n  let sandbox = Cu.Sandbox(options.principal, options);\n\n  delete sandbox.Iterator;\n  delete sandbox.Components;\n  delete sandbox.importFunction;\n  delete sandbox.debug;\n\n  return sandbox;\n}\n\n*/\n","/home/travis/build/npmtest/node-npmtest-slimerjs/node_modules/slimerjs/src/modules/slimer-sdk/webpage.js":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nconst { Cc, Ci, Cu, Cr } = require('chrome');\nCu.import('resource://slimerjs/slLauncher.jsm');\nCu.import('resource://slimerjs/slUtils.jsm');\nCu.import('resource://slimerjs/slConsole.jsm');\nCu.import('resource://slimerjs/slConfiguration.jsm');\nCu.import('resource://slimerjs/slimer-sdk/phantom.jsm');\nCu.import(\"resource://gre/modules/Services.jsm\");\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\nCu.import('resource://slimerjs/slPhantomJSKeyCode.jsm');\nCu.import('resource://slimerjs/slQTKeyCodeToDOMCode.jsm');\nCu.import('resource://slimerjs/webpageUtils.jsm');\nCu.import('resource://slimerjs/slCookiesManager.jsm');\nCu.import('resource://slimerjs/slDebug.jsm');\n\n\n\nconst de = Ci.nsIDocumentEncoder\nconst {validateOptions} = require(\"sdk/deprecated/api-utils\");\n\nconst fs = require(\"sdk/io/file\");\nconst base64 = require(\"sdk/base64\");\nconst Q = require(\"sdk/core/promise\");\nconst heritage = require(\"sdk/core/heritage\");\nconst systemPrincipal = Cc['@mozilla.org/systemprincipal;1']\n                        .createInstance(Ci.nsIPrincipal);\nconst netLog = require('net-log');\nnetLog.startTracer();\n\n/**\n * create a webpage object\n * @module webpage\n */\nfunction create() {\n    let [webpage, win] = _create(null);\n    return webpage;\n}\nexports.create = create;\n\n/**\n * @return [webpage, window]\n */\nfunction _create(parentWebpageInfo) {\n\n    // -----------------------  private properties and functions for the webpage object\n\n    /**\n     * the <browser> element loading the webpage content\n     */\n    var browser = null;\n\n    var browserJustCreated = true;\n    /**\n     * library path\n     */\n    var libPath = (slConfiguration.scriptFile ? slConfiguration.scriptFile.parent.clone(): null);\n\n    /**\n     * utility function to create a sandbox when executing a\n     * user script in the webpage content\n     */\n    function createSandBox(win) {\n        let sandbox = Cu.Sandbox(win,\n            {\n                'principal':systemPrincipal,\n                'sandboxName': browser.currentURI.spec,\n                'sandboxPrototype': win,\n                'wantXrays': false\n            });\n        return sandbox;\n    }\n\n    var webPageSandbox = null;\n\n    /**\n     * evaluate javascript code into a sandbox\n     * @see webpage.evaluate(), webpage.evaluateJavascript()...\n     * @param string src the source code to evaluate\n     * @param string file the file name associated to the source code\n     */\n    function evalInSandbox (src, file) {\n        if (!webPageSandbox) {\n            webPageSandbox = new WeakMap();\n        }\n        let win = getCurrentFrame();\n        if (!webPageSandbox.has(win)) {\n            webPageSandbox.set(win, createSandBox(win));\n        }\n        try {\n            let res = Cu.evalInSandbox(src, webPageSandbox.get(win), 'ECMAv5', file, 1);\n            // QWebFrame.evaluateJavascript() used by PhantomJS\n            // always returns null when no value are returned by\n            // the script.\n            if (res === undefined) {\n                return null;\n            }\n            return res;\n        }\n        catch(e) {\n            if (webpage.onError) {\n                let [msg, stackRes] = getTraceException(e, '');\n                executePageListener(webpage, 'onError', ['Error: '+msg, stackRes]);\n                return null;\n            }\n            else {\n                throw new Error('Error during javascript evaluation in the web page: '+e)\n            }\n        }\n    }\n\n    /**\n     * an observer for the Observer Service.\n     * It observes console events.\n     */\n    var webpageObserver = {\n        QueryInterface: XPCOMUtils.generateQI([Ci.nsISupportsWeakReference,Ci.nsIObserver]),\n\n        observe: function webpageobserver_observe(aSubject, aTopic, aData) {\n            if (aTopic == \"console-api-log-event\") {\n                if (!webpage.onConsoleMessage)\n                    return;\n                // aData == outer window id\n                // aSubject == console event object. see http://mxr.mozilla.org/mozilla-central/source/devtools/shared/Console.jsm#526\n                var consoleEvent = aSubject.wrappedJSObject;\n                if (webpageUtils.isOurWindow(browser, aData)) {\n                    var args = consoleEvent.arguments;\n                    if (!Array.isArray(args)) {\n                        args = Array.prototype.slice.call(args);\n                    }\n                    executePageListener(webpage, 'onConsoleMessage', [\n                        args.join(' '),\n                        consoleEvent.lineNumber,\n                        consoleEvent.filename,\n                        consoleEvent.level,\n                        consoleEvent.functionName,\n                        consoleEvent.timeStamp]);\n                    return\n                }\n                return;\n            }\n        }\n    }\n\n    /**\n     * a listener for the console service, to track errors in the content window.\n     */\n    var jsErrorListener = {\n        observe:function( aMessage ){\n            //dump(\" ************** jsErrorListener\\n\");\n            if (!webpage.onError)\n                return;\n            try {\n                let msg = aMessage.QueryInterface(Ci.nsIScriptError);\n                /*dump(\" on error:\"+msg.errorMessage+\n                     \"(\"+msg.category+\") f:\"+msg.flags\n                     +\" ow:\"+msg.outerWindowID\n                     +\" is:\"+webpageUtils.isOurWindow(browser, msg.outerWindowID)+\"\\n\")*/\n                let frameUrl = webpageUtils.isOurWindow(browser, msg.outerWindowID);\n                if (msg instanceof Ci.nsIScriptError\n                    && !(msg.flags & Ci.nsIScriptError.warningFlag)\n                    && msg.outerWindowID\n                    && frameUrl\n                    && msg.category == \"content javascript\"\n                    ) {\n                    let [m, stack] = getTraceException(msg, null);\n                    webpage.onError(msg.errorMessage, stack);\n                }\n            }\n            catch(e) {\n                //dump(\"**************** jsErrorListener err:\"+e+\"\\n\")\n            }\n        },\n        QueryInterface: function (iid) {\n            if (!iid.equals(Ci.nsIConsoleListener) &&\n                !iid.equals(Ci.nsISupports)) {\n                throw Cr.NS_ERROR_NO_INTERFACE;\n            }\n            return this;\n        }\n    };\n\n    /**\n     * build an object of options for the netlogger\n     */\n    function getNetLoggerOptions(webpage, deferred, firstRequestHeaders) {\n        var wycywigReg = /^wyciwyg:\\/\\//;\n        var firstRequestHeadersUsed = false;\n        return {\n            _onRequest: function(request) {\n                request = request.QueryInterface(Ci.nsIHttpChannel);\n                if (webpage.settings.userAgent)\n                    request.setRequestHeader(\"User-Agent\", webpage.settings.userAgent, false);\n                let h;\n                if (firstRequestHeadersUsed) {\n                    h = webpage.customHeaders;\n                }\n                else {\n                    h = firstRequestHeaders;\n                    firstRequestHeadersUsed = true;\n                }\n                for (var hname in h) {\n                    request.setRequestHeader(hname, h[hname], false);\n                }\n            },\n            onRequest: function(requestData, request) {\n                webpage.resourceRequested(requestData, request);\n            },\n            onResponse:  function(res) {\n                webpage.resourceReceived(res);\n            },\n            onTimeout : function(res) {\n                webpage.resourceTimeout(res);\n            },\n            onError:  function(err) {\n                webpage.resourceError(err);\n            },\n            getCaptureTypes: function() {\n                return webpage.captureContent;\n            },\n            onLoadStarted: function(url){\n                if (wycywigReg.test(url)) {\n                    return;\n                }\n                webpage.loadStarted(url, false);\n            },\n            onURLChanged: function(url){\n                if (wycywigReg.test(url)) {\n                    return;\n                }\n                webpage.urlChanged(url);\n            },\n            onTransferStarted :null,\n            onContentLoaded: function(url, success){\n                if (wycywigReg.test(url)) {\n                    return;\n                }\n                try {\n                    Services.console.unregisterListener(jsErrorListener);\n                }catch(e){}\n\n                Services.console.registerListener(jsErrorListener);\n                // phantomjs call onInitialized not only at the page creation\n                // but also after the content loading.. don't know why.\n                // let's imitate it. Only after a success\n                if (success) {\n                    webpage.initialized();\n                }\n            },\n            onLoadFinished: function(url, success){\n                if (wycywigReg.test(url)) {\n                    return;\n                }\n                webpage.loadFinished(success, url, false);\n                if (privProp.staticContentLoading) {\n                    privProp.staticContentLoading = false;\n                }\n                if (deferred)\n                    deferred.resolve(success);\n            },\n            onFrameLoadStarted : function(url, duringMainLoad) {\n                if (wycywigReg.test(url)) {\n                    return;\n                }\n                if (!duringMainLoad)\n                    webpage.loadStarted(url, true)\n            },\n            onFrameLoadFinished : function(url, success, frameWindow, duringMainLoad) {\n                if (wycywigReg.test(url)) {\n                    return;\n                }\n                if (!duringMainLoad)\n                    webpage.loadFinished(success, url, true);\n            }\n        }\n    }\n\n    /**\n     * object that intercepts all window.open() of the web content\n     */\n    var slBrowserDOMWindow = {\n\n        QueryInterface : function(aIID) {\n            if (aIID.equals(Ci.nsIBrowserDOMWindow) ||\n                aIID.equals(Ci.nsISupports))\n                return this;\n            throw Cr.NS_NOINTERFACE;\n        },\n\n        /**\n         * called by nsContentTreeOwner::ProvideWindow\n         * when a window should be opened (window.open is invoked by a web page)\n         * @param aURI in our case, it is always null\n         * @param aWhere nsIBDW.OPEN_DEFAULTWINDOW, OPEN_CURRENTWINDOW OPEN_NEWWINDOW OPEN_NEWTAB OPEN_SWITCHTAB\n         * @param aContext nsIBDW.OPEN_EXTERNAL (external app which ask to open the url), OPEN_NEW\n         * @return the nsIDOMWindow object where to load the URI\n         */\n        openURI : function(aURI, aOpener, aWhere, aContext)\n        {\n            // create the webpage object for this child window\n            let opener = (webpage.ownsPages?aOpener:null);\n            let parentWPInfo = null;\n            let childPage, win;\n            if (webpage.ownsPages) {\n                parentWPInfo = {\n                    window: opener,\n                    detachChild:function(child){\n                        let idx = privProp.childWindows.indexOf(child);\n                        if (idx != -1) {\n                            privProp.childWindows.splice(0,1);\n                        }\n                    }\n                }\n            }\n            [childPage, win] = _create(parentWPInfo);\n\n            if (webpage.ownsPages) {\n                privProp.childWindows.push(childPage);\n            }\n\n            // call the callback\n            webpage.rawPageCreated(childPage);\n\n            // returns the contentWindow of the browser element\n            // nsContentTreeOwner::ProvideWindow and other will\n            // load the expected URI into it.\n            return win.content;\n        },\n\n        openURIInFrame : function(aURI, aOpener, aWhere, aContext) {\n            return null;\n        },\n\n        isTabContentWindow : function(aWindow) {\n            return false;\n        }\n    }\n\n    /**\n     * some private parameters\n     */\n    var privProp = {\n        clipRect : null,\n        framePath : [],\n        childWindows : [], // list of webpage of child windows\n        settings: {},\n        viewportSize : {},\n        staticContentLoading : false,\n        paperSize : null\n    }\n\n    let defaultViewportSize = slConfiguration.getDefaultViewportSize();\n    privProp.viewportSize.width = defaultViewportSize.width;\n    privProp.viewportSize.height = defaultViewportSize.height;\n\n    let defaultSettings = slConfiguration.getDefaultWebpageConfig();\n    for (let p in defaultSettings) {\n        privProp.settings[p] = defaultSettings[p]\n    }\n\n    function getCurrentFrame() {\n        if (!browser)\n            return null;\n        var win = browser.contentWindow;\n        win.name = ''; // it seems that the root window take the name of the xul window\n        privProp.framePath.forEach(function(frameName){\n            if (win == null)\n                return;\n            if ((typeof frameName) == 'number') {\n                if (frameName < win.frames.length) {\n                    win = win.frames[frameName];\n                }\n                else\n                    win = null;\n            }\n            else if ((typeof frameName) == 'string') {\n                let found = false;\n                for(let i=0; i < win.frames.length; i++) {\n                    if (win.frames[i].name == frameName) {\n                        win = win.frames[i];\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    win = null;\n                }\n            }\n            else\n                win = null;\n        });\n        return win;\n    }\n\n    /**\n     *  @return array 0:the webpage object, 1:the chrome window\n     */\n    function openBlankBrowser(noInitializedEvent) {\n        let options = getNetLoggerOptions(webpage, null, webpage.customHeaders);\n        let ready = false;\n        let parentWindow = (parentWebpageInfo?parentWebpageInfo.window:null);\n        let win = slLauncher.openBrowser(function(nav){\n            browser = nav;\n            browser.webpage = webpage;\n            browserJustCreated = true;\n            browser.authAttempts = 0;\n            Services.obs.addObserver(webpageObserver, \"console-api-log-event\", true);\n            netLog.registerBrowser(browser, options);\n            if (!noInitializedEvent)\n                webpage.initialized();\n            ready = true;\n        }, parentWindow, privProp.viewportSize);\n\n        win.QueryInterface(Ci.nsIDOMChromeWindow)\n           .browserDOMWindow = slBrowserDOMWindow;\n\n        // we're waiting synchronously after the initialisation of the new window, because we need\n        // to have a ready browser element and then to have an existing win.content.\n        // slBrowserDOMWindow.openURI needs to return this win.content so the\n        // caller will load the URI into this window object.\n        let thread = Services.tm.currentThread;\n        while (!ready)\n            thread.processNextEvent(true);\n\n        return [webpage, win];\n    }\n\n    function prepareJSEval(func, args) {\n\n        if (!(func instanceof Function\n              || typeof func === 'function'\n              || typeof func === 'string'\n              || func instanceof String)) {\n            return false;\n        }\n\n        let argsList = args.map(\n            function(arg){\n                  let type = typeof arg;\n                  switch(type) {\n                      case 'object':\n                          if (!arg || arg instanceof RegExp) {\n                              return \"\"+arg;\n                          }\n                      case 'array':\n                      case 'string':\n                          return JSON.stringify(arg);\n                      case \"date\":\n                          return \"new Date(\" + JSON.stringify(arg) + \")\";\n                      default:\n                          return \"\"+arg\n                  }\n            });\n\n        return '('+func.toString()+').apply(this, [' + argsList.join(\",\") + ']);';\n    }\n\n    // ----------------------------------- webpage\n\n    /**\n     * the webpage object itself\n     * @module webpage\n     */\n    var webpage = {\n\n        /**\n         * toString on a webpage object indicates\n         * qtruntimeobject in PhantomJS.\n         * here is an alternate way to know if the\n         * object is a webpage object\n         */\n        __type : 'qtruntimeobject',\n\n        get objectName () {\n            return \"WebPage\";\n        },\n\n        /**\n          Object containing various settings of the web page\n\n            - javascriptEnabled: false if scripts of the page should not be executed (defaults to true).\n            - loadImages: false to not load images (defaults to true).\n            - localToRemoteUrlAccessEnabled: defines whether local resource (e.g. from file) can access remote URLs or not (defaults to false).\n            - userAgent defines the user agent sent to server when the web page requests resources.\n            - userName sets the user name used for HTTP authentication.\n            - password sets the password used for HTTP authentication.\n            - XSSAuditingEnabled defines whether load requests should be monitored for cross-site scripting attempts (defaults to false).\n            - webSecurityEnabled defines whether web security should be enabled or not (defaults to true).\n            - maxAuthAttempts: integer\n            - resourceTimeout: integer, in milliseconds. warning, it is converted into seconds\n            - javascriptCanOpenWindows\n            - javascriptCanCloseWindows\n            Note: The settings apply only during the initial call to the WebPage#open function. Subsequent modification of the settings object will not have any impact.\n         */\n        get settings (){\n            return privProp.settings;\n        },\n\n        set settings (val){\n            privProp.settings = heritage.mix(privProp.settings, val);\n        },\n\n        /**\n         * list of regexp matching content types\n         * of resources for which you want to retrieve the content.\n         * The content is then set on the body property of the response\n         * object received by your onResourceReceived callback\n         */\n        captureContent : [],\n\n        // ------------------------ cookies and headers\n\n        /**\n         * list of headers to set on every request for the webpage\n         */\n        customHeaders : {},\n\n        /**\n         * retrieve the list of cookies of the domain of the current url\n         * @return cookie[]\n         */\n        get cookies() {\n            if (!browser || browserJustCreated || !browser.currentURI)\n                return [];\n            return slCookiesManager.getCookiesForUri(browser.currentURI);\n        },\n\n        /**\n         * set a list of cookies for the domain of the web page\n         * @param cookie[] val\n         */\n        set cookies(val) {\n            if (!browser || browserJustCreated)\n                return;\n            slCookiesManager.setCookies(val, browser.currentURI);\n        },\n\n        /**\n         * add a cookie in the cookie manager for the current url\n         * @param cookie cookie\n         * @return boolean true if the cookie has been set\n         */\n        addCookie: function(cookie) {\n            if (!browser || browserJustCreated)\n                return false;\n            return slCookiesManager.addCookie(cookie, browser.currentURI);\n        },\n\n        /**\n         * erase all cookies of the current domain\n         */\n        clearCookies: function() {\n            if (browser && !browserJustCreated)\n                slCookiesManager.clearCookies(browser.currentURI);\n        },\n\n        /**\n         * delete all cookies that have the given name\n         * on the current domain\n         * @param string cookieName  the cookie name\n         * @return boolean true if deletion is ok\n         */\n        deleteCookie: function(cookieName) {\n            if (!browser || browserJustCreated)\n                return false;\n            return slCookiesManager.deleteCookie(cookieName, browser.currentURI);\n        },\n\n        // -------------------------------- History\n\n        get canGoBack () {\n            return browser.canGoBack;\n        },\n\n        get canGoForward () {\n            return browser.canGoForward;\n        },\n\n        go : function(indexIncrement) {\n            let h = browser.sessionHistory;\n            let index = h.index + indexIncrement;\n            if (index >= h.count || index < 0)\n                return;\n            browser.gotoIndex(index);\n        },\n\n        goBack : function() {\n            browser.goBack();\n        },\n\n        goForward : function() {\n            browser.goForward();\n        },\n\n        navigationLocked : false,\n\n        reload : function() {\n            browser.reload();\n        },\n\n        stop : function() {\n            browser.stop();\n        },\n\n        // -------------------------------- Window manipulation\n\n        /**\n         * Open a web page in a browser\n         *\n         * It can accept several arguments and only the first\n         * one is required:\n         *\n         * open(url)\n         * open(url, callback)\n         * open(url, httpConf)\n         * open(url, httpConf, callback)\n         * open(url, operation, data)\n         * open(url, operation, data, callback)\n         * open(url, operation, data, headers, callback)\n         *\n         * @param string url    the url of the page to open\n         * @param function callback  a function called when the page is loaded. it\n         *                           receives \"success\" or \"fail\" as parameter.\n         * @param string|object httpConf see httpConf arg of openUrl\n         * @param string operation\n         * @param string data\n         * @param object headers\n         */\n        open: function(url, arg1, arg2, arg3, arg4) {\n\n            switch(arguments.length) {\n                case 1:\n                    return this.openUrl(url, 'get');\n                    break;\n                case 2:\n                    if (typeof arg1 === 'function') {\n                        return this.openUrl(url, 'get', null, arg1);\n                    }\n                    else {\n                        return this.openUrl(url, arg1);\n                    }\n                    break;\n                case 3:\n                    if (typeof arg2 === 'function') {\n                        return this.openUrl(url, arg1, null, arg2);\n                    }\n                    else {\n                        return this.openUrl(url, {\n                            operation: arg1,\n                            data: arg2\n                        });\n                    }\n                    break;\n                case 4:\n                    return this.openUrl(url, {\n                            operation: arg1,\n                            data: arg2\n                        }, null, arg3);\n                    break;\n                case 5:\n                    return this.openUrl(url, {\n                            operation: arg1,\n                            data: arg2,\n                            headers: arg3\n                        }, null, arg4);\n                    break;\n            }\n            throw \"open: arguments are missing\";\n        },\n\n        /**\n         * open a webpage\n         * @param string url       the url of the page to load\n         * @param string httpConf  the http method 'get', 'post', 'head', 'post', 'delete'\n         * @param object httpConf  an object with two properties\n         *          operation: http method (default: get)\n         *          data: body of the request\n         *          headers: (optional)\n         *          encoding: (optional, default utf8)\n         * @param object settings  it replaces webpage.settings.\n         * @return void\n         */\n        openUrl: function(url, httpConf, settings, callback) {\n\n            if (settings) {\n                this.settings = settings;\n            }\n\n            if (!httpConf) {\n                httpConf = {\n                    operation: 'get',\n                }\n            }\n            else if (typeof httpConf == 'string') {\n                httpConf = {\n                    operation: httpConf,\n                }\n            }\n\n            var me = this;\n\n            // create a promise that we will return\n            let deferred = Q.defer();\n            deferred.promise.then(function(result) {\n                if (callback) {\n                    try {\n                        callback(result);\n                        callback = null;\n                    }\n                    catch(e) {\n                        slLauncher.showError(e);\n                    }\n                }\n                return result;\n            });\n\n            let options = getNetLoggerOptions(this, deferred, this.customHeaders);\n\n            let loadUri = function() {\n                netLog.registerBrowser(browser, options);\n                try {\n                    webpageUtils.browserLoadURI(browser, url, httpConf);\n                }\n                catch(e) {\n                    // we simulate PhantomJS behavior on url errors\n                    options.onLoadStarted('');\n                    options.onURLChanged('about:blank');\n                    if (e.message == 'NS_ERROR_UNKNOWN_PROTOCOL') {\n                        options.onRequest({\n                            id: 1,\n                            method: httpConf.operation,\n                            url: url,\n                            time: new Date(),\n                            headers: (('headers' in httpConf)?httpConf.headers:[])\n                            }, null\n                        );\n                        options.onError({id: 1,\n                            url: url,\n                            errorCode:301,\n                            errorString:\"Protocol is unknown\"\n                        });\n                        options.onResponse( {\n                            id: 1,\n                            url: url,\n                            time: new Date(),\n                            headers: [],\n                            bodySize: 0,\n                            contentType: null,\n                            contentCharset: null,\n                            redirectURL: null,\n                            stage: \"end\",\n                            status: null,\n                            statusText: null,\n                            // Extensions\n                            referrer: \"\",\n                            isFileDownloading : false,\n                            body: \"\"\n                        });\n                    }\n                    options.onLoadFinished(url, \"fail\");\n                }\n            }\n            \n            if (DEBUG_WEBPAGE)\n                slDebugLog(\"webpage: openUrl \"+url+\" conf:\"+slDebugGetObject(httpConf));\n\n            if (browser) {\n                if (browserJustCreated){\n                    webpage.initialized();\n                    browserJustCreated = false;\n                }\n                // don't recreate a browser if already opened.\n                loadUri();\n                return deferred.promise;\n            }\n\n            var win = slLauncher.openBrowser(function(nav){\n                browser = nav;\n                browser.webpage = me;\n                Services.obs.addObserver(webpageObserver, \"console-api-log-event\", true);\n                browser.stop();\n                me.initialized();\n                browserJustCreated = false;\n                browser.authAttempts = 0;\n                loadUri();\n            }, null, privProp.viewportSize);\n            // to catch window.open()\n            win.QueryInterface(Ci.nsIDOMChromeWindow)\n               .browserDOMWindow= slBrowserDOMWindow;\n            return deferred.promise;\n        },\n\n        /**\n         * close the browser\n         */\n        close: function() {\n            if (browser) {\n                browser.closing = true;\n                try {\n                    Services.console.unregisterListener(jsErrorListener);\n                }catch(e){}\n                try {\n                    Services.obs.removeObserver(webpageObserver, \"console-api-log-event\");\n                }catch(e){}\n                netLog.unregisterBrowser(browser);\n                this.closing(this);\n                slLauncher.closeBrowser(browser);\n                browser.webpage = null;\n                if (parentWebpageInfo) {\n                    parentWebpageInfo.detachChild(this);\n                }\n            }\n            webPageSandbox = null;\n            browser=null;\n            if (DEBUG_WEBPAGE)\n                slDebugLog(\"webpage: close\");\n        },\n\n        /**\n         * function called when the browser is being closed, during a call of WebPage.close()\n         * or during a call of window.close() inside the web page\n         */\n        onClosing: null,\n\n        /**\n         * This boolean indicates if pages opening by the webpage (by window.open())\n         * should be children of the webpage (true) or not (false). Default is true.\n         *\n         * If true, children pages can be retrieved by getPage(), pages, pagesWindowName\n         */\n        ownsPages : true,\n\n        /**\n         * Returns a Child Page that matches the given \"window.name\".\n         *\n         * @param string windowName\n         * @return webpage the found webpage\n         */\n        getPage: function (windowName) {\n            let pages = privProp.childWindows.filter(function(page){\n                if(page.windowName == windowName)\n                    return true;\n                return false;\n            });\n            if (pages.length)\n                return pages[0];\n            return null;\n        },\n\n        /**\n         * Returns a list of child pages that this page has currently opened\n         * with `window.open()`.\n         * If a child page is closed (by `window.close()` or by `webpage.close()`),\n         * the page is automatically removed from this list.\n         *\n         * You should not keep a strong reference to this array since you obtain\n         * only a copy, so you won't see changes.\n         *\n         * If \"ownsPages\" is \"false\", this list won't owns the child pages.\n         *\n         * @return array list of child pages currently opened.\n         */\n        get pages () {\n            return privProp.childWindows.filter(function(page){ return true;});\n        },\n\n        /**\n         * Returns a list of window name of child pages.\n         *\n         * The window name is the name given to `window.open()`.\n         *\n         * The list is only from child pages that have been created when\n         * ownsPages was true.\n         *\n         * @return array  list of strings\n         */\n        get pagesWindowName () {\n            return privProp.childWindows.map(function(page){ return page.windowName;});\n        },\n\n        release : function() {\n            this.close();\n        },\n\n        get scrollPosition() {\n            let pos = {top:0, left:0}\n            pos.top = browser.contentWindow.scrollY;\n            pos.left = browser.contentWindow.scrollX;\n            return pos;\n        },\n\n        set scrollPosition(val) {\n            let pos = heritage.mix({top:0, left:0}, val);\n            browser.contentWindow.scrollTo(pos.left, pos.top);\n        },\n\n        get url() {\n            if (browser && !browserJustCreated)\n                return browser.currentURI.spec;\n            return \"\";\n        },\n\n        get viewportSize() {\n            if (!browser)\n                return {\n                    width: privProp.viewportSize.width,\n                    height: privProp.viewportSize.height\n                };\n            let win = browser.ownerDocument.defaultView.top;\n            return {\n                width: win.innerWidth,\n                height: win.innerHeight\n            }\n        },\n\n        set viewportSize(val) {\n\n            if (typeof val != \"object\")\n                throw new Error(\"Bad argument type\");\n\n            val = heritage.mix({width:privProp.viewportSize.width,\n                               height:privProp.viewportSize.height}, val);\n            let w = val.width || privProp.viewportSize.width;\n            let h = val.height || privProp.viewportSize.height;\n\n            if (typeof w != \"number\") {\n                w = parseInt(w, 10);\n            }\n            if (typeof h != \"number\") {\n                h = parseInt(h, 10);\n            }\n            if (w < 0 || h < 0) {\n                return;\n            }\n\n            privProp.viewportSize.width = w;\n            privProp.viewportSize.height = h;\n\n            if (!browser)\n                return;\n\n            let win = browser.ownerDocument.defaultView.top;\n\n            let domWindowUtils = win.QueryInterface(Ci.nsIInterfaceRequestor)\n                                    .getInterface(Ci.nsIDOMWindowUtils);\n            if ('setCSSViewport' in domWindowUtils) {\n                domWindowUtils. setCSSViewport(w,h);\n            }\n            win.resizeTo(w,h);\n            domWindowUtils.redraw(1);\n        },\n\n        get windowName () {\n            if (!browser)\n                return null;\n            return browser.contentWindow.name;\n        },\n\n        // -------------------------------- frames manipulation\n\n        childFramesCount: function () {\n            return this.framesCount;\n        },\n\n        childFramesName : function () {\n            return this.framesName;\n        },\n\n        currentFrameName : function () {\n            return this.frameName;\n        },\n\n        get frameUrl() {\n            var win = getCurrentFrame();\n            if (!win){\n                return '';\n            }\n            return win.location.href;\n        },\n\n        get focusedFrameName () {\n            if (!browser) {\n                return '';\n            }\n            var win = webpageUtils.getFocusedWindow();\n            if (win && win.name && win.name != 'webpage')\n                return win.name;\n            return '';\n        },\n\n        get framesCount () {\n            var win = getCurrentFrame();\n            if (!win){\n                return 0;\n            }\n            return win.frames.length;\n        },\n\n        get frameName () {\n            var win = getCurrentFrame();\n            if (!win){\n                return false;\n            }\n            return win.name;\n        },\n\n        get framesName () {\n            var win = getCurrentFrame();\n            if (!win){\n                return [];\n            }\n            let l = [];\n            for(let i = 0; i < win.frames.length; i++) {\n                l.push(win.frames[i].name);\n            }\n            return l;\n        },\n\n        switchToFocusedFrame: function() {\n            if (!browser) {\n                return false;\n            }\n            var win = webpageUtils.getFocusedWindow();\n            if (!win)\n                return -1;\n            var l = [];\n            while(browser.contentWindow != win) {\n                if (win.name) {\n                    l.unshift(win.name)\n                }\n                else {\n                    let f = win.parent.frames;\n                    let found = false;\n                    for (let i=0; i < f.length;i++) {\n                        if (f[i] == win) {\n                            l.unshift(i);\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found)\n                        return -2;\n                }\n                win = win.parent;\n            }\n            privProp.framePath = l;\n            return true;\n        },\n\n        switchToFrame: function(frameName) {\n            privProp.framePath.push(frameName);\n            var win = getCurrentFrame();\n            if (!win){\n                privProp.framePath.pop();\n                return false;\n            }\n            return true;\n        },\n\n        switchToChildFrame: function(frame) {\n            return this.switchToFrame(frame);\n        },\n\n        switchToMainFrame: function() {\n            privProp.framePath = [];\n        },\n\n        switchToParentFrame: function() {\n            if (privProp.framePath.length) {\n                privProp.framePath.pop();\n                return true;\n            }\n            else\n                return false;\n        },\n\n        get frameContent() {\n            var win = getCurrentFrame();\n            if (!win){\n                return false;\n            }\n            return webpageUtils.getWindowContent(win, null, false);\n        },\n\n        set frameContent(val) {\n            var win = getCurrentFrame();\n            if (!win){\n                return;\n            }\n\n            let webNav = win.QueryInterface(Ci.nsIInterfaceRequestor)\n                            .getInterface(Ci.nsIWebNavigation);\n            let docShell = webNav.QueryInterface(Ci.nsIDocShell);\n\n            if ((typeof content) != \"string\") {\n                // for given DOM node, serialize it\n                let encoder = Cc[\"@mozilla.org/layout/documentEncoder;1?type=text/html\"]\n                                .createInstance(Ci.nsIDocumentEncoder);\n                encoder.init(document, \"text/html\", de.OutputLFLineBreak | de.OutputRaw);\n                encoder.setNode(content);\n                content = encoder.encodeToString();\n            }\n\n            privProp.staticContentLoading = true;\n            webpageUtils.setWindowContent (docShell, content, webNav.currentURI.clone());\n\n            // wait until the content is loaded\n            let thread = Services.tm.currentThread;\n            while (privProp.staticContentLoading)\n                thread.processNextEvent(true);\n        },\n\n        get framePlainText() {\n            var win = getCurrentFrame();\n            if (!win){\n                return false;\n            }\n\n            return webpageUtils.getWindowContent(win, null, true, privProp.settings.plainTextAllContent);\n        },\n\n        get frameTitle() {\n            var win = getCurrentFrame();\n            if (!win){\n                return '';\n            }\n            return win.document.title;\n        },\n\n        // -------------------------------- Javascript evaluation\n\n        /**\n         * Evaluate the given function into the context of the web page content\n         * \n         * @param function  func    the function to evaluate\n         * @param ...       args    arguments for the function\n         *\n         * FIXME: modifying a variable in a sandbox\n         * that inherits of the context of a window,\n         * does not propagate the modification into\n         * this context. We have same\n         * issue that https://bugzilla.mozilla.org/show_bug.cgi?id=783499\n         * the only solution is to do window.myvariable = something in the\n         * given function, instead of myvariable = something\n         * @see a solution used for the Firefox webconsole\n         * https://hg.mozilla.org/mozilla-central/rev/f5d6c95a9de9#l6.374\n         */\n        evaluate: function(func, ...args) {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n\n            let f = prepareJSEval(func, args);\n            if (f === false) {\n                throw new Error(\"Wrong use of WebPage#evaluate\");\n            }\n            return evalInSandbox(f, 'phantomjs://webpage.evaluate()');\n        },\n\n        evaluateJavaScript: function(src) {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n\n            return evalInSandbox(src, 'phantomjs://webpage.evaluateJavaScript()');\n        },\n\n        /**\n         * @param function  func  the function to evaluate\n         * @param integer   timeMs  time to wait before execution\n         * @param ...       args    other args are arguments for the function\n         */\n        evaluateAsync: function(func, timeMs, ...args) {\n            if (!browser) {\n                throw new Error(\"WebPage not opened\");\n            }\n\n            let f = prepareJSEval(func, args);\n            if (f === false) {\n                throw new Error(\"Wrong use of WebPage#evaluateAsync\");\n            }\n\n            if (timeMs == undefined) {\n                timeMs = 0;\n            }\n            browser.contentWindow.setTimeout(function() {\n                evalInSandbox(f, 'phantomjs://webpage.evaluateAsync()');\n            }, timeMs)\n        },\n\n        includeJs: function(url, callback) {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n            var win = getCurrentFrame();\n            if (!win){\n                throw new Error(\"No window available\");\n            }\n            webpageUtils.evalInWindow (win, null, url, callback);\n        },\n\n        get libraryPath () {\n            if (!libPath)\n                return \"\";\n            return libPath.path;\n        },\n\n        set libraryPath (path) {\n            libPath = slUtils.getMozFile(path);\n        },\n\n        /**\n         * FIXME: modifying a variable in a sandbox\n         * that inherits of the context of a window,\n         * does not propagate the modification into\n         * this context. We have same\n         * issue that https://bugzilla.mozilla.org/show_bug.cgi?id=783499\n         * the only solution is to do window.myvariable = something in the\n         * given function, instead of myvariable = something\n         */\n        injectJs: function(filename) {\n            if (!browser) {\n                throw new Error(\"WebPage not opened\");\n            }\n            let f = slUtils.getAbsMozFile(filename, slUtils.workingDirectory);\n            if (!f.exists()) {\n                // filename resolved against the libraryPath property\n                f = slUtils.getAbsMozFile(filename, libPath);\n                if (!f.exists()) {\n                    dump(\"Error injectJs: can't open '\"+filename+\"'\\n\");\n                    return false;\n                }\n            }\n            let source = slUtils.readSyncStringFromFile(f);\n            evalInSandbox(source, filename);\n            return true;\n        },\n\n        \n        /**\n         * Stop JavaScript within a onLongRunningScript callback.\n         * Called outside of onLongRunningScript it does nothing. \n         */\n        stopJavaScript : function stopJavaScript () {\n            stopJavaScript.__interrupt__ = true;\n        },\n        \n        onError : phantom.defaultErrorHandler,\n\n        // --------------------------------- content manipulation\n\n        get content () {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n\n            return webpageUtils.getWindowContent(browser.contentWindow,\n                                    browser.docShell, false);\n        },\n\n        set content(val) {\n            this.setContent(val, null);\n        },\n\n        get offlineStoragePath() {\n            return slConfiguration.offlineStoragePath;\n        },\n\n        get offlineStorageQuota() {\n            return slConfiguration.offlineStorageDefaultQuota;\n        },\n\n        get plainText() {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n\n            return webpageUtils.getWindowContent(browser.contentWindow,\n                                    browser.docShell, true, privProp.settings.plainTextAllContent);\n        },\n\n        sendEvent: function(eventType, arg1, arg2, button, modifier) {\n\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n\n            eventType = eventType.toLowerCase();\n            browser.contentWindow.focus();\n            let domWindowUtils = browser.contentWindow\n                                        .QueryInterface(Ci.nsIInterfaceRequestor)\n                                        .getInterface(Ci.nsIDOMWindowUtils);\n            if (modifier) {\n                let  m = 0;\n                let mod = this.event.modifier;\n                if (modifier & mod.shift) m |= domWindowUtils.MODIFIER_SHIFT;\n                if (modifier & mod.alt) m |= domWindowUtils.MODIFIER_ALT;\n                if (modifier & mod.ctrl) m |= domWindowUtils.MODIFIER_CONTROL;\n                if (modifier & mod.meta) m |= domWindowUtils.MODIFIER_META;\n                modifier = m;\n            }\n            else\n                modifier = 0;\n\n            if (eventType == 'keydown' || eventType == 'keyup') {\n                var keyCode = arg1;\n                if ((typeof keyCode) != \"number\") {\n                    if (keyCode.length == 0)\n                        return;\n                    keyCode = keyCode.charCodeAt(0);\n                }\n\n                let DOMKeyCode = convertQTKeyCode(keyCode);\n                if (DOMKeyCode.modifier && modifier == 0)\n                    modifier = DOMKeyCode.modifier;\n\n                if (DEBUG_WEBPAGE) {\n                    slDebugLog(\"webpage: sendEvent DOMEvent:\"+eventType+\" keycode:\"+DOMKeyCode.keyCode+\" charCode:\"+DOMKeyCode.charCode+\" mod:\"+modifier)\n                }\n                domWindowUtils.sendKeyEvent(eventType, DOMKeyCode.keyCode, DOMKeyCode.charCode, modifier);\n                return;\n            }\n            else if (eventType == 'keypress') {\n                let key = arg1;\n                if (typeof key == \"number\") {\n                    let DOMKeyCode = convertQTKeyCode(key);\n                    if (DEBUG_WEBPAGE) {\n                        slDebugLog(\"webpage: sendEvent DOMEvent:keypress keycode:\"+DOMKeyCode.keyCode+\" charCode:\"+DOMKeyCode.charCode+\" mod:\"+modifier)\n                    }\n                    domWindowUtils.sendKeyEvent(\"keypress\", DOMKeyCode.keyCode, DOMKeyCode.charCode, modifier);\n                }\n                else if (key.length == 1) {\n                    let charCode = key.charCodeAt(0);\n                    let DOMKeyCode = convertQTKeyCode(charCode);\n                    if (DEBUG_WEBPAGE) {\n                        slDebugLog(\"webpage: sendEvent DOMEvent:keypress keycode:\"+DOMKeyCode.keyCode+\" charCode:\"+charCode+\" mod:\"+modifier)\n                    }\n                    domWindowUtils.sendKeyEvent(\"keypress\", DOMKeyCode.keyCode, charCode, modifier);\n                }\n                else {\n                    if (DEBUG_WEBPAGE) {\n                        slDebugLog(\"webpage: sendEvent keydown,keypress,keyup for the string:'\"+key+\"' mod:\"+modifier)\n                    }\n                    for(let i=0; i < key.length;i++) {\n                        let charCode = key.charCodeAt(i);\n                        let DOMKeyCode = convertQTKeyCode(charCode);\n                        domWindowUtils.sendKeyEvent(\"keydown\", DOMKeyCode.keyCode, DOMKeyCode.charCode, modifier);\n                        domWindowUtils.sendKeyEvent(\"keypress\", DOMKeyCode.keyCode, charCode, modifier);\n                        domWindowUtils.sendKeyEvent(\"keyup\", DOMKeyCode.keyCode, DOMKeyCode.charCode, modifier);\n                    }\n                }\n                return;\n            }\n\n            let btn = 0;\n            if (button == 'middle')\n                btn = 1;\n            else if (button == 'right')\n                btn = 2;\n\n            let x = arg1 || 0;\n            let y = arg2 || 0;\n\n            if (DEBUG_WEBPAGE) {\n                slDebugLog(\"webpage: sendEvent \"+eventType+\" x:\"+x+\" y:\"+y+\" btn:\"+btn+\" mod:\"+modifier)\n            }\n\n            // mouse events\n            if (eventType == \"mousedown\" ||\n                eventType == \"mouseup\" ||\n                eventType == \"mousemove\") {\n                domWindowUtils.sendMouseEvent(eventType,\n                        x, y, btn, 1, modifier);\n                webpageUtils.sleepIfJavascriptURI(domWindowUtils, x, y)\n                return;\n            }\n            else if (eventType == \"mousedoubleclick\") {\n                // this type allowed by phantomjs has no really equivalence\n                // and tests in phantomjs show that it is simply... buggy\n                // note that is undocumented (2013-02-22)\n                domWindowUtils.sendMouseEvent(\"mousedown\",\n                        x, y, btn, 2, modifier);\n                webpageUtils.sleepIfJavascriptURI(domWindowUtils, x, y)\n                return;\n            }\n            else if (eventType == \"doubleclick\") {\n                domWindowUtils.sendMouseEvent(\"mousedown\",\n                        x, y, btn, 1, modifier);\n                domWindowUtils.sendMouseEvent(\"mouseup\",\n                        x, y, btn, 1, modifier);\n                domWindowUtils.sendMouseEvent(\"mousedown\",\n                        x, y, btn, 2, modifier);\n                domWindowUtils.sendMouseEvent(\"mouseup\",\n                        x, y, btn, 2, modifier);\n                webpageUtils.sleepIfJavascriptURI(domWindowUtils, x, y)\n                return;\n            }\n            else if (eventType == \"click\") {\n                domWindowUtils.sendMouseEventToWindow(\"mousedown\",\n                        x, y, btn, 1, modifier);\n                domWindowUtils.sendMouseEventToWindow(\"mouseup\",\n                        x, y, btn, 1, modifier);\n                webpageUtils.sleepIfJavascriptURI(domWindowUtils, x, y)\n                return;\n            }\n\n            throw new Error(\"Unknown event type\");\n        },\n\n        event : {\n            modifier : {\n                shift:  0x02000000,\n                ctrl:   0x04000000,\n                alt:    0x08000000,\n                meta:   0x10000000,\n                keypad: 0x20000000\n            },\n            key : phantomJSKeyCodeList.key // unicode values\n        },\n\n        get title() {\n            if (!browser) {\n                return '';\n            }\n            return browser.contentDocument.title;\n        },\n\n        setContent: function(content, url) {\n            if (!browser) {\n                openBlankBrowser(true);\n            }\n            browserJustCreated = false;\n            browser.webNavigation.stop(3);\n            let uri = browser.currentURI.clone();\n            if (url) {\n                // if url given, take it\n                uri = Services.io.newURI(url, null, null);\n            }\n            else {\n                url = uri.spec;\n            }\n\n            this.navigationRequested(url, 'Other', true, true);\n\n            if ((typeof content) != \"string\") {\n                // for given DOM node, serialize it\n                let encoder = Cc[\"@mozilla.org/layout/documentEncoder;1?type=text/html\"]\n                                .createInstance(Ci.nsIDocumentEncoder);\n                encoder.init(document, \"text/html\", de.OutputLFLineBreak | de.OutputRaw);\n                encoder.setNode(content);\n                content = encoder.encodeToString();\n            }\n\n            privProp.staticContentLoading = true;\n\n            webpageUtils.setWindowContent (browser.docShell, content, uri);\n\n            // wait until the content is loaded\n            let thread = Services.tm.currentThread;\n            while (privProp.staticContentLoading)\n                thread.processNextEvent(true);\n        },\n\n        /**\n         * set a file to an <input type=\"file\">. this can be a list of files.\n         * a click event is generated on the element.\n         * @param string selector  a CSS selector to an <input type=\"file\">\n         * @param string|array      list of files to select\n         */\n        uploadFile: function(selector, filename) {\n\n            if (!browser) {\n                return;\n            }\n            // check the selector\n            let exists = this.evaluate(function(sel){\n                    var el = document.querySelector(sel)\n                    return (el?true:false);\n                }, selector);\n\n            if (!exists) {\n                console.log(\"Warning uploadFile: \"+selector+\" does not exist\");\n                return;\n            }\n\n            // set files. Only take existing files.\n            let files;\n            if (!Array.isArray(filename))\n                files = [filename];\n            else\n                files = filename;\n\n            browser.uploadFiles = [];\n            files.forEach(function(file) {\n                try {\n                    let selectedFile = slUtils.getMozFile(file);\n                    if (selectedFile.exists()) {\n                        browser.uploadFiles.push(selectedFile);\n                    }\n                }\n                catch(e) {\n                }\n            });\n\n            if (!browser.uploadFiles.length) {\n                return\n            }\n            browser.uploadFilesReaded = false;\n            // send a click. It will open the file picker which will\n            // take browser.uploadFiles\n            this.evaluate(function(sel){\n                    var el = document.querySelector(sel);\n                    if (!el) {\n                        return;\n                    }\n                    var ev = document.createEvent('MouseEvents');\n                    ev.initEvent(\"click\", true, true);\n                    el.dispatchEvent(ev);\n                }, selector);\n\n            slUtils.sleep(500, function(){ return browser.uploadFilesReaded;} ); // wait after the file picker opening\n        },\n\n        // ------------------------------- Screenshot and pdf export\n\n        /**\n         * clipRect defines the rectangle to render from the webpage\n         * when calling render*() methods\n         */\n        get clipRect () {\n            if (privProp.clipRect)\n                return privProp.clipRect;\n            return {top:0, left:0, width:0, height:0}\n        },\n        set clipRect (value) {\n            let requirements = {\n                top: {\n                    is: [\"undefined\", \"number\"],\n                    ok: (val) => val === undefined || val >= 0,\n                    msg: \"clipRect.top should be a positive integer\"\n                },\n                left: {\n                    is: [\"undefined\", \"number\"],\n                    ok: (val) => val === undefined || val >= 0,\n                    msg: \"clipRect.left should be a positive integer\"\n                },\n                width: {\n                    is: [\"undefined\", \"number\"],\n                    ok: (val) => val === undefined || val >= 0,\n                    msg: \"clipRect.width should be a positive integer\"\n                },\n                height: {\n                    is: [\"undefined\", \"number\"],\n                    ok: (val) => val === undefined || val >= 0,\n                    msg: \"clipRect.height should be a positive integer\"\n                },\n            }\n            if (typeof(value) === \"object\") {\n                privProp.clipRect = heritage.mix({top:0, left:0, width:0, height:0},\n                                                 validateOptions(value, requirements));\n            } else {\n                privProp.clipRect = null;\n            }\n        },\n        /**\n         * dimensions for the PDF rendering\n         *  {width:'', height:'', margin:''}\n         *  or\n         *  {format:'', orientation:'', margin:''}\n         *\n         *  margin can be a single dimension or an object containing\n         *  one or more of the following properties: 'top', 'left', 'bottom', 'right'\n         *\n         *  format: \"A4\" etc.\n         *  orientation: \"landscape\" or \"portrait\"\n         *  dimension: supported unit \n         */\n        get paperSize () {\n            return privProp.paperSize;\n        },\n        set paperSize (val) {\n            privProp.paperSize = val;\n        },\n        get zoomFactor () {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n            return browser.markupDocumentViewer.fullZoom;\n        },\n        set zoomFactor (val) {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n            browser.markupDocumentViewer.fullZoom = val;\n            let domWindowUtils = browser.contentWindow\n                                        .QueryInterface(Ci.nsIInterfaceRequestor)\n                                        .getInterface(Ci.nsIDOMWindowUtils);\n            domWindowUtils.redraw(1);\n        },\n\n        render: function(filename, options) {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n\n            let file = fs.absolute(filename);\n\n            try {\n                let finalOptions = webpageUtils.getScreenshotOptions(this, options, fs.extension(file, true));\n                if (finalOptions.format == 'pdf') {\n                    let printOptions = webpageUtils.getPrintOptions(this, browser.contentWindow, file, finalOptions);\n                    if (printOptions === null) {\n                        return false;\n                    }\n                    return webpageUtils.renderPageAsPDF(browser.contentWindow, printOptions);\n                }\n\n                let canvas = webpageUtils.getScreenshotCanvas(\n                                            browser.contentWindow,\n                                            finalOptions.ratio,\n                                            finalOptions.onlyViewport, this);\n                let content = null;\n                canvas.toBlob(function(blob) {\n                    let reader = new browser.contentWindow.FileReader();\n                    reader.onloadend = function() {\n                        content = reader.result;\n                    }\n                    reader.readAsBinaryString(blob);\n                }, finalOptions.contentType, finalOptions.quality);\n\n                let thread = Services.tm.currentThread;\n                while (content === null) {\n                    thread.processNextEvent(true);\n                }\n\n                let dir = fs.directory(file);\n                if (!fs.exists(dir)) {\n                    fs.makeTree(dir);\n                }\n\n                fs.write(file, content, \"wb\");\n                return true;\n            }\n            catch(e) {\n                if (DEBUG_WEBPAGE) {\n                    dumpex(e);\n                }\n                return false;\n            }\n        },\n\n        renderBytes: function(options) {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n            try {\n                let finalOptions = webpageUtils.getScreenshotOptions(this, options);\n                let canvas = webpageUtils.getScreenshotCanvas(\n                                            browser.contentWindow,\n                                            finalOptions.ratio,\n                                            finalOptions.onlyViewport, this);\n                let content = null;\n                canvas.toBlob(function(blob) {\n                    let reader = new browser.contentWindow.FileReader();\n                    reader.onloadend = function() {\n                        content = reader.result;\n                    }\n                    reader.readAsBinaryString(blob);\n                }, finalOptions.contentType, finalOptions.quality);\n\n                let thread = Services.tm.currentThread;\n                while (content === null) {\n                    thread.processNextEvent(true);\n                }\n                return content;\n            }\n            catch(e) {\n                if (DEBUG_WEBPAGE) {\n                    dumpex(e);\n                }\n                return null;\n            }\n        },\n\n        renderBase64: function(options) {\n            if (!browser)\n                throw new Error(\"WebPage not opened\");\n            let finalOptions = webpageUtils.getScreenshotOptions(this, options)\n\n            let canvas = webpageUtils.getScreenshotCanvas(browser.contentWindow,\n                                            finalOptions.ratio, finalOptions.onlyViewport, this);\n\n            return canvas.toDataURL(finalOptions.contentType, finalOptions.quality).split(\",\", 2)[1];\n        },\n\n        //--------------------------------------------------- window popup callback\n\n        onAlert : null,\n\n        onAuthPrompt: null,\n\n        onCallback : null,\n\n        onConfirm : null,\n\n        onConsoleMessage : null,\n\n        onFilePicker : null,\n\n        onPrompt : null,\n        \n        onLongRunningScript : null,\n\n        // ------------------------------ browsing callbacks\n\n        // This callback is invoked after the web page is created but before a URL is loaded. The callback may be used to change global objects (document...)\n        onInitialized: null,\n\n        //This callback is invoked when the page finishes the loading. It may accept a single argument indicating the page's status: 'success' if no network errors occurred, otherwise 'fail'.\n        onLoadFinished: null,\n\n        //This callback is invoked when the page starts the loading. There is no argument passed to the callback.\n        onLoadStarted: null,\n\n        onNavigationRequested: null,\n\n        // This callback is invoked when a new child window (but not deeper descendant windows) is created by the page, e.g. using window.open\n        onPageCreated: null,\n\n        onResourceError : null,\n\n        onResourceTimeout : null,\n\n        onResourceRequested : null,\n\n        onResourceReceived : null,\n\n        //This callback is invoked when the URL changes, e.g. as it navigates away from the current URL.\n        onUrlChanged : null,\n\n        // Callback invoked when a file is downloaded .\n        onFileDownload : null,\n\n        onFileDownloadError: null,\n\n        // -------------------------------- private methods to send some events\n        closing:function (page) {\n            executePageListener(this, 'onClosing', [page]);\n        },\n\n        initialized: function() {\n            webPageSandbox = null;\n            if (browser) {\n                let ds = browser.docShell;\n                ds.allowImages = privProp.settings.loadImages;\n                ds.allowJavascript = privProp.settings.javascriptEnabled;\n            }\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onInitialized\");\n            }\n            executePageListener(this, 'onInitialized');\n        },\n\n        javaScriptAlertSent: function(message) {\n            executePageListener(this, 'onAlert', [message]);\n        },\n\n        javaScriptConsoleMessageSent: function(message, lineNumber, fileName) {\n            executePageListener(this, 'onConsoleMessage', [message, lineNumber, fileName]);\n        },\n\n        loadFinished: function(status, url, isFrame) {\n            browserJustCreated = false;\n            webPageSandbox = null;\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onLoadFinished status:\"+status+\" url:\"+url+\" isFrame:\"+isFrame);\n            }\n            executePageListener(this, 'onLoadFinished', [status, url, isFrame]);\n        },\n\n        loadStarted: function(url, isFrame) {\n            webPageSandbox = null;\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onLoadStarted url:\"+url+\" isFrame:\"+isFrame);\n            }\n            executePageListener(this, 'onLoadStarted', [url, isFrame]);\n        },\n\n        /**\n         * @param string url  the url of the requested page\n         * @param string navigationType a string indicated the origin:\n         *          \"Undefined\" \"LinkClicked\" \"FormSubmitted\" \"BackOrForward\" \"Reload\" \"FormResubmitted\" \"Other\"\n         * @param boolean willNavigate  true if the navigation is not locked\n         * @param boolean isMainFrame true if it comes from the mainFrame\n         */\n\n        navigationRequested: function(url, navigationType, willNavigate, isMainFrame) {\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onNavigationRequested url:\"+url+\" navigationType:\"+navigationType+\" willNavigate:\"+willNavigate+\" isMainFrame:\"+isMainFrame);\n            }\n            executePageListener(this, 'onNavigationRequested', [url, navigationType, willNavigate, isMainFrame]);\n        },\n\n        rawPageCreated: function(page) {\n            executePageListener(this, 'onPageCreated', [page]);\n        },\n\n        resourceError: function(error) {\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onResourceError error:\"+slDebugGetObject(error));\n            }\n            executePageListener(this, 'onResourceError', [error]);\n        },\n\n        resourceTimeout: function(error) {\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onResourceTimeout error:\"+slDebugGetObject(error));\n            }\n            executePageListener(this, 'onResourceTimeout', [error]);\n        },\n\n        resourceReceived: function(resource) {\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onResourceReceived resource:\"+slDebugGetObject(resource, ['body']));\n            }\n\n            executePageListener(this, 'onResourceReceived', [resource])\n        },\n\n        resourceRequested: function(resource, request) {\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onResourceRequested resource:\"+slDebugGetObject(resource));\n            }\n            executePageListener(this, 'onResourceRequested', [resource, request]);\n        },\n\n        urlChanged: function(url) {\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onUrlChanged url:\"+url);\n            }\n            webPageSandbox = null;\n            executePageListener(this, 'onUrlChanged', [url]);\n        },\n\n        fileDownload : function(url, responseData) {\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onFileDownload \"+url);\n            }\n            return executePageListener(this, 'onFileDownload', [url, responseData]);\n        },\n\n        fileDownloadError : function(message) {\n            if (DEBUG_WEBPAGE_LOADING) {\n                slDebugLog(\"webpage: onFileDownloadError: \"+message);\n            }\n            executePageListener(this, 'onFileDownloadError', [message]);\n        }\n    };\n\n    function executePageListener(page, listener, args) {\n        if (page[listener]) {\n            try {\n                return page[listener].apply(page, args);\n            } catch(e) {\n                console.log(\"Error \"+listener+\": [\"+e.name+\"] \"+e.message+\" (\"+e.fileName+\" ; line:\"+e.lineNumber+\" col:\"+e.columnNumber+\")\");\n            }\n        }\n    }\n\n    // initialization\n    return openBlankBrowser(false);\n} // end of _create\n\n"}